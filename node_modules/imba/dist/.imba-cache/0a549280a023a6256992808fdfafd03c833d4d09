{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};\nconst $refs$ = Symbol.for('#refs'), $packed$ = Symbol.for('#packed');\n\n/*body*/\nclass ΩOPObject {\n\t\n\t\n\trolesΞfor(agent){\n\t\tlet checks;\n\t\t\n\t\tif (!(agent)) { return 0 };\n\t\t\n\t\tlet roles = (this[agent]?.$roles || 0) | (agent.$roles || 0);\n\t\t\n\t\tif (checks = OP.conditionalΞroles) {\n\t\t\t\n\t\t\tfor (let $1 = 0, $2 = iter$__(checks), $3 = $2.length; $1 < $3; $1++) {\n\t\t\t\tlet role = $2[$1];\n\t\t\t\tconsole.count('check role');\n\t\t\t\tif (role.check(agent,this)) {\n\t\t\t\t\t\n\t\t\t\t\troles |= role;\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (this.$up) {\n\t\t\t\n\t\t\troles |= this.$up.rolesΞfor(agent);\n\t\t};\n\t\treturn roles;\n\t}\n\t\n\troleΞnamesΞfor(agent){\n\t\t\n\t\treturn OPRole.namesΞfor(this.rolesΞfor(agent));\n\t}\n\t\n\t/**\n\t@returns { (number|boolean) }\n\t*/\n\treadableΞfor(agent,roles,deep = true){\n\t\t\n\t\troles ??= this.rolesΞfor(agent);\n\t\t\n\t\tlet key = this.ααid;\n\t\tif (key.R && (key.R & roles)==0) { return false };\n\t\tif (!(agent)) { return true };\n\t\tif (!(deep && this.hasOwnProperty('$parents'))) { return true };\n\t\t\n\t\tfor (let parent of iter$__(this.$parents)){\n\t\t\t\n\t\t\tif (parent.readableΞfor(agent,parent.rolesΞfor(agent),deep)) {\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t};\n\t\t};\n\t\treturn false;\n\t}\n\t\n\t// check if agent is allowed to add object to specific parent\n\t// can-add-parent\n\t// check if agent is allowed to remove object from specific parent\n\t// can-remove-parent\n\t\n\twritableΞfor(agent,roles){\n\t\t\n\t\tif (true && agent == null) { return true };\n\t\t\n\t\troles ??= this.rolesΞfor(agent);\n\t\t\n\t\tlet key = this.ααid;\n\t\t\n\t\tif (key.W && !((key.W & roles))) {\n\t\t\t\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\tif (!(this.hasOwnProperty('$parents'))) {\n\t\t\t\n\t\t\treturn true;\n\t\t};\n\t\t\n\t\tfor (let parent of iter$__(this.$parents)){\n\t\t\t\n\t\t\tlet proles = parent.rolesΞfor(agent);\n\t\t\t// find all the children-prop types\n\t\t\tlet kinds = parent.$shape.$children.$w;\n\t\t\tfor (let kind of iter$__((kinds || []))){\n\t\t\t\t\n\t\t\t\tif (kind.test(this)) {\n\t\t\t\t\t\n\t\t\t\t\tif (!((kind.W & proles))) {\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn true;\n\t}\n\t\n\tdehydrateΞfor(agent,roles,bitmap = OPFLAGS.FULL){\n\t\t\n\t\t// If it does not exist - just return negative rev\n\t\tif (!(this.existsΦ)) {\n\t\t\t\n\t\t\treturn {id: this.id,_rev: -1};\n\t\t};\n\t\t\n\t\troles ??= this.rolesΞfor(agent);\n\t\t\n\t\t// If we return\n\t\tif (!(this.readableΞfor(agent,roles))) { return };\n\t\t\n\t\tlet cache = this.$memo;\n\t\tlet key = (\"\" + roles + \":\" + bitmap);\n\t\t\n\t\t// TODO check if there are any lazy values at all\n\t\tif (cache[key]) {\n\t\t\t\n\t\t\treturn cache[key];\n\t\t};\n\t\t\n\t\tlet flags = OPFLAGS.CLOUD | OPFLAGS.FULL;\n\t\tlet shallow = (bitmap & OPFLAGS.FULL)==0;\n\t\t\n\t\tlet raw = this.$cloud;\n\t\t\n\t\tif (!(raw)) {\n\t\t\t\n\t\t\t// nothing to return??\n\t\t\treturn;\n\t\t};\n\t\t\n\t\tlet shape = this.$fields.$cloud;\n\t\tlet refs = [];\n\t\t\n\t\tlet obj = {_: flags,id: this.id};\n\t\tfor (let $4 = 0, $5 = Object.keys(raw), $6 = $5.length, k, v, f; $4 < $6; $4++){\n\t\t\tk = $5[$4];v = raw[k];\n\t\t\tif (f = shape[k]) {\n\t\t\t\t\n\t\t\t\tif (f.R && (f.R & roles)==0) { continue; };\n\t\t\t\tif (v == null) { continue; };\n\t\t\t\tif (shallow && f.lazy && !(f.refΦ) && k != 'id') {\n\t\t\t\t\t\n\t\t\t\t\tobj._ &= ~OPFLAGS.FULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tobj[k] = v;\n\t\t\t\t// Collecting all direct references and caching them on\n\t\t\t\t// dehydrated object in a single #refs array\n\t\t\t\tif (v && f.refΦ && !(f.enum) && (!(shallow) || !(f.lazy)) && !((f?.reftype?.virtualΦ))) {\n\t\t\t\t\t\n\t\t\t\t\tif (typeof v == 'string') {\n\t\t\t\t\t\t\n\t\t\t\t\t\trefs.push(v);\n\t\t\t\t\t} else if (v.constructor == Object) {\n\t\t\t\t\t\t\n\t\t\t\t\t\trefs.push(...Object.keys(v));\n\t\t\t\t\t} else if (v instanceof Array) {\n\t\t\t\t\t\t\n\t\t\t\t\t\trefs.push(...v);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (refs.length) {\n\t\t\t\n\t\t\tobj[$refs$] = refs;\n\t\t};\n\t\t\n\t\treturn cache[key] = obj;\n\t}\n\t\n\tpackΞfor(agent,roles,bitmap){\n\t\t\n\t\tlet o = this.dehydrateΞfor(agent,roles,bitmap);\n\t\tif (!(o)) { return };\n\t\treturn o[$packed$] = o[$packed$] || OP.msgpack.pack(o);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPObject');}\n};\nextend$__(OPObject.prototype,ΩOPObject.prototype);\n;\n","dependencies":[],"map":{"version":3,"file":"permissions.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/core/permissions.imba"],"sourcesContent":["extend class OPObject\n\n\tdef roles-for agent\n\t\treturn 0 unless agent\n\n\t\tlet roles = (self[agent]..$roles or 0) | (agent.$roles or 0)\n\n\t\tif let checks = OP.conditional-roles\n\t\t\tfor role in checks\n\t\t\t\tconsole.count('check role')\n\t\t\t\tif role.check(agent,self)\n\t\t\t\t\troles |= role\n\n\t\tif $up\n\t\t\troles |= $up.roles-for(agent)\n\t\troles\n\n\tdef role-names-for agent\n\t\tOPRole.names-for roles-for(agent)\n\n\tdef readable-for\\(number|boolean) agent, roles, deep = yes\n\t\troles ??= roles-for(agent)\n\n\t\tlet key = @@id\n\t\treturn no if key.R and key.R !& roles\n\t\treturn yes unless agent\n\t\treturn yes unless deep and hasOwnProperty('$parents')\n\n\t\tfor parent of $parents\n\t\t\tif parent.readable-for(agent,parent.roles-for(agent),deep)\n\t\t\t\treturn yes\n\t\tno\n\n\t# check if agent is allowed to add object to specific parent\n\t# can-add-parent\n\t# check if agent is allowed to remove object from specific parent\n\t# can-remove-parent\n\n\tdef writable-for agent, roles\n\t\treturn true if $node$ and agent == null\n\n\t\troles ??= roles-for(agent)\n\n\t\tlet key = @@id\n\n\t\tif key.W && !(key.W & roles)\n\t\t\treturn no\n\n\t\tunless hasOwnProperty('$parents')\n\t\t\treturn yes\n\n\t\tfor parent of $parents\n\t\t\tlet proles = parent.roles-for(agent)\n\t\t\t# find all the children-prop types\n\t\t\tlet kinds = parent.$shape.$children.$w\n\t\t\tfor kind of (kinds or [])\n\t\t\t\tif kind.test(self)\n\t\t\t\t\tif !(kind.W & proles)\n\t\t\t\t\t\treturn no\n\n\t\treturn yes\n\n\tdef dehydrate-for agent, roles, bitmap = OPFLAGS.FULL\n\t\t# If it does not exist - just return negative rev\n\t\tunless exists?\n\t\t\treturn {id: id, _rev: -1}\n\n\t\troles ??= roles-for(agent)\n\n\t\t# If we return\n\t\treturn unless readable-for(agent,roles)\n\n\t\tlet cache = $memo\n\t\tlet key = \"{roles}:{bitmap}\"\n\n\t\t# TODO check if there are any lazy values at all\n\t\tif cache[key]\n\t\t\treturn cache[key]\n\n\t\tlet flags = OPFLAGS.CLOUD | OPFLAGS.FULL\n\t\tlet shallow = bitmap !& OPFLAGS.FULL\n\n\t\tlet raw = $cloud\n\n\t\tunless raw\n\t\t\t# nothing to return??\n\t\t\treturn\n\n\t\tlet shape = $fields.$cloud\n\t\tlet refs = []\n\n\t\tlet obj = {_: flags, id: id}\n\t\tfor own k,v of raw\n\t\t\tif let f = shape[k]\n\t\t\t\tcontinue if f.R and f.R !& roles\n\t\t\t\tcontinue if v == null\n\t\t\t\tif shallow and f.lazy and !f.ref? and k != 'id'\n\t\t\t\t\tobj._ ~= OPFLAGS.FULL\n\t\t\t\t\tcontinue\n\n\t\t\t\tobj[k] = v\n\t\t\t\t# Collecting all direct references and caching them on\n\t\t\t\t# dehydrated object in a single #refs array\n\t\t\t\tif v and f.ref? and !f.enum and (!shallow or !f.lazy) and !(f..reftype..virtual?)\n\t\t\t\t\tif typeof v == 'string'\n\t\t\t\t\t\trefs.push(v)\n\t\t\t\t\telif v.constructor == Object\n\t\t\t\t\t\trefs.push(...Object.keys(v))\n\t\t\t\t\telif v isa Array\n\t\t\t\t\t\trefs.push(...v)\n\n\t\tif refs.length\n\t\t\tobj.#refs = refs\n\n\t\tcache[key] = obj\n\n\tdef pack-for agent, roles, bitmap\n\t\tlet o = dehydrate-for agent, roles, bitmap\n\t\treturn unless o\n\t\to.#packed = o.#packed or OP.msgpack.pack(o)\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };\nimport {run as imba_run, commit as imba_commit} from 'imba';\nconst $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__');\n\n/*body*/\nimport * as msgpackr from 'msgpackr';\nexport const Unpackr = msgpackr.Unpackr;\nexport const Packr = msgpackr.Packr;\nimport bx from 'base-x';\nexport const bx58 = bx('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport const bx32 = bx('ybndrfg8ejkmcpqxot1uwisza345h769');// z-base-32\n\nexport const bases = {\n\t32: bx32,\n\t58: bx58\n};\n\nconst STACK = [];\nlet WRITER = null;\nlet READER = null;\n\nconst OPTIONS = {\n\tuseRecords: 1 << 0,\n\tuseTimestamp32: 1 << 1,\n\tbundleStrings: 1 << 2,\n\tsequential: 1 << 3,\n\tencodeUndefinedAsNil: 1 << 4,\n\tmapsAsObjects: 1 << 5\n};\n\nconst defaultOptions = {\n\tuseRecords: true,\n\tuseTimestamp32: true\n};\n\nconst unpacker = new Unpackr(\n\t{useRecords: function(v) { return !(!(v.id)); },\n\tuseTimestamp32: true,\n\tmapsAsObjects: true,\n\tvariableMapSize: true}\n);\n\nconst safeUnpacker = new Unpackr(\n\t{copyBuffers: true,\n\tuseRecords: true,\n\tuseTimestamp32: true,\n\tmapsAsObjects: true}\n);\n\nexport const CustomMapping = {\n\tMESSAGE: 2,\n\tSTREAM: 3,\n\tRESPONSE: 4,\n\t\n\tOPObject: 1,\n\tMessage: 2,\n\tStreamValue: 3,\n\tFileSystem: 4,\n\tOPData: 5,\n\tServer: 6,\n\tOPSerialization: 7,\n\t\n\tBinaryChunk: 8,\n\tBinaryState: 9,\n\tBinaryChunkRequest: 10,\n\tBinaryPatch: 11,\n\tSiteManifest: 12,\n\tImageColors: 13,\n\tOPHandshake: 14,\n\tOPAssetUploaded: 15,\n\tOPMutation: 16,\n\tOPMutations: 17,\n\tOPBATCH: 17,\n\tOPSET: 18\n};\n\nexport const Serializers = {\n\tObject: {\n\t\twrite: function(item,typ,ctx) {\n\t\t\t\n\t\t\tlet ctor = item.constructor;\n\t\t\tlet ser = ctor?.serialize;\n\t\t\tif (ser instanceof Function) {\n\t\t\t\t\n\t\t\t\treturn ser.serialize(item,ctx);\n\t\t\t};\n\t\t\t\n\t\t\tlet o = {};\n\t\t\tfor (let $1 = 0, $2 = Object.keys(item), $3 = $2.length, k, v; $1 < $3; $1++){\n\t\t\t\tk = $2[$1];v = item[k];\n\t\t\t\to[k] = v;\n\t\t\t};\n\t\t\treturn o;\n\t\t},\n\t\t\n\t\tread: function(data,typ) {\n\t\t\t\n\t\t\t\n\t\t\tlet item = new typ();\n\t\t\tObject.assign(item,data);\n\t\t\treturn item;\n\t\t}\n\t}\n};\n\nexport const packr = new msgpackr.Packr();\n\nexport function register(code,cls,o = {}){\n\t\n\t// if it is called only with a class\n\tif (code == 0) {\n\t\t\n\t\tcode = CustomMapping[cls?.name];\n\t};\n\t\n\t// return register(nr,code)\n\t\n\tif (!(code)) {\n\t\t\n\t\tthrow \"cannot register msgpack extension without number\";\n\t};\n\t\n\tif (code) {\n\t\t\n\t\tCustomMapping[code] = cls;\n\t};\n\t\n\tlet opts = {\n\t\tClass: cls,\n\t\ttype: code,\n\t\twrite: function(item) {\n\t\t\t\n\t\t\treturn o.write ? o.write(item,cls,WRITER) : (((cls?.serialize?.(item,WRITER) ?? item.id)));\n\t\t},\n\t\tread: function(item) {\n\t\t\t\n\t\t\treturn o.read ? o.read(item,cls,READER) : (((cls?.deserialize?.(item,READER) ?? new cls(item,o,READER))));\n\t\t}\n\t};\n\t\n\treturn msgpackr.addExtension(opts);\n};\n\nfunction decodeOptions(value){\n\t\n\tlet o = {};\n\tfor (let $4 = 0, $5 = Object.keys(OPTIONS), $6 = $5.length, k, v; $4 < $6; $4++){\n\t\tk = $5[$4];v = OPTIONS[k];\n\t\to[k] = !(!((value & v)));\n\t};\n\treturn o;\n};\n\nfunction encodeOptions(value){\n\t\n\tlet out = 0;\n\tfor (let $7 = 0, $8 = Object.keys(value), $9 = $8.length, k, v; $7 < $9; $7++){\n\t\tk = $8[$7];v = value[k];\n\t\tlet bit = OPTIONS[k];\n\t\tif (!(!(v)) && bit) {\n\t\t\t\n\t\t\tout |= bit;\n\t\t};\n\t};\n\treturn out;\n};\n\nclass Context {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $10;\n\t\t($10 = $$.refs) !== undefined && (this.refs = $10);\n\t\t\n\t}\n\tconstructor($$ = null){\n\t\tthis[$__init__$]($$);\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $11;\n\t\tthis.refs = ($$ && ($11 = $$.refs) !== undefined) ? ($11) : [];\n\t\t\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Context');}\n};\n\nexport function concat(...buffers){\n\t\n\tlet size = 0;\n\tif (buffers.length == 1) {\n\t\t\n\t\treturn buffers[0];\n\t};\n\t\n\tfor (let $12 = 0, $13 = iter$__(buffers), $14 = $13.length; $12 < $14; $12++) {\n\t\tlet buf = $13[$12];\n\t\tsize += buf.length;\n\t};\n\t\n\tlet offset = 0;\n\tlet merged = new Uint8Array(size);\n\tfor (let i = 0, $15 = iter$__(buffers), $16 = $15.length; i < $16; i++) {\n\t\tlet buf = $15[i];\n\t\tmerged.set(buf,offset);\n\t\toffset += buf.length;\n\t};\n\treturn merged;\n};\n\nexport function bakeStructures(structs){\n\tvar $17;\n\t\n\tlet structures = [];\n\t$17 = [];\n\tfor (let $18 = 0, $19 = iter$__(structs), $23 = $19.length; $18 < $23; $18++) {\n\t\tlet item = $19[$18];\n\t\tlet obj = {};\n\t\tfor (let $20 = 0, $21 = iter$__(item), $22 = $21.length; $20 < $22; $20++) {\n\t\t\tlet k = $21[$20];\n\t\t\tobj[k] = 1;\n\t\t};\n\t\t$17.push(obj);\n\t};\n\tlet samples = $17;\n\tlet packr = new msgpackr.Packr(\n\t\t// structures: structures\n\t\t\t\t{getStructures: function() {\n\t\t\t\n\t\t\tconsole.warn(\"getStructures\",structures);\n\t\t\treturn [];\n\t\t},\n\t\t\n\t\tsaveStructures: function(structures) {\n\t\t\t\n\t\t\treturn console.warn(\"save structures?!\",structures);\n\t\t}}\n\t);\n\t\n\tlet res = packr.pack(samples);\n\tfor (let $24 = 0, $25 = iter$__(samples), $26 = $25.length; $24 < $26; $24++) {\n\t\tlet item = $25[$24];\n\t\tpackr.pack(item);\n\t};\n\tconsole.warn(\"baked?!\",packr,res,structures);\n\treturn {packr: packr,res: res,structures: structures};\n};\n\nexport function packCustom(value){\n\t\n\treturn packr.pack(value);\n};\n\nexport function pack(value,ctx = {}){\n\t\n\tlet prev = WRITER;\n\tWRITER = ctx;\n\tlet res = msgpackr.pack(value);\n\tWRITER = prev;\n\treturn res;\n};\n\nexport function getType(value){\n\t\n\tlet nr = (value[0] == 212) ? value[1] : null;\n\treturn nr && CustomMapping[nr] || null;\n};\n\nexport function packMultiple(...values){\n\t\n\tlet bins = [];\n\tfor (let $27 = 0, $28 = iter$__(values), $29 = $28.length; $27 < $29; $27++) {\n\t\tlet part = $28[$27];\n\t\tbins.push(pack(part));\n\t};\n\treturn concat(...bins);\n};\n\n/**\n@param {any} using\n*/\nexport function unpack(value,context = {},using = unpacker){\n\t\n\tlet prev = READER;\n\tSTACK.unshift(READER = context);\n\tif (value instanceof ArrayBuffer) {\n\t\t\n\t\tvalue = new Uint8Array(value);\n\t};\n\t\n\tlet res = using.unpack(value);\n\tSTACK.shift();\n\tREADER = prev;\n\treturn res;\n};\n\nexport function stringify(value,base = 58){\n\t\n\tlet bin = pack(value);\n\treturn bases[base].encode(bin);\n};\n\nexport function parse(value,base = 58){\n\t\n\tif (typeof value == 'string') {\n\t\t\n\t\tvalue = bases[base].decode(value);\n\t};\n\treturn unpack(value);\n};\n\n/**\n@param {any} using\n*/\nexport function unpackMultiple(value,context = {},using = unpacker){\n\t\n\tlet prev = READER;\n\tSTACK.unshift(READER = context);\n\tif (value instanceof ArrayBuffer) {\n\t\t\n\t\tvalue = new Uint8Array(value);\n\t};\n\tlet res = using.unpackMultiple(value);\n\tSTACK.shift();\n\tREADER = prev;\n\treturn res;\n};\n\nexport function unpackSafe(value,ctx = {}){\n\t\n\treturn unpack(value,ctx,safeUnpacker);\n};\n\nexport function unpackMultipleSafe(value,cb){\n\t\n\tif (value instanceof ArrayBuffer) {\n\t\t\n\t\tvalue = new Uint8Array(value);\n\t};\n\treturn cb ? safeUnpacker.unpackMultiple(value,cb) : safeUnpacker.unpackMultiple(value);\n};\n\n// export def isStreamable\n\nexport async function unpackStream(stream,handler){\n\tlet h;\n\t\n\tlet o = {};\n\t\n\tif (stream instanceof globalThis.Request) {\n\t\t\n\t\tstream = await stream;\n\t};\n\t\n\tif (stream instanceof globalThis.Response) {\n\t\t\n\t\tif (h = stream.headers.get('op-encoding')) {\n\t\t\t\n\t\t\to = decodeOptions(Number(h));\n\t\t};\n\t\t\n\t\t// Dropping the chunked parsing now since msgpack struggles\n\t\t// with it\n\t\tif (false) {};\n\t\t\n\t\tstream = stream.body;\n\t};\n\t\n\tif (stream.getReader instanceof Function) {\n\t\t\n\t\tstream = stream.getReader();\n\t};\n\t\n\tlet deserializer = new Deserializer(handler,o);\n\treturn deserializer.readStream(stream);\n};\n\nexport class Deserializer {\n\t\n\tconstructor(handler,o = {}){\n\t\t\n\t\tthis.handler = handler;\n\t\tthis.values = [];\n\t\tthis.structures = [];\n\t\tthis.bytesRead = 0;\n\t\tthis.stats = {entries: 0,chunks: []};\n\t\tthis.options = Object.assign({\n\t\t\tuseRecords: true,\n\t\t\tstructures: this.structures,\n\t\t\tmapsAsObjects: true\n\t\t},o);\n\t\tthis.state = new Context;\n\t\tthis.unpackr = new msgpackr.Unpackr(this.options);\n\t\t\n\t\tthis.rest = null;\n\t}\n\t\n\t/**\n\t@param {ReadableStreamDefaultReader} stream\n\t*/\n\tasync readStream(stream){\n\t\t\n\t\tlet t0 = Date.now();\n\t\t// if process.env.PROFILE\n\t\tif (!(stream.read)) {\n\t\t\t\n\t\t\tconsole.warn('cannot read',stream);\n\t\t};\n\t\t\n\t\tlet chunk;while (true){\n\t\t\t\n\t\t\tif (!((chunk = await stream.read(1024 * 10)))) {\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\tif (chunk.value) { this.write(chunk.value) };\n\t\t\tif (!(true)) {};\n\t\t\tif (chunk.done) { break; };\n\t\t};\n\t\t\n\t\t// if process.env.PROFILE\n\t\treturn this;\n\t}\n\t\n\twrite(chunk){\n\t\tvar self = this;\n\t\t\n\t\tlet startOffset = this.bytesRead;\n\t\tlet stat = {size: chunk.length,start: this.bytesRead};\n\t\tthis.bytesRead += chunk.length;\n\t\t\n\t\tthis.stats.chunks.push(stat);\n\t\tlet handling = null;\n\t\tlet last = null;\n\t\t\n\t\tif (this.rest) {\n\t\t\t\n\t\t\tlet mergedArray = new Uint8Array(this.rest.byteLength + chunk.byteLength);\n\t\t\t\n\t\t\tmergedArray.set(this.rest,0);\n\t\t\tmergedArray.set(chunk,this.rest.byteLength);\n\t\t\t\n\t\t\tchunk = mergedArray;\n\t\t\tstat.rest = this.rest;\n\t\t\tstat.size = chunk.byteLength;\n\t\t\tthis.rest = null;\n\t\t};\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tSTACK.unshift(this);\n\t\t\tlet prev = READER;\n\t\t\tREADER = this.state;\n\t\t\tlet count = 0;\n\t\t\t// not used for now\n\t\t\tlet commitΞevery = 100000;\n\t\t\tlet resume = null;\n\t\t\t\n\t\t\timba_run(function() {\n\t\t\t\t\n\t\t\t\treturn self.unpackr.unpackMultiple(chunk,function(item,start,end) {\n\t\t\t\t\t\n\t\t\t\t\tself.stats.entries++;\n\t\t\t\t\tcount++;\n\t\t\t\t\tlast = item;\n\t\t\t\t\tself.handler(handling = item,startOffset + start,startOffset + end,startOffset);\n\t\t\t\t\t// pause unpacking after some time\n\t\t\t\t\t\n\t\t\t\t\tif ((count % commitΞevery) == 0) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t// global.app..render!\n\t\t\t\t\t\tresume = end;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\treturn handling = null;\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\tREADER = prev;\n\t\t\tSTACK.shift();\n\t\t\t\n\t\t\tif (resume) {\n\t\t\t\t\n\t\t\t\timba_commit();\n\t\t\t\t// wait for it?\n\t\t\t\treturn setTimeout(function() { return self.write(chunk.slice(resume)); },0);\n\t\t\t};\n\t\t} catch (error) {\n\t\t\t\n\t\t\tstat.error = error;\n\t\t\tlet lpos = error.lastPosition;\n\t\t\t\n\t\t\tif (lpos == 0) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\ttrue;\n\t\t\t};\n\t\t\t\n\t\t\tif (lpos != undefined) {\n\t\t\t\t\n\t\t\t\t// stat.error = error\n\t\t\t\tlet structs = this.structures.slice(0);\n\t\t\t\t\n\t\t\t\tthis.bytesRead = startOffset + lpos;\n\t\t\t\tstat.structs = structs;\n\t\t\t\tstat.values = error.values;\n\t\t\t\treturn this.rest = chunk.slice(lpos);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tconsole.warn('error deserializing data',error,handling,error.incomplete);\n\t\t\t\tthrow error;\n\t\t\t};\n\t\t} finally {\n\t\t\t\n\t\t\treturn;\n\t\t};\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Deserializer');}\n};\n\nexport class Serializer {\n\t\n\tconstructor(o = {}){\n\t\t\n\t\t\n\t\to = Object.assign({useRecords: true,useTimestamp32: true,sequential: true,mapsAsObjects: true},o);\n\t\to.useRecords = function(obj) { return !(!(obj.id)); };// only use records for objects with id\n\t\t\n\t\tthis.state = new Context;\n\t\t\n\t\t\n\t\t\n\t\tthis.packr = new msgpackr.PackrStream(o);\n\t\tthis.on = this.packr.on.bind(packr);\n\t\t;\n\t}\n\t\n\twrite(data){\n\t\t\n\t\t// let prev = WRITER\n\t\tWRITER = this.state;\n\t\treturn this.packr.write(data);\n\t\t// WRITER = prev\n\t}\n\t\n\tget encoding(){\n\t\t\n\t\treturn encodeOptions(this.packr.packr);\n\t}\n\t\n\tpipe(reader){\n\t\t\n\t\treturn this.packr.pipe(reader);\n\t}\n\t\n\tend(){\n\t\t\n\t\treturn this.packr.end();\n\t}\n\t\n\tpause(){\n\t\t\n\t\treturn this.packr.pause();\n\t}\n\t\n\tresume(){\n\t\t\n\t\treturn this.packr.resume();\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Serializer');}\n};\n","dependencies":[],"map":{"version":3,"file":"msgpack.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/msgpack.imba"],"sourcesContent":["import * as msgpackr from 'msgpackr'\nexport const Unpackr = msgpackr.Unpackr\nexport const Packr = msgpackr.Packr\nimport bx from 'base-x'\nexport const bx58 = bx('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz')\nexport const bx32 = bx('ybndrfg8ejkmcpqxot1uwisza345h769') # z-base-32\n\nexport const bases = {\n\t32: bx32\n\t58: bx58\n}\n\nconst STACK = []\nlet WRITER = null\nlet READER = null\n\nconst OPTIONS = {\n\tuseRecords: 1 << 0\n\tuseTimestamp32: 1 << 1\n\tbundleStrings: 1 << 2\n\tsequential: 1 << 3\n\tencodeUndefinedAsNil: 1 << 4\n\tmapsAsObjects: 1 << 5\n}\n\nconst defaultOptions = {\n\tuseRecords: true\n\tuseTimestamp32: true\n}\n\nconst unpacker = new Unpackr(\n\tuseRecords: do(v) !!v.id\n\tuseTimestamp32: true\n\tmapsAsObjects: true\n\tvariableMapSize: true\n)\n\nconst safeUnpacker = new Unpackr(\n\tcopyBuffers: true\n\tuseRecords: true\n\tuseTimestamp32: true\n\tmapsAsObjects: true\n)\n\nexport const CustomMapping = {\n\tMESSAGE: 2\n\tSTREAM: 3\n\tRESPONSE: 4\n\n\tOPObject:1\n\tMessage:2\n\tStreamValue:3\n\tFileSystem: 4\n\tOPData: 5\n\tServer: 6\n\tOPSerialization: 7\n\n\tBinaryChunk:8\n\tBinaryState:9\n\tBinaryChunkRequest:10\n\tBinaryPatch:11\n\tSiteManifest:12\n\tImageColors:13\n\tOPHandshake:14\n\tOPAssetUploaded:15\n\tOPMutation:16\n\tOPMutations:17\n\tOPBATCH:17\n\tOPSET:18\n}\n\nexport const Serializers = {\n\tObject: {\n\t\twrite: do(item,typ,ctx)\n\t\t\tlet ctor = item.constructor\n\t\t\tlet ser = ctor..serialize\n\t\t\tif ser isa Function\n\t\t\t\treturn ser.serialize(item,ctx)\n\n\t\t\tlet o = {}\n\t\t\tfor own k,v of item\n\t\t\t\to[k] = v\n\t\t\treturn o\n\n\t\tread: do(data,typ)\n\n\t\t\tlet item = new typ()\n\t\t\tObject.assign(item,data)\n\t\t\treturn item\n\t}\n}\n\nexport const packr = new msgpackr.Packr()\n\nexport def register code,cls,o = {}\n\t# if it is called only with a class\n\tif code == 0\n\t\tcode = CustomMapping[cls..name]\n\n\t# return register(nr,code)\n\n\tif !code\n\t\tthrow \"cannot register msgpack extension without number\"\n\n\tif code\n\t\tCustomMapping[code] = cls\n\n\tlet opts = {\n\t\tClass: cls\n\t\ttype: code\n\t\twrite: do(item)\n\t\t\to.write ? o.write(item,cls,WRITER) : (cls..serialize(item,WRITER) ?? item.id)\n\t\tread: do(item)\n\t\t\to.read ? o.read(item,cls,READER) : (cls..deserialize(item,READER) ?? new cls(item,o,READER))\n\t}\n\n\tmsgpackr.addExtension(opts)\n\ndef decodeOptions value\n\tlet o = {}\n\tfor own k,v of OPTIONS\n\t\to[k] = !!(value & v)\n\treturn o\n\ndef encodeOptions value\n\tlet out = 0\n\tfor own k,v of value\n\t\tlet bit = OPTIONS[k]\n\t\tif !!v and bit\n\t\t\tout |= bit\n\treturn out\n\nclass Context\n\trefs = []\n\nexport def concat ...buffers\n\tlet size = 0\n\tif buffers.length == 1\n\t\treturn buffers[0]\n\n\tfor buf in buffers\n\t\tsize += buf.length\n\n\tlet offset = 0\n\tlet merged = new Uint8Array(size)\n\tfor buf,i in buffers\n\t\tmerged.set(buf,offset)\n\t\toffset += buf.length\n\treturn merged\n\nexport def bakeStructures structs\n\tlet structures = []\n\tlet samples = for item in structs\n\t\tlet obj = {}\n\t\tfor k in item\n\t\t\tobj[k] = 1\n\t\tobj\n\tlet packr = new msgpackr.Packr(\n\t\t# structures: structures\n\t\tgetStructures: do\n\t\t\tconsole.warn \"getStructures\",structures\n\t\t\treturn []\n\n\t\tsaveStructures: do(structures)\n\t\t\tconsole.warn \"save structures?!\",structures\n\t)\n\n\tlet res = packr.pack(samples)\n\tfor item in samples\n\t\tpackr.pack(item)\n\tconsole.warn \"baked?!\",packr,res,structures\n\treturn {packr,res,structures}\n\nexport def packCustom value\n\tpackr.pack(value)\n\nexport def pack value, ctx = {}\n\tlet prev = WRITER\n\tWRITER = ctx\n\tlet res = msgpackr.pack(value)\n\tWRITER = prev\n\treturn res\n\nexport def getType value\n\tlet nr = value[0] == 212 ? value[1] : null\n\tnr and CustomMapping[nr] or null\n\nexport def packMultiple ...values\n\tlet bins = []\n\tfor part in values\n\t\tbins.push(pack(part))\n\treturn concat(...bins)\n\nexport def unpack value, context = {}, using\\any = unpacker\n\tlet prev = READER\n\tSTACK.unshift(READER = context)\n\tif value isa ArrayBuffer\n\t\tvalue = new Uint8Array(value)\n\n\tlet res = using.unpack(value)\n\tSTACK.shift()\n\tREADER = prev\n\treturn res\n\nexport def stringify value, base = 58\n\tlet bin = pack(value)\n\tbases[base].encode(bin)\n\nexport def parse value, base = 58\n\tif typeof value == 'string'\n\t\tvalue = bases[base].decode(value)\n\tunpack(value)\n\nexport def unpackMultiple value, context = {}, using\\any = unpacker\n\tlet prev = READER\n\tSTACK.unshift(READER = context)\n\tif value isa ArrayBuffer\n\t\tvalue = new Uint8Array(value)\n\tlet res = using.unpackMultiple(value)\n\tSTACK.shift()\n\tREADER = prev\n\treturn res\n\nexport def unpackSafe value,ctx = {}\n\tunpack(value,ctx,safeUnpacker)\n\nexport def unpackMultipleSafe value,cb\n\tif value isa ArrayBuffer\n\t\tvalue = new Uint8Array(value)\n\tcb ? safeUnpacker.unpackMultiple(value,cb) : safeUnpacker.unpackMultiple(value)\n\n# export def isStreamable\n\nexport def unpackStream stream, handler\n\tlet o = {}\n\n\tif stream isa global.Request\n\t\tstream = await stream\n\n\tif stream isa global.Response\n\t\tif let h = stream.headers.get('op-encoding')\n\t\t\to = decodeOptions(Number(h))\n\n\t\t# Dropping the chunked parsing now since msgpack struggles\n\t\t# with it\n\t\tif false\n\t\t\tlet buf = await stream.arrayBuffer!\n\n\t\t\tlet bufarr = new Uint8Array(buf)\n\t\t\tlet deserializer = new Deserializer(handler,o)\n\t\t\tdeserializer.write(bufarr)\n\t\t\treturn deserializer\n\n\t\tstream = stream.body\n\n\tif stream.getReader isa Function\n\t\tstream = stream.getReader!\n\n\tlet deserializer = new Deserializer(handler,o)\n\tdeserializer.readStream(stream)\n\nexport class Deserializer\n\tdef constructor handler,o = {}\n\t\thandler = handler\n\t\tvalues = []\n\t\tstructures = []\n\t\tbytesRead = 0\n\t\tstats = {entries: 0,chunks:[]}\n\t\toptions = Object.assign({\n\t\t\tuseRecords: true\n\t\t\tstructures: structures\n\t\t\tmapsAsObjects: true\n\t\t}, o)\n\t\tstate = new Context\n\t\tunpackr = new msgpackr.Unpackr(options)\n\n\t\trest = null\n\n\tdef readStream stream\\ReadableStreamDefaultReader\n\t\tlet t0 = Date.now!\n\t\t# if process.env.PROFILE\n\t\tunless stream.read\n\t\t\tconsole.warn 'cannot read',stream\n\n\t\twhile true\n\t\t\tunless const chunk = await stream.read(1024 * 10)\n\t\t\t\tbreak\n\t\t\twrite(chunk.value) if chunk.value\n\t\t\timba.commit! unless $node$\n\t\t\tbreak if chunk.done\n\n\t\t# if process.env.PROFILE\n\t\treturn self\n\n\tdef write chunk\n\t\tlet startOffset = bytesRead\n\t\tlet stat = {size:chunk.length, start: bytesRead}\n\t\tbytesRead += chunk.length\n\n\t\tstats.chunks.push(stat)\n\t\tlet handling = null\n\t\tlet last = null\n\n\t\tif rest\n\t\t\tlet mergedArray = new Uint8Array(rest.byteLength + chunk.byteLength)\n\n\t\t\tmergedArray.set(rest, 0)\n\t\t\tmergedArray.set(chunk, rest.byteLength)\n\n\t\t\tchunk = mergedArray\n\t\t\tstat.rest = rest\n\t\t\tstat.size = chunk.byteLength\n\t\t\trest = null\n\n\t\ttry\n\t\t\tSTACK.unshift(self)\n\t\t\tlet prev = READER\n\t\t\tREADER = state\n\t\t\tlet count = 0\n\t\t\t# not used for now\n\t\t\tlet commit-every = 100000\n\t\t\tlet resume = null\n\n\t\t\timba.run do\n\t\t\t\tunpackr.unpackMultiple(chunk) do(item,start,end)\n\t\t\t\t\tstats.entries++\n\t\t\t\t\tcount++\n\t\t\t\t\tlast = item\n\t\t\t\t\thandler(handling = item,startOffset + start, startOffset + end,startOffset)\n\t\t\t\t\t# pause unpacking after some time\n\n\t\t\t\t\tif (count % commit-every) == 0\n\n\t\t\t\t\t\t# global.app..render!\n\t\t\t\t\t\tresume = end\n\t\t\t\t\t\treturn false\n\n\t\t\t\t\thandling = null\n\n\t\t\tREADER = prev\n\t\t\tSTACK.shift!\n\n\t\t\tif resume\n\t\t\t\timba.commit!\n\t\t\t\t# wait for it?\n\t\t\t\tsetTimeout(&,0) do write(chunk.slice(resume))\n\n\t\tcatch error\n\t\t\tstat.error = error\n\t\t\tlet lpos = error.lastPosition\n\n\t\t\tif lpos == 0\n\n\t\t\t\tyes\n\n\t\t\tif lpos != undefined\n\t\t\t\t# stat.error = error\n\t\t\t\tlet structs = structures.slice(0)\n\n\t\t\t\tbytesRead = startOffset + lpos\n\t\t\t\tstat.structs = structs\n\t\t\t\tstat.values = error.values\n\t\t\t\trest = chunk.slice(lpos)\n\t\t\telse\n\t\t\t\tconsole.warn 'error deserializing data',error,handling,error.incomplete\n\t\t\t\tthrow error\n\t\tfinally\n\t\t\treturn\n\nexport class Serializer\n\tdef constructor o = {}\n\n\t\to = Object.assign({ useRecords: yes, useTimestamp32: yes, sequential: yes, mapsAsObjects: yes },o)\n\t\to.useRecords = do(obj) !!obj.id # only use records for objects with id\n\n\t\tstate = new Context\n\t\tif $node$\n\n\t\t\tself.packr = new msgpackr.PackrStream(o)\n\t\t\ton = self.packr.on.bind(packr)\n\n\tdef write data\n\t\t# let prev = WRITER\n\t\tWRITER = state\n\t\tself.packr.write(data)\n\t\t# WRITER = prev\n\n\tget encoding\n\t\tencodeOptions(self.packr.packr)\n\n\tdef pipe reader\n\t\tself.packr.pipe(reader)\n\n\tdef end\n\t\tself.packr.end!\n\n\tdef pause\n\t\tself.packr.pause!\n\n\tdef resume\n\t\tself.packr.resume!\n"],"names":[],"mappings":";;;;;;;;AAAA,MAAM,CAAC,CAAC,IAAI,QAAQ,MAAM,UAAU;AACpC,MAAM,OAAO,OAAO,GAAG,QAAQ,CAAC,OAAO;AACvC,MAAM,OAAO,KAAK,GAAG,QAAQ,CAAC,KAAK;AACnC,MAAM,CAAC,EAAE,MAAM,QAAQ;AACvB,MAAM,OAAO,IAAI,GAAG,EAAE,CAAC,4DAA4D,CAAC;AACpF,MAAM,OAAO,IAAI,GAAG,EAAE,CAAC,kCAAkC,CAAC;;AAE1D,MAAM,OAAO,KAAK,GAAG;CACpB,EAAE,EAAE,IAAI;CACR,EAAE,EAAE,IAAI;CACR;;MAEK,KAAK,GAAG,EAAE;IACZ,MAAM,GAAG,IAAI;IACb,MAAM,GAAG,IAAI;;MAEX,OAAO,GAAG;CACf,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;CAClB,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;CACtB,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;CACrB,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;CAClB,oBAAoB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;CAC5B,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;CACrB;;MAEK,cAAc,GAAG;CACtB,UAAU,EAAE,IAAI;CAChB,cAAc,EAAE,IAAI;CACpB;;MAEK,QAAQ,GAAG,GAAG,CAAC,OAAO;EAC3B,UAAU,EAAE,QAAE,CAAC,CAAC,IAAE,OAAA,EAAC,EAAC,CAAC,CAAC,EAAE,CAAA,CAAA;CACxB,cAAc,EAAE,IAAI;CACpB,aAAa,EAAE,IAAI;CACnB,eAAe,EAAE,IAAI;CACrB;;MAEK,YAAY,GAAG,GAAG,CAAC,OAAO;EAC/B,WAAW,EAAE,IAAI;CACjB,UAAU,EAAE,IAAI;CAChB,cAAc,EAAE,IAAI;CACpB,aAAa,EAAE,IAAI;CACnB;;AAED,MAAM,OAAO,aAAa,GAAG;CAC5B,OAAO,EAAE,CAAC;CACV,MAAM,EAAE,CAAC;CACT,QAAQ,EAAE,CAAC;;CAEX,QAAQ,EAAC,CAAC;CACV,OAAO,EAAC,CAAC;CACT,WAAW,EAAC,CAAC;CACb,UAAU,EAAE,CAAC;CACb,MAAM,EAAE,CAAC;CACT,MAAM,EAAE,CAAC;CACT,eAAe,EAAE,CAAC;;CAElB,WAAW,EAAC,CAAC;CACb,WAAW,EAAC,CAAC;CACb,kBAAkB,EAAC,EAAE;CACrB,WAAW,EAAC,EAAE;CACd,YAAY,EAAC,EAAE;CACf,WAAW,EAAC,EAAE;CACd,WAAW,EAAC,EAAE;CACd,eAAe,EAAC,EAAE;CAClB,UAAU,EAAC,EAAE;CACb,WAAW,EAAC,EAAE;CACd,OAAO,EAAC,EAAE;CACV,KAAK,EAAC,EAAE;CACR;;AAED,MAAM,OAAO,WAAW,GAAG;CAC1B,MAAM,EAAE;EACP,KAAK,EAAE,QAAE,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAC;;OAClB,IAAI,GAAG,IAAI,CAAC,WAAW;OACvB,GAAG,GAAG,IAAI,EAAE,SAAS;GACzB,EAAE,EAAC,GAAG,YAAK,QAAQ,EAAA;;IAClB,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC;IAAA;;OAE3B,CAAC,GAAG,EAAE;GACV,GAAG,0EAAgB;;IAClB,CAAC,CAAA,CAAE,CAAC,GAAG,CAAC;IAAA;GACT,MAAM,CAAC,CAAC;GAAA;;EAET,IAAI,EAAE,QAAE,CAAC,IAAI,CAAC,GAAG,EAAC;;;OAEb,IAAI,GAAG,GAAG,CAAC,GAAG,EAAE;GACpB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;GACxB,MAAM,CAAC,IAAI;GAAA;EACZ;CACD;;AAED,MAAM,OAAO,KAAK,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE;;AAEzC,MAAM,CAAC,QAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAA;;;CAElC,EAAE,EAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAA;;EACX,IAAI,GAAG,aAAa,CAAA,GAAI,EAAE,IAAI,CAAC;EAAA;;;;CAIhC,EAAE,EAAC,EAAC,IAAI,CAAA,EAAA;;QACD,kDAAkD;EAAA;;CAEzD,EAAE,EAAC,IAAI,EAAA;;EACN,aAAa,CAAA,IAAK,CAAC,GAAG,GAAG;EAAA;;KAEtB,IAAI,GAAG;EACV,KAAK,EAAE,GAAG;EACV,IAAI,EAAE,IAAI;EACV,KAAK,EAAE,QAAE,CAAC,IAAI,EAAC;;UACd,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAI,CAAA,GAAG,EAAE,SAAS,EAAA,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAA;GAAC;EAC9E,IAAI,EAAE,QAAE,CAAC,IAAI,EAAC;;UACb,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAI,CAAA,GAAG,EAAE,WAAW,EAAA,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,CAAA;GAAC;EAC7F;;CAED,OAAA,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC;CAAA;;AAE5B,QAAG,CAAC,aAAa,CAAC,KAAK,CAAA;;KAClB,CAAC,GAAG,EAAE;CACV,GAAG,6EAAmB;;EACrB,CAAC,CAAA,CAAE,CAAC,GAAG,EAAC,GAAE,KAAK,CAAC,CAAC,CAAC,CAAC;EAAC;CACrB,MAAM,CAAC,CAAC;CAAA;;AAET,QAAG,CAAC,aAAa,CAAC,KAAK,CAAA;;KAClB,GAAG,GAAG,CAAC;CACX,GAAG,2EAAiB;;MACf,GAAG,GAAG,OAAO,CAAA,CAAE,CAAC;EACpB,EAAE,EAAC,EAAC,EAAC,CAAC,CAAA,CAAA,CAAC,EAAG,CAAC,GAAG,EAAA;;GACb,GAAG,CAAC,EAAE,CAAC,GAAG;GAAA;EAAA;CACZ,MAAM,CAAC,GAAG;CAAA;;AAEX,KAAK,CAAC,OAAO,EAAA;qCApIb;;YAqIC,IAAI,CAAA,wBAAJ,IAAI;;EArIL;uBAAA;;EAAA;kDAAA;;OAqIC,IAAI,oBAAJ,IAAI,CAAA,sBAAA,IAAG,EAAE;;EArIV;;;AAqIU,CAAA;;AAEV,MAAM,CAAC,QAAG,CAAC,MAAM,IAAI,OAAO,CAAA;;KACvB,IAAI,GAAG,CAAC;CACZ,EAAE,EAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,EAAA;;EACrB,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC;EAAA;;CAElB,GAAG,6BAAQ,OAAO,uCAAA;MAAd,GAAG;EACN,IAAI,IAAI,GAAG,CAAC,MAAM;EAAA;;KAEf,MAAM,GAAG,CAAC;KACV,MAAM,GAAG,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC;CACjC,GAAG,2BAAU,OAAO,mCAAA;MAAhB,GAAG;EACN,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC;EACtB,MAAM,IAAI,GAAG,CAAC,MAAM;EAAA;CACrB,MAAM,CAAC,MAAM;CAAA;;AAEd,MAAM,CAAC,QAAG,CAAC,cAAc,CAAC,OAAO,CAAA;;;KAC5B,UAAU,GAAG,EAAE;;CACL,GAAG,6BAAS,OAAO,uCAAA;MAAf,IAAI;MACjB,GAAG,GAAG,EAAE;EACZ,GAAG,6BAAM,IAAI,uCAAA;OAAT,CAAC;GACJ,GAAG,CAAA,CAAE,CAAC,GAAG,CAAC;GAAA;WACX,GAAG;EAAA;KAJA,OAAO;KAKP,KAAK,GAAG,GAAG,CAAC,QAAQ,CAAC,KAAK;;KAE7B,aAAa,EAAE,QAAE,GAAA;;GAChB,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,CAAA;GACvC,MAAM,CAAC,EAAE;GAAA;;EAEV,cAAc,EAAE,QAAE,CAAC,UAAU,EAAC;;GAC7B,OAAA,OAAO,CAAC,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAA;GAAA;EAC5C;;KAEG,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC;CAC7B,GAAG,6BAAS,OAAO,uCAAA;MAAf,IAAI;EACP,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;EAAA;CACjB,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,CAAA;CAC3C,MAAM,CAAC,CAAC,KAAK,QAAC,GAAG,MAAC,UAAU,aAAC;CAAA;;AAE9B,MAAM,CAAC,QAAG,CAAC,UAAU,CAAC,KAAK,CAAA;;CAC1B,OAAA,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC;CAAA;;AAElB,MAAM,CAAC,QAAG,CAAC,IAAI,CAAC,KAAK,CAAE,GAAG,GAAG,EAAE,CAAA;;KAC1B,IAAI,GAAG,MAAM;CACjB,MAAM,GAAG,GAAG;KACR,GAAG,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC;CAC9B,MAAM,GAAG,IAAI;CACb,MAAM,CAAC,GAAG;CAAA;;AAEX,MAAM,CAAC,QAAG,CAAC,OAAO,CAAC,KAAK,CAAA;;KACnB,EAAE,GAAG,CAAA,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAA,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI;CAC1C,OAAA,EAAE,CAAC,EAAG,CAAC,aAAa,CAAA,EAAG,CAAC,CAAC,EAAE,CAAC,IAAI;CAAA;;AAEjC,MAAM,CAAC,QAAG,CAAC,YAAY,IAAI,MAAM,CAAA;;KAC5B,IAAI,GAAG,EAAE;CACb,GAAG,6BAAS,MAAM,uCAAA;MAAd,IAAI;EACP,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;EAAA;CACtB,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC;CAAA;;;QAEsB,GAAG;;AAAhD,MAAM,CAAC,QAAG,CAAC,MAAM,CAAC,KAAK,CAAE,OAAO,GAAG,EAAE,CAAE,KAAK,GAAO,QAAQ,CAAA;;KACtD,IAAI,GAAG,MAAM;CACjB,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC;CAC/B,EAAE,EAAC,KAAK,YAAK,WAAW,EAAA;;EACvB,KAAK,GAAG,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC;EAAA;;KAE1B,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC;CAC7B,KAAK,CAAC,KAAK,EAAE;CACb,MAAM,GAAG,IAAI;CACb,MAAM,CAAC,GAAG;CAAA;;AAEX,MAAM,CAAC,QAAG,CAAC,SAAS,CAAC,KAAK,CAAE,IAAI,GAAG,EAAE,CAAA;;KAChC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC;CACrB,OAAA,KAAK,CAAA,IAAK,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC;CAAA;;AAExB,MAAM,CAAC,QAAG,CAAC,KAAK,CAAC,KAAK,CAAE,IAAI,GAAG,EAAE,CAAA;;CAChC,EAAE,EAAC,OAAO,KAAK,CAAC,EAAE,CAAC,QAAQ,EAAA;;EAC1B,KAAK,GAAG,KAAK,CAAA,IAAK,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC;EAAA;CAClC,OAAA,MAAM,CAAC,KAAK,CAAC;CAAA;;;QAEuC,GAAG;;AAAxD,MAAM,CAAC,QAAG,CAAC,cAAc,CAAC,KAAK,CAAE,OAAO,GAAG,EAAE,CAAE,KAAK,GAAO,QAAQ,CAAA;;KAC9D,IAAI,GAAG,MAAM;CACjB,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC;CAC/B,EAAE,EAAC,KAAK,YAAK,WAAW,EAAA;;EACvB,KAAK,GAAG,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC;EAAA;KAC1B,GAAG,GAAG,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC;CACrC,KAAK,CAAC,KAAK,EAAE;CACb,MAAM,GAAG,IAAI;CACb,MAAM,CAAC,GAAG;CAAA;;AAEX,MAAM,CAAC,QAAG,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,GAAG,EAAE,CAAA;;CACnC,OAAA,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC;CAAA;;AAE/B,MAAM,CAAC,QAAG,CAAC,kBAAkB,CAAC,KAAK,CAAC,EAAE,CAAA;;CACrC,EAAE,EAAC,KAAK,YAAK,WAAW,EAAA;;EACvB,KAAK,GAAG,GAAG,CAAC,UAAU,CAAC,KAAK,CAAC;EAAA;QAC9B,EAAE,GAAG,YAAY,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,cAAc,CAAC,KAAK,CAAC;CAAA;;;;AAIhF,MAAM,CAAC,cAAG,CAAC,YAAY,CAAC,MAAM,CAAE,OAAO,CAAA;;;KAClC,CAAC,GAAG,EAAE;;CAEV,EAAE,EAAC,MAAM,YAAK,UAAM,CAAC,OAAO,EAAA;;EAC3B,MAAM,SAAS,MAAM;EAAA;;CAEtB,EAAE,EAAC,MAAM,YAAK,UAAM,CAAC,QAAQ,EAAA;;EAC5B,EAAE,EAAK,CAAC,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,EAAA;;GAC3C,CAAC,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;GAAA;;;;EAI7B,EAAE,EAAC,KAAK;;EAQR,MAAM,GAAG,MAAM,CAAC,IAAI;EAAA;;CAErB,EAAE,EAAC,MAAM,CAAC,SAAS,YAAK,QAAQ,EAAA;;EAC/B,MAAM,GAAG,MAAM,CAAC,SAAS,EAAC;EAAA;;KAEvB,YAAY,GAAG,GAAG,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;CAC9C,OAAA,YAAY,CAAC,UAAU,CAAC,MAAM,CAAC;CAAA;;AAEhC,MAAM,CAAC,KAAK,CAAC,YAAY,EAAA;;CACpB,WAAW,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,CAAA;;EAC7B,KAAA,OAAO,GAAG,OAAO;EACjB,KAAA,MAAM,GAAG,EAAE;EACX,KAAA,UAAU,GAAG,EAAE;EACf,KAAA,SAAS,GAAG,CAAC;EACb,KAAA,KAAK,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,MAAM,EAAC,EAAE,CAAC;EAC9B,KAAA,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;GACvB,UAAU,EAAE,IAAI;GAChB,UAAU,EAAE,KAAA,UAAU;GACtB,aAAa,EAAE,IAAI;GACnB,CAAE,CAAC,CAAC;EACL,KAAA,KAAK,GAAG,GAAG,CAAC,OAAO;EACnB,KAAA,OAAO,GAAG,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAA,OAAO,CAAC;;EAEvC,KAAA,IAAI,GAAG,IAAI;EAAA;;;SAEU,2BAA2B;;OAA7C,UAAU,CAAC,MAAM,CAA4B;;MAC5C,EAAE,GAAG,IAAI,CAAC,GAAG,EAAC;;EAElB,EAAM,IAAC,MAAM,CAAC,IAAI,GAAA;;GACjB,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAA;GAAA;;mBAE5B,IAAI,CAAA;;GACT,EAAM,KAAO,KAAK,SAAS,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,IAAA;;;IAC3C;GACa,EAAE,EAAC,KAAK,CAAC,KAAK,IAAjC,KAAA,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,EAAA;GACL,EAAM,IAAC,IAAM;GACpB,EAAE,EAAC,KAAK,CAAC,IAAI;GAAA;;;EAGpB,MAAM,CAAC,IAAI;EAAA;;CAER,KAAK,CAAC,KAAK,CAAA;;;MACV,WAAW,GAAG,KAAA,SAAS;MACvB,IAAI,GAAG,CAAC,IAAI,EAAC,KAAK,CAAC,MAAM,CAAE,KAAK,EAAE,KAAA,SAAS,CAAC;EAChD,KAAA,SAAS,IAAI,KAAK,CAAC,MAAM;;EAEzB,KAAA,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;MACnB,QAAQ,GAAG,IAAI;MACf,IAAI,GAAG,IAAI;;EAEf,EAAE,EAAC,KAAA,IAAI,EAAA;;OACF,WAAW,GAAG,GAAG,CAAC,UAAU,CAAC,KAAA,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC;;GAEpE,WAAW,CAAC,GAAG,CAAC,KAAA,IAAI,CAAE,CAAC,CAAC;GACxB,WAAW,CAAC,GAAG,CAAC,KAAK,CAAE,KAAA,IAAI,CAAC,UAAU,CAAC;;GAEvC,KAAK,GAAG,WAAW;GACnB,IAAI,CAAC,IAAI,GAAG,KAAA,IAAI;GAChB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,UAAU;GAC5B,KAAA,IAAI,GAAG,IAAI;GAAA;;MAET;;GACF,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;OACf,IAAI,GAAG,MAAM;GACjB,MAAM,GAAG,KAAA,KAAK;OACV,KAAK,GAAG,CAAC;;OAET,YAAY,GAAG,MAAM;OACrB,MAAM,GAAG,IAAI;;GAEjB,QAAQ,CAAC,QAAE,GAAA;;IACV,OAAA,KAAA,OAAO,CAAC,cAAc,CAAC,KAAK,CAAE,QAAE,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAC;;KAC/C,KAAA,KAAK,CAAC,OAAO,EAAE;KACf,KAAK,EAAE;KACP,IAAI,GAAG,IAAI;KACX,KAAA,OAAO,CAAC,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,CAAE,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC;;;KAG3E,EAAE,GAAE,KAAK,CAAC,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC,EAAA;;;;MAG7B,MAAM,GAAG,GAAG;MACZ,MAAM,CAAC,KAAK;MAAA;;KAEb,OAAA,QAAQ,GAAG,IAAI;KAAA,CAba;IAab,CAdT;;GAgBR,MAAM,GAAG,IAAI;GACb,KAAK,CAAC,KAAK,EAAC;;GAEZ,EAAE,EAAC,MAAM,EAAA;;IACR,WAAW,EAAC;;IAEZ,OAAA,UAAU,CAAM,QAAE,YAAC,KAAA,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,IAAhC,CAAC,CAAC;IAA8B;GAAA,eAEpC;;GACV,IAAI,CAAC,KAAK,GAAG,KAAK;OACd,IAAI,GAAG,KAAK,CAAC,YAAY;;GAE7B,EAAE,EAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAA;;;IAEX,IAAG;IAAA;;GAEJ,EAAE,EAAC,IAAI,CAAC,EAAE,CAAC,SAAS,EAAA;;;QAEf,OAAO,GAAG,KAAA,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;;IAEjC,KAAA,SAAS,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI;IAC9B,IAAI,CAAC,OAAO,GAAG,OAAO;IACtB,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM;IAC1B,OAAA,KAAA,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC;IAAA,MACrB;;IACH,OAAO,CAAC,IAAI,CAAC,0BAA0B,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAA;UACjE,KAAK;IAAA;GAAA,SACN;;GACN,MAAM;GAAA;EAAA;;;AAAA,CAAA;;AAET,MAAM,CAAC,KAAK,CAAC,UAAU,EAAA;;CAClB,WAAW,CAAC,CAAC,GAAG,EAAE,CAAA;;;EAErB,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAE,UAAU,EAAE,IAAG,CAAE,cAAc,EAAE,IAAG,CAAE,UAAU,EAAE,IAAG,CAAE,aAAa,EAAE,IAAG,CAAE,CAAC,CAAC,CAAC;EAClG,CAAC,CAAC,UAAU,GAAG,QAAE,CAAC,GAAG,IAAE,OAAA,EAAC,EAAC,GAAG,CAAC,EAAE,CAAA,CAAA;;EAE/B,KAAA,KAAK,GAAG,GAAG,CAAC,OAAO;EACV;;;EAER,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC;EACxC,KAAA,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC;EAAA;EAAA;;CAE5B,KAAK,CAAC,IAAI,CAAA;;;EAEb,MAAM,GAAG,KAAA,KAAK;EACd,OAAA,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC;;EACP;;CAEhB,GAAG,CAAC,QAAQ,EAAA;;EACX,OAAA,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;EAAA;;CAE5B,IAAI,CAAC,MAAM,CAAA;;EACd,OAAA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;EAAA;;CAEpB,GAAG,EAAA;;EACN,OAAA,IAAI,CAAC,KAAK,CAAC,GAAG,EAAC;EAAA;;CAEZ,KAAK,EAAA;;EACR,OAAA,IAAI,CAAC,KAAK,CAAC,KAAK,EAAC;EAAA;;CAEd,MAAM,EAAA;;EACT,OAAA,IAAI,CAAC,KAAK,CAAC,MAAM,EAAC;EAAA;;;AAAA,CAAA;AACpB;"}},"css":{"code":""},"warnings":[],"errors":[]}
{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction decorate$__(decorators,target,key,desc){\n\tvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\tif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\telse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\treturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport {αlazy as imba_αlazy, αthenable as imba_αthenable, use_hooks as imba_use_hooks, hooks as imba_hooks, emit as imba_emit, listen as imba_listen, once as imba_once, unlisten as imba_unlisten, reportObserved as imba_reportObserved, createRef as imba_createRef, observable as imba_observable, autorun as imba_autorun} from 'imba';\n(imba_use_hooks());\nconst $changed$ = Symbol.for('#changed'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $$views$ = Symbol.for('##views'), $dirty$ = Symbol.for('#dirty'), $v$ = Symbol.for('#v'), $filter$ = Symbol.for('#filter');\nvar $1 = Symbol(), $2 = Symbol(), $3 = Symbol();\n\n/*body*/\nimport {R,W,D,RW,RWD} from '../protocol';\nconst OWNREF = Symbol.for(\"~\");\n\nexport class Iterable extends Array {\n\t\n\t\n\ttoIterable(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tadd(item){\n\t\t\n\t\tif (this.indexOf(item) < 0) { this.push(item) };\n\t\treturn this;\n\t}\n\t\n\tdelete(item){\n\t\t\n\t\tlet idx = this.indexOf(item);\n\t\tif (idx >= 0) { this.splice(idx,1) };\n\t\treturn this;\n\t}\n\t\n\tselect(filter){\n\t\t\n\t\tlet views = this[$$views$] ||= new WeakMap;\n\t\tlet v = views.get(filter);\n\t\tv || views.set(filter,v = new LiveIterable(this,filter));\n\t\treturn v;\n\t}\n\t\n\tlog(...params){\n\t\t\n\t\treturn console.log(`%c iter`,`color:lightpurple`,...params);\n\t}\n\t\n\tclear(){\n\t\t\n\t\t// FIXME does not work with the observables\n\t\tthis.length = 0;\n\t\treturn this;\n\t}\n\t\n\thas(value){\n\t\t\n\t\treturn this.includes(value);\n\t}\n\t\n\tall(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tget size(){\n\t\t\n\t\treturn this.length;\n\t}\n\t\n\temit(name,...params){\n\t\treturn imba_emit(this,name,params);\n\t}\n\ton(name,...params){\n\t\treturn imba_listen(this,name,...params);\n\t}\n\tonce(name,...params){\n\t\treturn imba_once(this,name,...params);\n\t}\n\tun(name,...params){\n\t\treturn imba_unlisten(this,name,...params);\n\t}\n\t\n\tstatic get [Symbol.species](){\n\t\t\n\t\treturn Iterable;\n\t}\n\t\n\tslice(...args){\n\t\t\n\t\timba_reportObserved(this);\n\t\treturn super.slice(...args);\n\t\t// if self[OWNREF]\n\t\t// imba.report\n\t}\n\t\n\tfilter(cb){\n\t\t\n\t\timba_reportObserved(this);\n\t\treturn super.filter(...arguments);\n\t}\n\t\n\tget writableΦ(){\n\t\t\n\t\tif (this.owner && this.field) {\n\t\t\t\n\t\t\treturn OP.rights(this.owner,this.field) & W;\n\t\t};\n\t}\n\t\n\t// consider sort order\n\t\n\tstatic {\n\t\tdefineName$__(this,'Iterable');inheritClass$__(this);}\n};\n\nexport class Index extends Iterable {\n\t\n\t\n\tconstructor(owner,rel,order){\n\t\t\n\t\tsuper();\n\t\t// FIXME up / key could be something?\n\t\t// use $up/$key interface?\n\t\tthis.owner = owner;\n\t\tthis.rel = rel;\n\t\t/**@type {Map}*/ this.$scores = null;\n\t\t\n\t\tif (order) {\n\t\t\t\n\t\t\tthis.$sorter = function(a,b) { return b.__cre - a.__cre; };\n\t\t};\n\t\t\n\t\tthis[OWNREF] = imba_createRef();\n\t\tthis[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\tget $up(){\n\t\t\n\t\treturn this.owner;\n\t}\n\t\n\tincr(value,ref,score){\n\t\t\n\t\t// push(value)\n\t\t// need to work with reference counting for sure\n\t\tthis.add(value,score);\n\t\treturn this;\n\t}\n\t\n\tdecr(value,ref,score){\n\t\t\n\t\tthis.delete(value);\n\t\treturn this;\n\t}\n\t\n\tadd(member,score,field = null){\n\t\t\n\t\tif (score) {\n\t\t\t\n\t\t\t\n\t\t\t(this.$scores ||= new Map).set(member,score);\n\t\t};\n\t\tif (this.indexOf(member) < 0) { this.push(member) };\n\t\treturn this;\n\t}\n\t\n\t// rename to add when stable\n\tupdate(member,score){\n\t\t\n\t\t\n\t\t(this.$scores ||= new Map).set(member,score);\n\t\tthis[$changed$]();\n\t\treturn true;\n\t}\n\t\n\tpush(value){\n\t\t\n\t\tsuper.push(value);\n\t\tthis[$changed$]();\n\t\treturn value;\n\t}\n\t\n\tsplice(idx,toRemove,...toAdd){\n\t\t\n\t\tlet removed = super.splice(idx,toRemove,...toAdd);\n\t\tif (removed?.length || toAdd?.length) {\n\t\t\t\n\t\t\tthis[$changed$]();\n\t\t};\n\t\treturn removed;\n\t}\n\t\n\tdelete(value){\n\t\t\n\t\tsuper.delete(...arguments);\n\t\treturn this[$changed$]();\n\t}\n\t\n\ttoIterable(){\n\t\t\n\t\tthis.resolved;\n\t\timba_reportObserved(this);\n\t\t\n\t\treturn this;\n\t}\n\t\n\tflatMap(cb){\n\t\t\n\t\tthis.toIterable();\n\t\treturn super.flatMap(cb);\n\t}\n\t\n\tget size(){\n\t\t\n\t\tthis.toIterable();\n\t\treturn this.length;\n\t}\n\t\n\t// returns the index itself, but with a guarantee that\n\t// the actual underlying array is up-to-date\n\tget resolved(){\n\t\t\n\t\tif (this[$dirty$]) {\n\t\t\t\n\t\t\tthis[$dirty$] = false;\n\t\t\tthis[$v$] = (this[$v$] || 0) + 1;\n\t\t\tif (this.$scores && !(this.$sorter)) {\n\t\t\t\t\n\t\t\t\tlet map = this.$scores;\n\t\t\t\tthis.$sorter = function(a,b) { return map.get(a) - map.get(b); };\n\t\t\t};\n\t\t\tif (this.$sorter) { this.sort(this.$sorter) };\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t[$changed$](){\n\t\t\n\t\tthis[$dirty$] = true;\n\t\tthis[OWNREF].invalidated(0);\n\t\treturn imba_emit(this,'change');\n\t}\n\t\n\t[Symbol.match](item){\n\t\t\n\t\timba_reportObserved(this);\n\t\treturn this.has(item);\n\t}\n\t\n\t$accepts(value,context){\n\t\t\n\t\treturn this.owner?.$accepts?.(value,context);\n\t}\n\t\n\t$consume(value,context){\n\t\t\n\t\treturn this.owner?.$consume?.(value,context);\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'Index');inheritClass$__(this);}\n};\n\nexport class SortedIterable extends Index {\n\t\n\t\n\tpush(){\n\t\t\n\t\treturn super.push(...arguments);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'SortedIterable');inheritClass$__(this);}\n};\n\nexport class LiveIterable extends Iterable {\n\t\n\tconstructor(sources,filter,...items){\n\t\tvar self;\n\t\t\n\t\tsuper(...items);self = this;\n\t\tthis[OWNREF] = imba_createRef();\n\t\tthis.sources = sources;\n\t\t\n\t\tthis[$filter$] = filter;\n\t\tthis.filters = [filter];\n\t\timba_observable(this);\n\t\t\n\t\tthis.refresher = imba_autorun(function(_0) {\n\t\t\t\n\t\t\treturn self.refresh(_0);\n\t\t});\n\t\tthis;\n\t\tthis[$__initor__$]===$2 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\t[$changed$](){\n\t\t\n\t\treturn this[OWNREF].invalidated(0);\n\t}\n\t\n\t// generally need to\n\trefresh(reacted){\n\t\t\n\t\t\n\t\tlet items = this.sources;\n\t\tlet matches = [];\n\t\tlet k = 0;\n\t\tlet f = this[$filter$];\n\t\tlet dirty = false;\n\t\tlet len = this.length;\n\t\t\n\t\tfor (let i = 0, $4 = iter$__(items), $5 = $4.length; i < $5; i++) {\n\t\t\tlet item = $4[i];\n\t\t\tif (f[Symbol.match](item)) {\n\t\t\t\t\n\t\t\t\tthis[k++] = item;\n\t\t\t\tmatches.push(item);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (reacted) { reacted() };\n\t\t\n\t\tif (k != len) { // this is definitely not the only valid time for this\n\t\t\t\n\t\t\tthis.length = k;\n\t\t\tdirty = true;\n\t\t};\n\t\t\n\t\tif (dirty) {\n\t\t\t\n\t\t\treturn this[$changed$]();\n\t\t\t\n\t\t\t// TODO add reportChanged and reportObserved to the imba typings\n\t\t\t// Support changes based on ordering etc? What if it is the same\n\t\t\t// length but different models?\n\t\t\t// imba.reportChanged(self)\n\t\t};\n\t}\n\t\n\tat(index){\n\t\t\n\t\timba_reportObserved(this);\n\t\treturn super.at(...arguments);\n\t}\n\t\n\tslice(i){\n\t\t\n\t\timba_reportObserved(this);\n\t\treturn super.slice(...arguments);\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $2;defineName$__(this,'LiveIterable');inheritClass$__(this);}\n};\n\nexport class OPChildrenIndex extends Index {\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tthis[$__initor__$]===$3 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\tget preload(){\n\t\t\n\t\treturn OP.filter({$parent: this.$up,$batch: true});\n\t}\n\t\n\tasync resolve(){\n\t\t\n\t\t\n\t\t\n\t\tawait this.preload;// OP.filter($parent: $up, $batch: yes)\n\t\t;\n\t\treturn true;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $3;this.prototype[$__hooks__$] = imba_hooks;\n\t\tdefineName$__(this,'OPChildrenIndex');decorate$__([imba_αlazy.bind([])],this.prototype,'preload',null);\n\t\tdecorate$__([imba_αthenable.bind([])],this.prototype,'resolve',null);\n\t\tinheritClass$__(this);}\n}; globalThis.OPChildrenIndex = OPChildrenIndex;\n","dependencies":[],"map":{"version":3,"file":"iterable.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/core/iterable.imba"],"sourcesContent":["import { R, W, D, RW, RWD } from '../protocol'\nconst OWNREF = Symbol.for(\"~\")\n\nexport class Iterable < Array\n\n\tdef toIterable\n\t\tself\n\n\tdef add item\n\t\tpush(item) unless indexOf(item) >= 0\n\t\treturn self\n\n\tdef delete item\n\t\tlet idx = indexOf(item)\n\t\tsplice(idx,1) if idx >= 0\n\t\treturn self\n\n\tdef select filter\n\t\tlet views = ##views ||= new WeakMap\n\t\tlet v = views.get(filter)\n\t\tv or views.set(filter,v = new LiveIterable(this,filter))\n\t\treturn v\n\n\tdef log ...params\n\t\tconsole.log `%c iter`,`color:lightpurple`,...params\n\n\tdef clear\n\t\t# FIXME does not work with the observables\n\t\tself.length = 0\n\t\tself\n\n\tdef has value\n\t\tincludes(value)\n\n\tdef all\n\t\tself\n\n\tget size\n\t\tself.length\n\n\tdef emit name, ...params do imba.emit(self,name,params)\n\tdef on name, ...params do imba.listen(self,name,...params)\n\tdef once name, ...params do imba.once(self,name,...params)\n\tdef un name, ...params do imba.unlisten(self,name,...params)\n\n\tstatic get [Symbol.species]\n\t\tIterable\n\n\tdef slice ...args\n\t\timba.reportObserved(this)\n\t\tsuper(...args)\n\t\t# if self[OWNREF]\n\t\t#\timba.report\n\n\tdef filter cb\n\t\timba.reportObserved(this)\n\t\tsuper\n\n\tget writable?\n\t\tif owner and field\n\t\t\treturn OP.rights(owner,field) & W\n\n\t# consider sort order\n\nexport class Index < Iterable\n\n\tdef constructor owner, rel, order\n\t\tsuper()\n\t\t# FIXME up / key could be something?\n\t\t# use $up/$key interface?\n\t\tself.owner = owner\n\t\tself.rel = rel\n\t\tself.$scores\\Map = null\n\n\t\tif order\n\t\t\tself.$sorter = do(a,b) b.__cre - a.__cre\n\n\t\tself[OWNREF] = imba.createRef!\n\n\tget $up\n\t\towner\n\n\tdef incr value, ref, score\n\t\t# push(value)\n\t\t# need to work with reference counting for sure\n\t\tadd(value,score)\n\t\tself\n\n\tdef decr value, ref, score\n\t\tself.delete(value)\n\t\tself\n\n\tdef add member, score, field = null\n\t\tif score\n\n\t\t\t($scores ||= new Map).set(member,score)\n\t\tpush(member) unless indexOf(member) >= 0\n\t\tself\n\n\t# rename to add when stable\n\tdef update member, score\n\n\t\t($scores ||= new Map).set(member,score)\n\t\t#changed!\n\t\tyes\n\n\tdef push value\n\t\tsuper(value)\n\t\t#changed!\n\t\treturn value\n\n\tdef splice idx, toRemove,...toAdd\n\t\tlet removed = super(idx,toRemove,...toAdd)\n\t\tif removed..length or toAdd..length\n\t\t\t#changed!\n\t\treturn removed\n\n\tdef delete value\n\t\tsuper\n\t\t#changed!\n\n\tdef toIterable\n\t\tresolved\n\t\timba.reportObserved(this)\n\n\t\tself\n\n\tdef flatMap cb\n\t\ttoIterable!\n\t\tsuper(cb)\n\n\tget size\n\t\ttoIterable!\n\t\tself.length\n\n\t# returns the index itself, but with a guarantee that\n\t# the actual underlying array is up-to-date\n\tget resolved\n\t\tif #dirty\n\t\t\t#dirty = no\n\t\t\t#v = (#v or 0) + 1\n\t\t\tif $scores and !$sorter\n\t\t\t\tlet map = $scores\n\t\t\t\t$sorter = do(a,b) map.get(a) - map.get(b)\n\t\t\tsort($sorter) if $sorter\n\t\tself\n\n\tdef #changed\n\t\t#dirty = yes\n\t\tself[OWNREF].invalidated(0)\n\t\timba.emit(self,'change')\n\n\tdef [Symbol.match] item\n\t\timba.reportObserved(this)\n\t\thas(item)\n\n\tdef $accepts value,context\n\t\towner..$accepts(value,context)\n\n\tdef $consume value,context\n\t\towner..$consume(value,context)\n\nexport class SortedIterable < Index\n\n\tdef push\n\t\tsuper\n\nexport class LiveIterable < Iterable\n\tdef constructor sources,filter,...items\n\t\tsuper(...items)\n\t\tself[OWNREF] = imba.createRef!\n\t\tsources = sources\n\n\t\t#filter = filter\n\t\tfilters = [filter]\n\t\timba.observable(self)\n\n\t\trefresher = imba.autorun do\n\t\t\trefresh($1)\n\t\tself\n\n\tdef #changed\n\t\tself[OWNREF].invalidated(0)\n\n\t# generally need to\n\tdef refresh reacted\n\n\t\tlet items = sources\n\t\tlet matches = []\n\t\tlet k = 0\n\t\tlet f = #filter\n\t\tlet dirty = no\n\t\tlet len = self.length\n\n\t\tfor item,i in items\n\n\t\t\tif f[Symbol.match](item)\n\t\t\t\tself[k++] = item\n\t\t\t\tmatches.push(item)\n\n\t\treacted! if reacted\n\n\t\tif k != len # this is definitely not the only valid time for this\n\t\t\tself.length = k\n\t\t\tdirty = yes\n\n\t\tif dirty\n\t\t\t#changed!\n\n\t\t\t# TODO add reportChanged and reportObserved to the imba typings\n\t\t\t# Support changes based on ordering etc? What if it is the same\n\t\t\t# length but different models?\n\t\t\t# imba.reportChanged(self)\n\n\tdef at index\n\t\timba.reportObserved(this)\n\t\tsuper\n\n\tdef slice i\n\t\timba.reportObserved(this)\n\t\tsuper\n\nexport global class OPChildrenIndex < Index\n\n\t@lazy get preload\n\t\tOP.filter($parent: $up, $batch: yes)\n\n\t@thenable def resolve\n\t\tif $node$\n\t\t\tawait preload # OP.filter($parent: $up, $batch: yes)\n\t\treturn yes"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
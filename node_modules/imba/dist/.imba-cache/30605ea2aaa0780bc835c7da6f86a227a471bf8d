{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };\nimport {listen as imba_listen, createRef as imba_createRef} from 'imba';\nconst $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $v$ = Symbol.for('#v'), $sv$ = Symbol.for('#sv');\nvar $1 = Symbol(), $2 = Symbol();\n\n/*body*/\nimport './any';\nimport {Iterable,Index} from '../core/iterable';\nconst OWNREF = Symbol.for(\"~\");\n\n// @template [Type=any]\nexport class OPChildrenField extends OPField {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $3;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\t($3 = $$.pgtype) !== undefined && (this.pgtype = $3);\n\t\t($3 = $$.generated) !== undefined && (this.generated = $3);\n\t\t($3 = $$.virtual) !== undefined && (this.virtual = $3);\n\t\t($3 = $$.children) !== undefined && (this.children = $3);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $4;\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tthis.pgtype = ($$ && ($4 = $$.pgtype) !== undefined) ? ($4) : '';\n\t\tthis.generated = ($$ && ($4 = $$.generated) !== undefined) ? ($4) : true;\n\t\tthis.virtual = ($$ && ($4 = $$.virtual) !== undefined) ? ($4) : true;\n\t\tthis.children = ($$ && ($4 = $$.children) !== undefined) ? ($4) : true;\n\t\t\n\t}\n\t$get(target){\n\t\t\n\t\tif (!(target.hasOwnProperty(this.name))) {\n\t\t\t\n\t\t\tObject.defineProperty(target,this.name,{\n\t\t\t\tvalue: new OPChildren(target,this,...this.filters)\n\t\t\t});\n\t\t};\n\t\treturn target[this.name];\n\t\t// target[key] ||= new OPChildren(target,self,...filters)\n\t}\n\t\n\tget filters(){\n\t\t\n\t\treturn this.args;\n\t}\n\t\n\t$load(value,target){\n\t\t\n\t\treturn;\n\t}\n\t\n\ttest(item,target){\n\t\t\n\t\t// FIXME Should also potentially test other filters\n\t\tif (this.type) {\n\t\t\t\n\t\t\treturn item instanceof this.type;\n\t\t};\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'OPChildrenField');inheritClass$__(this);}\n}; globalThis.OPChildrenField = OPChildrenField;\n\nclass ΩOPObject {\n\t\n\t\n\t// @template [T=any]\n\t/**\n\t@param {T} type\n\t@returns { OPChildrenField<T> }\n\t*/\n\tαchildren(type,...filters){\n\t\t\n\t\treturn new OPChildrenField(type,...filters);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPObject');}\n};\nextend$__(OPObject.prototype,ΩOPObject.prototype);\n;\n\n/*\nSimple class that represents subsets of the $children index. Will probably\nmerge with other more general iterable type once we've covered cases with tests\n*/\n\nexport class OPChildren extends Iterable {\n\t\n\tstatic get [Symbol.species](){\n\t\t\n\t\treturn Iterable;\n\t}\n\t\n\tconstructor(owner,field,...filters){\n\t\tvar self;\n\t\t\n\t\tsuper();self = this;\n\t\t\n\t\t// make non-enumerable to hide from logs in node++\n\t\tObject.defineProperties(this,{\n\t\t\t$up: {value: owner,enumerable: false},\n\t\t\t$key: {value: field,enumerable: false},\n\t\t\t$filters: {value: filters,enumerable: false}\n\t\t// [Symbol.for(\"~\")]: {value: imba.createRef!, enumerable: false}\n\t\t});\n\t\t\n\t\timba_listen(this.$up.$children,'change',function() {\n\t\t\t\n\t\t\treturn self[OWNREF].invalidated(0);\n\t\t});\n\t\t\n\t\tthis[OWNREF] = imba_createRef();\n\t\tthis[$__initor__$]===$2 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\tget $source(){\n\t\t\n\t\t// By default, the source is all the children of object\n\t\treturn this.$up.$children;\n\t}\n\t\n\tget size(){\n\t\t\n\t\tthis.toIterable();\n\t\treturn this.length;\n\t}\n\t\n\thas(item){\n\t\t\n\t\tthis.resolved;\n\t\t// reportObserved?\n\t\treturn this.includes(item);\n\t}\n\t\n\tslice(...args){\n\t\t\n\t\tthis.resolved;\n\t\treturn super.slice(...arguments);\n\t}\n\t\n\tget resolved(){\n\t\t\n\t\tlet v = this.$source.resolved[$v$];\n\t\t// if the source-version has changed\n\t\tif ((this[$sv$] != v) ? ((this[$sv$] = v,true)) : false) {\n\t\t\t\n\t\t\tlet filters = this.$filters;\n\t\t\tlet single = filters.length == 1 && filters[0];\n\t\t\tlet filtered;\n\t\t\t\n\t\t\tif (single) {\n\t\t\t\t\n\t\t\t\tfiltered = this.$source.filter(function(item) { return single.test(item); });\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tfiltered = this.$source.filter(function(item) {\n\t\t\t\t\t\n\t\t\t\t\treturn filters.every(function(filter) { return filter.test(item); });\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\tfor (let i = 0, $5 = iter$__(filtered), $6 = $5.length; i < $6; i++) {\n\t\t\t\tlet item = $5[i];\n\t\t\t\tthis[i] = item;\n\t\t\t};\n\t\t\t\n\t\t\tthis.length = filtered.length;\n\t\t\tthis[OWNREF].invalidated(0);\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t// FIXME this is incredibly slow now - just for passing tests\n\t// Should not refilter everytime, and should be smart about\n\t// identifying if any of the filters need reactivity.\n\ttoIterable(){\n\t\t\n\t\tthis.resolved;\n\t\t// imba.reportObserved(this)\n\t\treturn this;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $2;defineName$__(this,'OPChildren');inheritClass$__(this);}\n}; globalThis.OPChildren = OPChildren;\n","dependencies":[],"map":{"version":3,"file":"children.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/fields/children.imba"],"sourcesContent":["import './any'\nimport {Iterable, Index} from '../core/iterable'\nconst OWNREF = Symbol.for(\"~\")\n\n# @template [Type=any]\nexport global class OPChildrenField < OPField\n\tpgtype = ''\n\tgenerated = yes\n\tvirtual = yes\n\tchildren = yes\n\n\tdef $get target\n\t\tunless target.hasOwnProperty(name)\n\t\t\tObject.defineProperty(target,name,{\n\t\t\t\tvalue: new OPChildren(target,self,...filters)\n\t\t\t})\n\t\treturn target[name]\n\t\t# target[key] ||= new OPChildren(target,self,...filters)\n\n\tget filters\n\t\targs\n\n\tdef $load value, target\n\t\treturn\n\n\tdef test item, target\n\t\t# FIXME Should also potentially test other filters\n\t\tif type\n\t\t\treturn item isa type\n\nextend class OPObject\n\n\t# @template [T=any]\n\tdef @children\\OPChildrenField<T> type\\T,...filters\n\t\tnew OPChildrenField(type,...filters)\n\n###\nSimple class that represents subsets of the $children index. Will probably\nmerge with other more general iterable type once we've covered cases with tests\n###\nexport global class OPChildren < Iterable\n\tstatic get [Symbol.species]\n\t\tIterable\n\n\tdef constructor owner,field,...filters\n\t\tsuper()\n\n\t\t# make non-enumerable to hide from logs in node++\n\t\tObject.defineProperties(self,{\n\t\t\t$up: {value: owner, enumerable: false}\n\t\t\t$key: {value: field, enumerable: false}\n\t\t\t$filters: {value: filters, enumerable: false}\n\t\t\t# [Symbol.for(\"~\")]: {value: imba.createRef!, enumerable: false}\n\t\t})\n\n\t\timba.listen($up.$children,'change') do\n\t\t\tself[OWNREF].invalidated(0)\n\n\t\tself[OWNREF] = imba.createRef!\n\n\tget $source\n\t\t# By default, the source is all the children of object\n\t\t$up.$children\n\n\tget size\n\t\ttoIterable!\n\t\treturn self.length\n\n\tdef has item\n\t\tresolved\n\t\t# reportObserved?\n\t\tincludes(item)\n\n\tdef slice ...args\n\t\tresolved\n\t\tsuper\n\n\tget resolved\n\t\tlet v = $source.resolved.#v\n\t\t# if the source-version has changed\n\t\tif #sv =? v\n\t\t\tlet filters = $filters\n\t\t\tlet single = filters.length == 1 and filters[0]\n\t\t\tlet filtered\n\n\t\t\tif single\n\t\t\t\tfiltered = $source.filter do(item) single.test(item)\n\t\t\telse\n\t\t\t\tfiltered = $source.filter do(item)\n\t\t\t\t\tfilters.every do(filter) filter.test(item)\n\n\t\t\tfor item,i in filtered\n\t\t\t\tself[i] = item\n\n\t\t\tself.length = filtered.length\n\t\t\tself[OWNREF].invalidated(0)\n\t\treturn self\n\n\t# FIXME this is incredibly slow now - just for passing tests\n\t# Should not refilter everytime, and should be smart about\n\t# identifying if any of the filters need reactivity.\n\tdef toIterable\n\t\tresolved\n\t\t# imba.reportObserved(this)\n\t\treturn self"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
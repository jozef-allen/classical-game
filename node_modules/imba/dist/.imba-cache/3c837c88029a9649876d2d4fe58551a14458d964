{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};\nimport {observable as imba_observable} from 'imba';\nconst $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $changed$ = Symbol.for('#changed');\nvar $1 = Symbol(), $2 = Symbol();\n\n/*body*/\nimport './any';\nimport {Iterable} from '../core/iterable';\n\n// @template [T=any]\nexport class OPFlagsField extends OPField {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $3;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\t($3 = $$.pgtype) !== undefined && (this.pgtype = $3);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $4;\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tthis.pgtype = ($$ && ($4 = $$.pgtype) !== undefined) ? ($4) : 'integer';\n\t\t\n\t}\n\t$set(value,target,key){\n\t\t\n\t\treturn this.$get(target,key).update(value);\n\t}\n\t\n\t$get(target,key){\n\t\t\n\t\treturn target[key] ||= new FlagsValue(target,this,{});\n\t}\n\t\n\t$load(value,target,key = this.key){\n\t\t\n\t\tif (value !== undefined) { this.$get(target,key).patch(value) };\n\t\treturn;\n\t}\n\t\n\tdiff(target,base,serialized){\n\t\t\n\t\tlet val = this.$get(target,this.key);\n\t\treturn val?.$diff ? val.$diff(base,serialized) : ((val?.serialize ? val.serialize(base) : val));\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'OPFlagsField');inheritClass$__(this);}\n}; globalThis.OPFlagsField = OPFlagsField;\n\nclass ΩOPObject {\n\t\n\t// @template [T=any]\n\t/**\n\t@param {T} type\n\t@returns { OPFlagsField<T> }\n\t*/\n\tαflags(type){\n\t\t\n\t\treturn new OPFlagsField(type);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPObject');}\n};\nextend$__(OPObject.prototype,ΩOPObject.prototype);\n;\n\n// use the field itself instead?\n// @template [X=any]\nexport class FlagsValue extends Iterable {\n\t\n\t\n\tconstructor(owner,field,options){\n\t\t\n\t\tsuper();\n\t\tthis.owner = owner;\n\t\tthis.field = field;\n\t\t// TODO use plain instead of raw consistently\n\t\t\n\t\t// Initing as null - so this will serialize to NULL\n\t\t// unless it has been either patched or set\n\t\tthis.raw = null;\n\t\tthis.type = field.meta.type;\n\t\timba_observable(this);\n\t\tthis[$__initor__$]===$2 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\tpluck(key){\n\t\t\n\t\treturn this.map(function(_0) { return _0[key]; });\n\t}\n\t\n\tadd(item){\n\t\t\n\t\tthis.update((this.raw || 0) | item);\n\t\treturn this;\n\t}\n\t\n\thas(item){\n\t\t\n\t\treturn (this.raw || 0) & (+item);\n\t}\n\t\n\ttoggle(item){\n\t\t\n\t\tconsole.log('toggle!',item,this.has(item));\n\t\treturn this.has(item) ? this.update((this.raw || 0) & ~item) : this.add(item);\n\t}\n\t\n\t// def delete item\n\t// \tupdate((raw or 0) & ~item)\n\t// \treturn self\n\t\n\t[$changed$](val = this.raw){\n\t\t\n\t\treturn this.owner.$changed(this.field.name,val,this.field);\n\t}\n\t\n\tget id(){\n\t\t\n\t\treturn (\"\" + (this.owner.id) + \"_\" + this.field.name.toUpperCase());\n\t}\n\t\n\tupdate(val){\n\t\t\n\t\tval = Number(val);\n\t\tif (val != (this.raw || 0)) {\n\t\t\t\n\t\t\t// How does this really work with patching?\n\t\t\tthis.patch(val);\n\t\t\tthis[$changed$]();\n\t\t};\n\t\treturn this;\n\t}\n\t\n\tpatch(v1){\n\t\tlet diff;\n\t\t\n\t\tif (diff = (this.raw || 0) ^ v1) {\n\t\t\t\n\t\t\t\n\t\t\tlet b = 0;\n\t\t\tlet num;\n\t\t\twhile ((num = 2 ** b) <= diff){\n\t\t\t\t\n\t\t\t\tif (diff & num) {\n\t\t\t\t\t\n\t\t\t\t\tlet item = this.type.bit(b);\n\t\t\t\t\t(v1 & num) ? this.push(item) : this.delete(item);\n\t\t\t\t};\n\t\t\t\tb++;\n\t\t\t};\n\t\t\tthis.raw = v1;\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t$patch(v1){\n\t\t\n\t\t// why not rather keep track of changes and local vs not local etc here?\n\t\treturn this.owner.sys.patch({[this.field.name]: v1});\n\t}\n\t\n\tserialize(){\n\t\t\n\t\treturn this.raw;\n\t}\n\t\n\tvalueOf(){\n\t\t\n\t\treturn this.raw || 0;\n\t}\n\t\n\ttoIterable(){\n\t\t\n\t\treturn console.log('toIterable Flags');\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $2;defineName$__(this,'FlagsValue');inheritClass$__(this);}\n};\n","dependencies":[],"map":{"version":3,"file":"flags.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/fields/flags.imba"],"sourcesContent":["import './any'\nimport {Iterable} from '../core/iterable'\n\n# @template [T=any]\nexport global class OPFlagsField < OPField\n\tpgtype = 'integer'\n\n\tdef $set value, target, key\n\t\tself.$get(target,key).update(value)\n\n\tdef $get target, key\n\t\ttarget[key] ||= new FlagsValue(target,self,{})\n\n\tdef $load value, target, key = key\n\t\tself.$get(target,key).patch(value) unless value === undefined\n\t\treturn\n\n\tdef diff target, base, serialized\n\t\tlet val = $get(target,key)\n\t\tval..$diff ? val.$diff(base,serialized) : (val..serialize ? val.serialize(base) : val)\n\nextend class OPObject\n\t# @template [T=any]\n\tdef @flags\\OPFlagsField<T> type\\T\n\t\tnew OPFlagsField(type)\n\n# use the field itself instead?\n# @template [X=any]\nexport class FlagsValue < Iterable\n\n\tdef constructor owner,field,options\n\t\tsuper()\n\t\towner = owner\n\t\tfield = field\n\t\t# TODO use plain instead of raw consistently\n\n\t\t# Initing as null - so this will serialize to NULL\n\t\t# unless it has been either patched or set\n\t\traw = null\n\t\ttype = field.meta.type\n\t\timba.observable(self)\n\n\tdef pluck key\n\t\tmap do $1[key]\n\n\tdef add item\n\t\tupdate((raw or 0) | item)\n\t\treturn self\n\n\tdef has item\n\t\t(raw or 0) & (+item)\n\n\tdef toggle item\n\t\tconsole.log 'toggle!',item,has(item)\n\t\thas(item) ? update((raw or 0) & ~item) : add(item)\n\n\t# def delete item\n\t# \tupdate((raw or 0) & ~item)\n\t# \treturn self\n\n\tdef #changed val = raw\n\t\towner.$changed(field.name,val,field)\n\n\tget id\n\t\t\"{owner.id}_{field.name.toUpperCase!}\"\n\n\tdef update val\n\t\tval = Number(val)\n\t\tif val != (raw or 0)\n\t\t\t# How does this really work with patching?\n\t\t\tpatch(val)\n\t\t\t#changed!\n\t\treturn self\n\n\tdef patch v1\n\t\tif let diff = (raw or 0) ^ v1\n\n\t\t\tlet b = 0\n\t\t\tlet num\n\t\t\twhile (num = 2 ** b) <= diff\n\t\t\t\tif diff & num\n\t\t\t\t\tlet item = type.bit(b)\n\t\t\t\t\tv1 & num ? push(item) : self.delete(item)\n\t\t\t\tb++\n\t\t\traw = v1\n\t\treturn self\n\n\tdef $patch v1\n\t\t# why not rather keep track of changes and local vs not local etc here?\n\t\towner.sys.patch({[field.name]: v1})\n\n\tdef serialize\n\t\traw\n\n\tdef valueOf\n\t\t(raw or 0)\n\n\tdef toIterable\n\t\tconsole.log 'toIterable Flags'"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction negIndex$__(value,index){ return value[value.length + index] };;\nfunction decorate$__(decorators,target,key,desc){\n\tvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\tif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\telse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\treturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport {αlazy as imba_αlazy, use_hooks as imba_use_hooks, hooks as imba_hooks, accessor as imba_accessor} from 'imba';\n(imba_use_hooks());\nconst $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__');\nvar $1 = Symbol(), $2 = Symbol('path'), $3 = Symbol(), $4 = Symbol('key'), $5 = Symbol(), $6 = Symbol('value'), $7 = Symbol(), $8 = Symbol('prev'), $9 = Symbol(), $10 = Symbol(), $37, $38, $39, $40;\n\n/*body*/\nimport '../protocol';\n\nconst APPLYING = 1 << 0;\nconst APPLIED = 1 << 1;\nconst REVERTING = 1 << 2;\nconst REVERTED = 1 << 3;\nconst PERSISTING = 1 << 4;\nconst PERSISTED = 1 << 5;\n\nconst DISCARDING = 1 << 6;\nconst DISCARDED = 1 << 7;\n\nclass OPMutation extends OPStruct {\n\t\n\t\n\t\n\t\n\t// parent mutation\n\t\n\tconstructor(...vals){\n\t\t\n\t\tif (vals.length == 1) {\n\t\t\t\n\t\t\tsuper();\n\t\t\tfor (let $13 = vals[0], $11 = 0, $12 = Object.keys($13), $14 = $12.length, k, v; $11 < $14; $11++){\n\t\t\t\tk = $12[$11];v = $13[k];\n\t\t\t\tthis[k] = v;\n\t\t\t};\n\t\t} else {\n\t\t\t\n\t\t\t// also include timestamp and flags?\n\t\t\tsuper(...arguments);\n\t\t};\n\t\tthis.$flags = 0;\n\t\tthis.$ts = OP.now;\n\t\tthis[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\tαindex(idx){\n\t\t\n\t\treturn {\n\t\t\t$set: function(val,target,slot,name) {\n\t\t\t\t\n\t\t\t\treturn target[idx] = (val ? val.valueOf() : val);\n\t\t\t},\n\t\t\t\n\t\t\t$get: function(target) {\n\t\t\t\t\n\t\t\t\treturn target[idx];\n\t\t\t},\n\t\t\t\n\t\t\t$init: function(v,target,slot,name) {\n\t\t\t\tlet val;\n\t\t\t\t\n\t\t\t\treturn val = target[idx];\n\t\t\t},\n\t\t\t\n\t\t\t$accessor: function(target,key,name,slot,context) {\n\t\t\t\t\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.key = key;\n\t\t\t\tcontext[slot] = context[(`_` + idx)] = this;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t}\n\t\n\t// commit the changes\n\tcommit(ctx){\n\t\tvar self = this;\n\t\t\n\t\treturn this.$committing ||= new Promise(async function(resolve) {\n\t\t\t\n\t\t\tawait self.$commit(ctx);\n\t\t\treturn resolve(self);\n\t\t});\n\t}\n\t\n\tasync $commit(ctx){\n\t\t\n\t\tif (!(this.applyingΦ || this.appliedΦ)) {\n\t\t\t\n\t\t\tawait this.apply(ctx);\n\t\t};\n\t\tif (!(this.persistingΦ || this.persistedΦ)) {\n\t\t\t\n\t\t\tawait this.persist(ctx);\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t$persisted(ctx){\n\t\t\n\t\treturn this;\n\t}\n\t\n\t// has mutation been applied?\n\tget applyingΦ(){\n\t\treturn this.$flags & APPLYING;\n\t}\n\tget appliedΦ(){\n\t\treturn this.$flags & APPLIED;\n\t}\n\t\n\tget persistableΦ(){\n\t\treturn !(this.persistingΦ) && !(this.persistedΦ);\n\t}\n\tget persistingΦ(){\n\t\treturn this.$flags & PERSISTING || !(!(this.$persisting));\n\t}\n\tget persistedΦ(){\n\t\treturn this.$flags & PERSISTED;\n\t}\n\tget revertingΦ(){\n\t\treturn this.$flags & REVERTING;\n\t}\n\tget revertedΦ(){\n\t\treturn this.$flags & REVERTED;\n\t}\n\t\n\tapplied(){\n\t\t\n\t\tthis.$flags |= APPLIED | APPLYING;\n\t\treturn this;\n\t}\n\t\n\tpersisted(ctx){\n\t\t\n\t\tif (((this.$flags & PERSISTED)==0) ? ((this.$flags |= PERSISTED,true)) : false) {\n\t\t\t\n\t\t\tthis.$persisted(ctx);\n\t\t};\n\t\tthis.$flags |= PERSISTING;\n\t\tthis.$persisting ||= Promise.resolve(this);\n\t\treturn this;\n\t}\n\t\n\tpersisting(promise = null){\n\t\t\n\t\tthis.$flags |= PERSISTING;\n\t\treturn this;\n\t}\n\t\n\treverted(){\n\t\t\n\t\t// rather use same applyed flags for reverting?\n\t\tthis.$flags |= REVERTING | REVERTED;\n\t\tthis.$flags &= ~APPLIED | APPLYING;\n\t\treturn this;\n\t}\n\t\n\tdiscarded(){\n\t\t\n\t\tthis.$flags |= DISCARDED;\n\t\treturn this;\n\t}\n\t\n\t// apply the actual changes in mutation\n\tapply(ctx = {}){\n\t\t\n\t\tif (((this.$flags & APPLYING)==0) ? ((this.$flags |= APPLYING,true)) : false) {\n\t\t\t\n\t\t\tthis.$apply(ctx);\n\t\t\tthis.applied();\n\t\t};\n\t\treturn true;\n\t}\n\t\n\tpersist(ctx = {}){\n\t\tvar self = this;\n\t\t\n\t\t\n\t\treturn this.$persisting ||= new Promise(async function(resolve,reject) {\n\t\t\t\n\t\t\t// what about failing?\n\t\t\t// if $flags |=? PERSISTING\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tself.$persisted = await self.$persist(ctx);\n\t\t\t\tself.persisted();\n\t\t\t\treturn resolve(self.$persisted);\n\t\t\t} catch (e) {\n\t\t\t\t\n\t\t\t\treturn reject(e);\n\t\t\t};\n\t\t});\n\t}\n\t\n\t// revert the mutation\n\trevert(ctx = {}){\n\t\t\n\t\tif (((this.$flags & REVERTING)==0) ? ((this.$flags |= REVERTING,true)) : false) {\n\t\t\t\n\t\t\tthis.$revert(ctx);\n\t\t};\n\t\treturn true;\n\t}\n\t\n\t// revert and completely discard the mutation\n\tasync discard(ctx = {}){\n\t\t\n\t\t// wait for all to be reverted?\n\t\tthis.revert(ctx);\n\t\t\n\t\tif (((this.$flags & DISCARDING)==0) ? ((this.$flags |= DISCARDING,true)) : false) {\n\t\t\t\n\t\t\tawait this.$discard(ctx);\n\t\t\tif (this.$up) {\n\t\t\t\t\n\t\t\t\tlet r = this.$up.delete(this);\n\t\t\t};\n\t\t\tthis.discarded();\n\t\t};\n\t\treturn true;\n\t}\n\t\n\t// see if this mutation can consume another mutation\n\tconsume(mut){\n\t\t\n\t\treturn true;\n\t}\n\t\n\t$apply(ctx){\n\t\t\n\t\treturn this;\n\t}\n\t\n\t$persist(ctx){\n\t\t\n\t\tif (false) {};\n\t\treturn this;\n\t}\n\t\n\t$revert(ctx){\n\t\t\n\t\treturn this;\n\t}\n\t\n\t$discard(ctx){\n\t\t\n\t\treturn this;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'OPMutation');inheritClass$__(this);}\n}; globalThis.OPMutation = OPMutation;\n\nclass OPMutations extends OPMutation {\n\t\n\t/**\n\t@returns { OPMutations[] }\n\t*/\n\tget mutations(){\n\t\treturn this;\n\t}\n\t\n\tstatic for(item){\n\t\t\n\t\tlet m = new OPMutations();\n\t\tm.$target = item;\n\t\treturn m;\n\t}\n\t\n\tpush(mut){\n\t\t\n\t\tif (!((mut instanceof OPMutation))) { return };\n\t\tif (!(mut.$up)) { Object.defineProperty(mut,'$up',{value: this}) };\n\t\tthis.$flags &= ~PERSISTING | PERSISTED;// could still be persisting?\n\t\tthis.$persisting = null;\n\t\t// committing should be reset as well?\n\t\tsuper.push(mut);\n\t\treturn mut;\n\t}\n\t\n\tasync commit_(){\n\t\t\n\t\t\n\t\t\n\t\tfor (let $15 = 0, $16 = iter$__(this.mutations), $17 = $16.length; $15 < $17; $15++) {\n\t\t\tlet mut = $16[$15];\n\t\t\tawait mut.commit(this);\n\t\t};\n\t\ttrue;\n\t\t;\n\t\tif (false) {};\n\t}\n\t\n\tasync $apply(){\n\t\t\n\t\tfor (let $18 = 0, $19 = iter$__(this.mutations), $20 = $19.length; $18 < $20; $18++) {\n\t\t\tlet mut = $19[$18];\n\t\t\tawait mut.apply(this);\n\t\t};\n\t\treturn this;\n\t}\n\t\n\tget size(){\n\t\t\n\t\treturn this.mutations.length;\n\t}\n\t\n\tget last(){\n\t\t\n\t\treturn negIndex$__(this.mutations,-1);\n\t}\n\t\n\tget unsavedΦ(){\n\t\t\n\t\treturn this.mutations.some(function(_0) { return !(_0.persistedΦ); });\n\t}\n\t\n\tasync $persist(ctx = {}){\n\t\t\n\t\t\n\t\t// Just include those mutations that are not already persisted\n\t\tlet all = this.filter(function(_0) { return _0.persistableΦ; });\n\t\t\n\t\t// FIXME could be mutations for different objects here?\n\t\t// if $target..local?\n\t\t// \tfor mut in all\n\t\t// \t\tawait mut.persist!\n\t\t// \treturn self\n\t\t\n\t\t\n\t\t\n\t\tlet updates = {};\n\t\tlet patches = [];\n\t\t\n\t\tfor (let $21 = 0, $22 = iter$__(all), $23 = $22.length; $21 < $23; $21++) {\n\t\t\tlet mut = $22[$21];\n\t\t\tif (!(mut.localΦ)) { mut.persisting(this) };\n\t\t};\n\t\t\n\t\t// collecting all [path: value] pairs from mutations\n\t\tfor (let $24 = 0, $25 = iter$__(all), $26 = $25.length; $24 < $26; $24++) {\n\t\t\tlet mut = $25[$24];\n\t\t\t\n\t\t\t\n\t\t\t// when a mut is local - it should not need to persist?\n\t\t\tif (mut.localΦ) {\n\t\t\t\t\n\t\t\t\tawait mut.persist();\n\t\t\t\tcontinue;\n\t\t\t};\n\t\t\t\n\t\t\t(updates[mut.$root] ||= {})[mut.$path] = mut.value;\n\t\t};\n\t\t\n\t\tfor (let $27 = 0, $28 = Object.keys(updates), $29 = $28.length, id, vals; $27 < $29; $27++){\n\t\t\tid = $28[$27];vals = updates[id];\n\t\t\tlet res = await OP.db.update(id,vals);\n\t\t\tpatches.push(res);\n\t\t\tOP.$patch(res);\n\t\t};\n\t\t\n\t\tfor (let mut of iter$__(all)){\n\t\t\t\n\t\t\tmut.persisted();\n\t\t};\n\t\t\n\t\treturn patches;\n\t\t;\n\t\t\n\t\tif (false) {};\n\t\treturn this;\n\t}\n\t\n\t$revert(ctx){\n\t\t\n\t\tfor (let $30 = 0, $31 = iter$__(this.mutations.slice(0).reverse()), $32 = $31.length; $30 < $32; $30++) {\n\t\t\tlet mut = $31[$30];\n\t\t\tmut.revert();\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t$discard(ctx){\n\t\t\n\t\tfor (let $33 = 0, $34 = iter$__(this.mutations.slice(0).reverse()), $35 = $34.length; $33 < $35; $33++) {\n\t\t\tlet mut = $34[$33];\n\t\t\tmut.discard();\n\t\t};\n\t\treturn this;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPMutations');inheritClass$__(this);}\n}; globalThis.OPMutations = OPMutations;\n\nclass OPSET extends OPMutation {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $36;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\tfields && ($36 = $$.path) !== undefined && this.ααpath.$init($36,this,$2,'path',$$);\n\t\tfields && ($36 = $$.key) !== undefined && this.ααkey.$init($36,this,$4,'key',$$);\n\t\tfields && ($36 = $$.value) !== undefined && this.ααvalue.$init($36,this,$6,'value',$$);\n\t\tfields && ($36 = $$.prev) !== undefined && this.ααprev.$init($36,this,$8,'prev',$$);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$10 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tfields && this.ααpath.$init($$ ? $$.path : undefined,this,$2,'path',$$);\n\t\tfields && this.ααkey.$init($$ ? $$.key : undefined,this,$4,'key',$$);\n\t\tfields && this.ααvalue.$init($$ ? $$.value : undefined,this,$6,'value',$$);\n\t\tfields && this.ααprev.$init($$ ? $$.prev : undefined,this,$8,'prev',$$);\n\t\t\n\t}\n\tset path(val){ this.ααpath.$set(val,this,$2,'path') }\n\tget path(){ return this.ααpath.$get(this,$2,'path') }\n\tget ααpath(){ return this[$3] || imba_accessor(($37 = this.αindex(0),$37),this,$2,'path',$3,OPSET.prototype) }\n\tset key(val){ this.ααkey.$set(val,this,$4,'key') }\n\tget key(){ return this.ααkey.$get(this,$4,'key') }\n\tget ααkey(){ return this[$5] || imba_accessor(($38 = this.αindex(1),$38),this,$4,'key',$5,OPSET.prototype) }\n\tset value(val){ this.ααvalue.$set(val,this,$6,'value') }\n\tget value(){ return this.ααvalue.$get(this,$6,'value') }\n\tget ααvalue(){ return this[$7] || imba_accessor(($39 = this.αindex(2),$39),this,$6,'value',$7,OPSET.prototype) }\n\tset prev(val){ this.ααprev.$set(val,this,$8,'prev') }\n\tget prev(){ return this.ααprev.$get(this,$8,'prev') }\n\tget ααprev(){ return this[$9] || imba_accessor(($40 = this.αindex(3),$40),this,$8,'prev',$9,OPSET.prototype) }\n\t\n\tstatic for(target,key,value,prev){\n\t\t\n\t\treturn new this(String(target),key,value,prev);\n\t}\n\t\n\t// target\n\tget object(){\n\t\t\n\t\treturn OP.get(this.path);\n\t}\n\t\n\tget target(){\n\t\t\n\t\treturn this.object;\n\t}\n\t\n\tget $type(){\n\t\t\n\t\treturn OP.getType(this.object);\n\t}\n\t\n\tget $root(){\n\t\t\n\t\treturn this.object.$root;\n\t}\n\t\n\tget $value(){\n\t\t\n\t\treturn this.value;\n\t}\n\t\n\tget localΦ(){\n\t\t\n\t\tif (this.$field?.localΦ) { return true };\n\t\treturn (this.$root instanceof OPPov) ? (!(this.$root.$up.persistedΦ)) : (!(this.$root.persistedΦ));\n\t\t// !$root.persisted? or target.local?\n\t}\n\t\n\tget $field(){\n\t\t\n\t\tlet obj = this.object;\n\t\tif (obj instanceof OPField) { return obj };\n\t\tlet field = obj.$fields && obj.$fields[this.key];\n\t\treturn field;\n\t}\n\t\n\tget $path(){\n\t\t\n\t\tlet pre = this.target.$path;\n\t\treturn pre ? ((\"\" + pre + `[` + this.key + `]`)) : this.key;\n\t}\n\t\n\t$revert(ctx){\n\t\t\n\t\treturn this.object.$fields[this.key].$set(this.prev,this.object,this);\n\t}\n\t\n\tasync $persist(ctx){\n\t\tlet p;\n\t\t\n\t\tlet upd = {[this.$path]: this.value};\n\t\tlet f = this.$field;\n\t\t\n\t\t// if field is local, is this where we persist it\n\t\tif (f?.localΦ) {\n\t\t\t\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tif (this.localΦ) {\n\t\t\t\n\t\t\t// is this not what apply should do?!\n\t\t\tlet d = this.$root.$plain;\n\t\t\tif (p = this.object.$path) {\n\t\t\t\t\n\t\t\t\tfor (let i = 0, $41 = iter$__(p.split('.')), $42 = $41.length; i < $42; i++) {\n\t\t\t\t\tlet k = $41[i];\n\t\t\t\t\td = (d[k] ||= {});\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tlet v = this.value;\n\t\t\tif (v?.$set) {\n\t\t\t\t\n\t\t\t\td[this.key] ||= {};\n\t\t\t\tfor (let $45 = v.$set, $43 = 0, $44 = Object.keys($45), $46 = $44.length, k2, v2; $43 < $46; $43++){\n\t\t\t\t\tk2 = $44[$43];v2 = $45[k2];\n\t\t\t\t\td[this.key][k2] = v2;\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\td[this.key] = v;\n\t\t\t};\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t\n\t\t\n\t\tlet patch = await OP.db.update(this.$root.id,upd);\n\t\tif (patch) {\n\t\t\t\n\t\t\tOP.$patch(patch);\n\t\t};\n\t\t\n\t\tif (this.$root instanceof OPPov) {\n\t\t\t\n\t\t\tnull;\n\t\t};\n\t\treturn patch;\n\t\t;\n\t\t\n\t\tif (false) {} else {\n\t\t\t\n\t\t\treturn super.$persist(...arguments);\n\t\t};\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $10;this.prototype[$__hooks__$] = imba_hooks;\n\t\tdefineName$__(this,'OPSET');decorate$__([imba_αlazy.bind([])],this.prototype,'object',null);\n\t\tinheritClass$__(this);}\n}; globalThis.OPSET = OPSET;\n\nclass OPADD extends OPSET {\n\t\n\tget $value(){\n\t\t\n\t\treturn {$add: String(this.value)};\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPADD');inheritClass$__(this);}\n}; globalThis.OPADD = OPADD;\n\nclass OPINCR extends OPSET {\n\t\n\tget $value(){\n\t\t\n\t\treturn {$incr: (this.value || 1)};\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPINCR');inheritClass$__(this);}\n}; globalThis.OPINCR = OPINCR;\n\nclass OPCRE extends OPSET {\n\t\n\tget $value(){\n\t\t\n\t\treturn {$add: String(this.value)};\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPCRE');inheritClass$__(this);}\n}; globalThis.OPCRE = OPCRE;\n\n","dependencies":[],"map":{"version":3,"file":"mutation.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/core/mutation.imba"],"sourcesContent":["import '../protocol'\n\nconst APPLYING   = 1 << 0\nconst APPLIED    = 1 << 1\nconst REVERTING  = 1 << 2\nconst REVERTED   = 1 << 3\nconst PERSISTING = 1 << 4\nconst PERSISTED  = 1 << 5\n\nconst DISCARDING = 1 << 6\nconst DISCARDED  = 1 << 7\n\nglobal class OPMutation < OPStruct\n\n\tdeclare static stack\\OPMutation\n\n\t# parent mutation\n\tdeclare $target\\OPObject\n\tdeclare $up\\OPMutation\n\n\tdef constructor ...vals\n\t\tif vals.length == 1\n\t\t\tsuper()\n\t\t\tfor own k,v of vals[0]\n\t\t\t\tself[k] = v\n\t\telse\n\t\t\t# also include timestamp and flags?\n\t\t\tsuper\n\t\t$flags = 0\n\t\t$ts = OP.now\n\n\tdef @index idx\n\t\treturn {\n\t\t\t$set: do(val,target,slot,name)\n\t\t\t\ttarget[idx] = (val ? val.valueOf() : val)\n\n\t\t\t$get: do(target)\n\t\t\t\ttarget[idx]\n\n\t\t\t$init: do(v,target,slot,name)\n\t\t\t\tlet val = target[idx]\n\n\t\t\t$accessor: do(target, key, name, slot, context)\n\t\t\t\tthis.name = name\n\t\t\t\tthis.key = key\n\t\t\t\tcontext[slot] = context[`_{idx}`] = this\n\t\t\t\tthis\n\t\t}\n\n\t# commit the changes\n\tdef commit ctx\n\t\t$committing ||= new Promise do(resolve)\n\t\t\tawait $commit(ctx)\n\t\t\tresolve(self)\n\n\tdef $commit ctx\n\t\tunless applying? or applied?\n\t\t\tawait apply(ctx)\n\t\tunless persisting? or persisted?\n\t\t\tawait persist(ctx)\n\t\treturn self\n\n\tdef $persisted ctx\n\t\tself\n\n\t# has mutation been applied?\n\tget applying? do $flags & APPLYING\n\tget applied? do $flags & APPLIED\n\n\tget persistable? do !persisting? and !persisted?\n\tget persisting? do $flags & PERSISTING or !!$persisting\n\tget persisted? do $flags & PERSISTED\n\tget reverting? do $flags & REVERTING\n\tget reverted? do $flags & REVERTED\n\n\tdef applied\n\t\t$flags |= APPLIED | APPLYING\n\t\tself\n\n\tdef persisted ctx\n\t\tif $flags |=? PERSISTED\n\t\t\t$persisted(ctx)\n\t\t$flags |= PERSISTING\n\t\t$persisting ||= Promise.resolve(self)\n\t\tself\n\n\tdef persisting promise = null\n\t\t$flags |= PERSISTING\n\t\tself\n\n\tdef reverted\n\t\t# rather use same applyed flags for reverting?\n\t\t$flags |= REVERTING | REVERTED\n\t\t$flags ~= APPLIED | APPLYING\n\t\tself\n\n\tdef discarded\n\t\t$flags |= DISCARDED\n\t\tself\n\n\t# apply the actual changes in mutation\n\tdef apply ctx = {}\n\t\tif $flags |=? APPLYING\n\t\t\t$apply(ctx)\n\t\t\tapplied!\n\t\tyes\n\n\tdef persist ctx = {}\n\n\t\t$persisting ||= new Promise do(resolve,reject)\n\t\t\t# what about failing?\n\t\t\t# if $flags |=? PERSISTING\n\t\t\ttry\n\t\t\t\t$persisted = await $persist(ctx)\n\t\t\t\tpersisted!\n\t\t\t\tresolve($persisted)\n\t\t\tcatch e\n\t\t\t\treject(e)\n\n\t# revert the mutation\n\tdef revert ctx = {}\n\t\tif $flags |=? REVERTING\n\t\t\t$revert(ctx)\n\t\tyes\n\n\t# revert and completely discard the mutation\n\tdef discard ctx = {}\n\t\t# wait for all to be reverted?\n\t\trevert(ctx)\n\n\t\tif $flags |=? DISCARDING\n\t\t\tawait $discard(ctx)\n\t\t\tif $up\n\t\t\t\tlet r = $up.delete(self)\n\t\t\tdiscarded!\n\t\tyes\n\n\t# see if this mutation can consume another mutation\n\tdef consume mut\n\t\tyes\n\n\tdef $apply ctx\n\t\tself\n\n\tdef $persist ctx\n\t\tif $web$\n\t\t\tlet res = await OP.server.commit(self)\n\t\t\treturn res\n\t\tself\n\n\tdef $revert ctx\n\t\tself\n\n\tdef $discard ctx\n\t\tself\n\nglobal class OPMutations < OPMutation\n\tget mutations\\OPMutations[] do self\n\n\tstatic def for item\n\t\tlet m = new OPMutations()\n\t\tm.$target = item\n\t\treturn m\n\n\tdef push mut\n\t\treturn unless mut isa OPMutation\n\t\tObject.defineProperty(mut,'$up',{value: self}) unless mut.$up\n\t\t$flags ~= PERSISTING | PERSISTED # could still be persisting?\n\t\t$persisting = null\n\t\t# committing should be reset as well?\n\t\tsuper(mut)\n\t\treturn mut\n\n\tdef commit_\n\t\tif $node$\n\t\t\tfor mut in mutations\n\t\t\t\tawait mut.commit(self)\n\t\t\tyes\n\t\tif $web$\n\t\t\t# different than persisting for sure\n\t\t\tfor mut in mutations\n\t\t\t\tawait mut.commit(self)\n\n\tdef $apply\n\t\tfor mut in mutations\n\t\t\tawait mut.apply(self)\n\t\tself\n\n\tget size\n\t\tmutations.length\n\n\tget last\n\t\tmutations[-1]\n\n\tget unsaved?\n\t\tmutations.some do !$1.persisted?\n\n\tdef $persist ctx = {}\n\n\t\t# Just include those mutations that are not already persisted\n\t\tlet all = filter do $1.persistable?\n\n\t\t# FIXME could be mutations for different objects here?\n\t\t# if $target..local?\n\t\t# \tfor mut in all\n\t\t# \t\tawait mut.persist!\n\t\t# \treturn self\n\n\t\tif $node$\n\t\t\tlet updates = {}\n\t\t\tlet patches = []\n\n\t\t\tfor mut in all\n\t\t\t\tmut.persisting(self) unless mut.local?\n\n\t\t\t# collecting all [path: value] pairs from mutations\n\t\t\tfor mut in all\n\n\t\t\t\t# when a mut is local - it should not need to persist?\n\t\t\t\tif mut.local?\n\t\t\t\t\tawait mut.persist!\n\t\t\t\t\tcontinue\n\n\t\t\t\t(updates[mut.$root] ||= {})[mut.$path] = mut.value\n\n\t\t\tfor own id,vals of updates\n\t\t\t\tlet res = await OP.db.update(id,vals)\n\t\t\t\tpatches.push(res)\n\t\t\t\tOP.$patch(res)\n\n\t\t\tfor mut of all\n\t\t\t\tmut.persisted!\n\n\t\t\treturn patches\n\n\t\tif $web$\n\t\t\tif all.length\n\t\t\t\tlet res = await OP.server.commit(OPMutations.of(...all))\n\t\tself\n\n\tdef $revert ctx\n\t\tfor mut in mutations.slice(0).reverse!\n\t\t\tmut.revert!\n\t\treturn self\n\n\tdef $discard ctx\n\t\tfor mut in mutations.slice(0).reverse!\n\t\t\tmut.discard!\n\t\treturn self\n\nglobal class OPSET < OPMutation\n\tpath @index(0)\n\tkey @index(1)\n\tvalue @index(2)\n\tprev @index(3)\n\n\tstatic def for target,key,value,prev\n\t\tnew self(String(target),key,value,prev)\n\n\t# target\n\t@lazy get object\n\t\tOP.get(path)\n\n\tget target\n\t\tobject\n\n\tget $type\n\t\tOP.getType(object)\n\n\tget $root\n\t\tobject.$root\n\n\tget $value\n\t\tvalue\n\n\tget local?\n\t\treturn yes if $field..local?\n\t\treturn $root isa OPPov ? !$root.$up.persisted? : !$root.persisted?\n\t\t# !$root.persisted? or target.local?\n\n\tget $field\n\t\tlet obj = object\n\t\treturn obj if obj isa OPField\n\t\tlet field = obj.$fields and obj.$fields[key]\n\t\treturn field\n\n\tget $path\n\t\tlet pre = target.$path\n\t\tpre ? `{pre}[{key}]` : key\n\n\tdef $revert ctx\n\t\tobject.$fields[key].$set(prev,object,self)\n\n\tdef $persist ctx\n\t\tlet upd = {[$path]: value}\n\t\tlet f = $field\n\n\t\t# if field is local, is this where we persist it\n\t\tif f..local?\n\t\t\treturn self\n\n\t\tif local?\n\t\t\t# is this not what apply should do?!\n\t\t\tlet d = $root.$plain\n\t\t\tif let p = object.$path\n\t\t\t\tfor k,i in p.split('.')\n\t\t\t\t\td = (d[k] ||= {})\n\n\t\t\tlet v = value\n\t\t\tif v..$set\n\t\t\t\td[key] ||= {}\n\t\t\t\tfor own k2,v2 of v.$set\n\t\t\t\t\td[key][k2] = v2\n\t\t\telse\n\t\t\t\td[key] = v\n\t\t\treturn self\n\n\t\tif $node$\n\t\t\tlet patch = await OP.db.update($root.id,upd)\n\t\t\tif patch\n\t\t\t\tOP.$patch(patch)\n\n\t\t\tif $root isa OPPov\n\t\t\t\tnull\n\t\t\treturn patch\n\n\t\tif $web$\n\t\t\tlet res = await OP.server.commit(self)\n\t\t\tOP.$patch(res) if res\n\t\t\treturn res\n\n\t\telse\n\t\t\tsuper\n\nglobal class OPADD < OPSET\n\tget $value\n\t\t{$add: String(value)}\n\nglobal class OPINCR < OPSET\n\tget $value\n\t\t{$incr: (value or 1)}\n\nglobal class OPCRE < OPSET\n\tget $value\n\t\t{$add: String(value)}\n\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
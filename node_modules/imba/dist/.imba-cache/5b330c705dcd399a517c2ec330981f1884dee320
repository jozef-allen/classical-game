{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};\nconst $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__');\nvar $1 = Symbol();\n\n/*body*/\nimport {OPRefField} from './ref';\n\n// @template [Type=any]\n// @template [LinkName=string]\nexport class OPLinkField extends OPRefField {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $2;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\t($2 = $$.pgtype) !== undefined && (this.pgtype = $2);\n\t\t($2 = $$.enum) !== undefined && (this.enum = $2);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $3;\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tthis.pgtype = ($$ && ($3 = $$.pgtype) !== undefined) ? ($3) : 'text';\n\t\tthis.enum = ($$ && ($3 = $$.enum) !== undefined) ? ($3) : false;\n\t\t\n\t}\n\t\n\t\n\t// serialize only oid for type\n\t\n\t\n\tget valuetype(){\n\t\t\n\t\treturn this.type;\n\t}\n\t\n\tget complexΦ(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tserialize(value,target){\n\t\t\n\t\t// FIXME what if this reference is a numeric id?\n\t\t// drop this\n\t\t// SERIALIZER.#register(value) if value and SERIALIZER\n\t\treturn value ? String(this.enum ? value.oid : value.id) : undefined;\n\t}\n\t\n\t$wake(target,val){\n\t\t\n\t\tif (val) {\n\t\t\t\n\t\t\t// $altered( $deserialize(val,target), null, target )\n\t\t\treturn this.$altered(this.$get(target),null,target);\n\t\t};\n\t}\n\t\n\t/**\n\t@returns { InstanceType<Type> }\n\t*/\n\t$get(target){\n\t\t\n\t\treturn target.$rich[this.name] ||= this.$deserialize(this.$getΞplain(target),target);\n\t}\n\t\n\t$set(value,target){\n\t\t\n\t\t// why is this completely different than @ref.$set? Doesnt make sense\n\t\tthis.$load(value,target);\n\t\treturn target.$changed(this.name,value,this);\n\t}\n\t\n\t$altered(value,prev,target){\n\t\t\n\t\tlet link = this.args[1];\n\t\tif (prev) { target.removeΞlink(prev[link],link) };\n\t\tif (value) { target.addΞlink(value[link],link,value) };\n\t\t\n\t\tif (this.$granted) {\n\t\t\t\n\t\t\t\n\t\t\t// should we store it on the target or in this model?\n\t\t\t// In this model it is already implicitly stored - could make sense to check live\n\t\t\t// unless we are really interested in being able to fetch the connection.\n\t\t\t// Need to decide on the structure for registering this\n\t\t\t// Should likely be a separate object representing the roles-combo between an item and user\n\t\t\t// it could be stored in both places if we wanted to.\n\t\t\t// Feels pretty natural to make this part of the pov, no? But povs are meant to be for users only\n\t\t\t\n\t\t\tif (value) {\n\t\t\t\t\n\t\t\t\ttarget.$pov(value).$promote(this.$granted,this);\n\t\t\t\t// value.sys.pov(value)\n\t\t\t\t// for this POC - expeting a single role to be set\n\t\t\t\t// FIXME this only works for very simple test - we have to essentially do reference counting here\n\t\t\t\t// let map = value.$roles ||= {}\n\t\t\t\t// (map[$granted] ||= new Set).add(target)\n\t\t\t\t// map[target]\n\t\t\t};\n\t\t\ttrue;\n\t\t};\n\t\treturn;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'OPLinkField');inheritClass$__(this);}\n}; globalThis.OPLinkField = OPLinkField;\n\nclass ΩOPObject {\n\t\n\t// @template [T=any]\n\t// @template [LinkName=any]\n\t/**\n\t@param {T} type\n\t@param {LinkName} name\n\t@returns { LinkField<T,LinkName> }\n\t*/\n\tαlink(type,name){\n\t\t\n\t\treturn new OPLinkField(type,name);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPObject');}\n};\nextend$__(OPObject.prototype,ΩOPObject.prototype);\n;\n","dependencies":[],"map":{"version":3,"file":"link.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/fields/link.imba"],"sourcesContent":["import {OPRefField} from './ref'\n\n# @template [Type=any]\n# @template [LinkName=string]\nexport global class OPLinkField < OPRefField\n\tpgtype = 'text'\n\n\t# serialize only oid for type\n\tenum = no\n\n\tget valuetype\n\t\ttype\n\n\tget complex?\n\t\tyes\n\n\tdef serialize value, target\n\t\t# FIXME what if this reference is a numeric id?\n\t\t# drop this\n\t\t# SERIALIZER.#register(value) if value and SERIALIZER\n\t\tvalue ? String(self.enum ? value.oid : value.id) : undefined\n\n\tdef $wake target, val\n\t\tif val\n\t\t\t# $altered( $deserialize(val,target), null, target )\n\t\t\t$altered( $get(target), null, target )\n\n\tdef $get\\InstanceType<Type> target\n\t\ttarget.$rich[name] ||= $deserialize($get-plain(target),target)\n\n\tdef $set value, target\n\t\t# why is this completely different than @ref.$set? Doesnt make sense\n\t\t$load(value,target)\n\t\ttarget.$changed(name,value,self)\n\n\tdef $altered value, prev, target\n\t\tlet link = args[1]\n\t\ttarget.remove-link(prev[link],link) if prev\n\t\ttarget.add-link(value[link],link,value) if value\n\n\t\tif $granted\n\n\t\t\t# should we store it on the target or in this model?\n\t\t\t# In this model it is already implicitly stored - could make sense to check live\n\t\t\t# unless we are really interested in being able to fetch the connection.\n\t\t\t# Need to decide on the structure for registering this\n\t\t\t# Should likely be a separate object representing the roles-combo between an item and user\n\t\t\t# it could be stored in both places if we wanted to.\n\t\t\t# Feels pretty natural to make this part of the pov, no? But povs are meant to be for users only\n\n\t\t\tif value\n\t\t\t\ttarget.$pov(value).$promote($granted,self)\n\t\t\t\t# value.sys.pov(value)\n\t\t\t\t# for this POC - expeting a single role to be set\n\t\t\t\t# FIXME this only works for very simple test - we have to essentially do reference counting here\n\t\t\t\t# let map = value.$roles ||= {}\n\t\t\t\t# (map[$granted] ||= new Set).add(target)\n\t\t\t\t# map[target]\n\t\t\tyes\n\t\treturn\n\nextend class OPObject\n\t# @template [T=any]\n\t# @template [LinkName=any]\n\tdef @link\\LinkField<T,LinkName> type\\T,name\\LinkName\n\t\tnew OPLinkField(type,name)"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,MAAM,EAAE,UAAU,OAAO,OAAO;;;;AAIhC,MAAM,CAAQ,KAAK,CAAC,WAAW,SAAG,UAAU,EAAA;qCAJ5C;;;WAKC,MAAM,CAAA,wBAAN,MAAM;WAGN,IAAI,CAAA,wBAAJ,IAAI;;EARL;cAAA;;;EAAA;kDAAA;;;OAKC,MAAM,mBAAN,MAAM,CAAA,qBAAA,IAAG,MAAM;OAGf,IAAI,mBAAJ,IAAI,CAAA,qBAAA,IAAG,KAAE;;EARV;;;;;;CAUC,GAAG,CAAC,SAAS,EAAA;;EACZ,OAAA,KAAA,IAAI;EAAA;;CAEL,GAAG,CAAC,QAAQ,EAAA;;EACX,OAAA,IAAG;EAAA;;CAEA,SAAS,CAAC,KAAK,CAAE,MAAM,CAAA;;;;;SAI1B,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE,CAAC,GAAG,SAAS;EAAA;;CAEzD,KAAK,CAAC,MAAM,CAAE,GAAG,CAAA;;EACpB,EAAE,EAAC,GAAG,EAAA;;;UAEL,KAAA,QAAQ,CAAE,KAAA,IAAI,CAAC,MAAM,CAAC,CAAE,IAAI,CAAE,MAAM,CAAE;GAAA;EAAA;;;YAE/B,kBAAkB;;CAAvB,IAAI,CAAoB,MAAM,CAAA;;SACjC,MAAM,CAAC,KAAK,CAAA,KAAC,IAAI,CAAC,KAAK,KAAA,YAAY,CAAC,KAAA,UAAU,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC;EAAA;;CAE3D,IAAI,CAAC,KAAK,CAAE,MAAM,CAAA;;;EAErB,KAAA,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC;EACnB,OAAA,MAAM,CAAC,QAAQ,CAAC,KAAA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;EAAA;;CAE7B,QAAQ,CAAC,KAAK,CAAE,IAAI,CAAE,MAAM,CAAA;;MAC3B,IAAI,GAAG,KAAA,IAAI,CAAC,CAAC,CAAC;EACkB,EAAE,EAAC,IAAI,EAA3C,EAAA,MAAM,CAAC,WAAW,CAAC,IAAI,CAAA,IAAK,CAAC,CAAC,IAAI,CAAC,EAAA;EACK,EAAE,EAAC,KAAK,EAAhD,EAAA,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAA,IAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,EAAA;;EAEvC,EAAE,EAAC,KAAA,QAAQ,EAAA;;;;;;;;;;;GAUV,EAAE,EAAC,KAAK,EAAA;;IACP,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,KAAA,QAAQ,CAAC,IAAI,CAAC;;;;;;;IAM7B;GACd,IAAG;GAAA;EACJ,MAAM;EAAA;;;AAAA,cAvDY,WAAW,GAAX,WAAW;;AAyDxB,KAAK,CAAC,SAAQ,EAAA;;;;;SAGiB,CAAC;SAAM,QAAQ;YAA1C,qBAAqB;;CAA3B,KAAK,CAAuB,IAAI,CAAG,IAAI,CAAS;;EACnD,OAAA,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC;EAAA;;;AAAA;UAJf,QAAQ;AAIO;AAAA;"}},"css":{"code":""},"warnings":[],"errors":[]}
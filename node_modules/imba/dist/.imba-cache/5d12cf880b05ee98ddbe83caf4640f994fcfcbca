{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};\nconst $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $__listeners__$ = Symbol.for('#__listeners__');\n\n/*body*/\nconst dashRegex = /-./g;\n\nexport const __served__ = new Set;\n\nexport class LazyProxy {\n\t\n\tstatic for(getter){\n\t\t\n\t\treturn new Proxy({},new this(getter));\n\t}\n\t\n\tconstructor(getter){\n\t\t\n\t\tthis.getter = getter;\n\t}\n\t\n\tget target(){\n\t\t\n\t\treturn this.getter();\n\t}\n\t\n\tget(_,key){\n\t\t\n\t\treturn this.target[key];\n\t}\n\t\n\tset(_,key,value){\n\t\t\n\t\tthis.target[key] = value;\n\t\treturn true;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'LazyProxy');}\n};\n\nexport function proxy(getter,placeholder = {}){\n\t\n\treturn new Proxy(placeholder,new LazyProxy(getter));\n};\n\nexport function parseTime(value){\n\t\n\tlet typ = typeof value;\n\tif (typ == 'number') {\n\t\t\n\t\treturn value;\n\t};\n\t\n\tif (typ == 'string') {\n\t\t\n\t\tif ((/^\\d+fps$/).test(value)) {\n\t\t\t\n\t\t\treturn 1000 / parseFloat(value);\n\t\t} else if ((/^([-+]?[\\d\\.]+)s$/).test(value)) {\n\t\t\t\n\t\t\treturn parseFloat(value) * 1000;\n\t\t} else if ((/^([-+]?[\\d\\.]+)ms$/).test(value)) {\n\t\t\t\n\t\t\treturn parseFloat(value);\n\t\t};\n\t};\n\t// throw or return NaN?\n\treturn null;\n};\n\nexport function toCamelCase(str){\n\t\n\tif (str.indexOf('-') >= 0) {\n\t\t\n\t\treturn str.replace(dashRegex,function(_0) { return _0.charAt(1).toUpperCase(); });\n\t} else {\n\t\t\n\t\treturn str;\n\t};\n};\n\nexport function getDeepPropertyDescriptor(item,key,stop){\n\t\n\t\n\tif (!(item)) {\n\t\t\n\t\treturn undefined;\n\t};\n\t\n\tlet desc = Object.getOwnPropertyDescriptor(item,key);\n\t\n\tif (desc || item == stop) {\n\t\t\n\t\treturn desc || undefined;\n\t};\n\t\n\treturn getDeepPropertyDescriptor(Reflect.getPrototypeOf(item),key,stop);\n};\n\n// Basic events - move to separate file?\nconst emit__ = function(event,args,node) {\n\t\n\tlet prev;\n\tlet cb;\n\tlet ret;\n\t\n\twhile ((prev = node) && (node = node.next)){\n\t\t\n\t\tif (cb = node.listener) {\n\t\t\t\n\t\t\tif (node.path && cb[node.path]) {\n\t\t\t\t\n\t\t\t\tret = args ? cb[node.path].apply(cb,args) : cb[node.path]();\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// check if it is a method?\n\t\t\t\tret = args ? cb.apply(node,args) : cb.call(node);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (node.times && --node.times <= 0) {\n\t\t\t\n\t\t\tprev.next = node.next;\n\t\t\tnode.listener = null;\n\t\t};\n\t};\n\treturn;\n};\n\n// method for registering a listener on object\nexport function listen(obj,event,listener,path){\n\t\n\tlet cbs;\n\tlet list;\n\tlet tail;\n\tcbs = obj[$__listeners__$] ||= {};\n\tlist = cbs[event] ||= {};\n\ttail = list.tail || (list.tail = (list.next = {}));\n\ttail.listener = listener;\n\ttail.path = path;\n\tlist.tail = tail.next = {};\n\treturn tail;\n};\n\n// register a listener once\nexport function once(obj,event,listener){\n\t\n\tlet tail = listen(obj,event,listener);\n\ttail.times = 1;\n\treturn tail;\n};\n\n// remove a listener\nexport function unlisten(obj,event,cb,meth){\n\t\n\tif (!(cb)) { return };\n\tlet node;\n\tlet prev;\n\tlet meta = obj[$__listeners__$];\n\tif (!(meta)) { return };\n\t\n\tif (node = meta[event]) {\n\t\t\n\t\twhile ((prev = node) && (node = node.next)){\n\t\t\t\n\t\t\tif (node == cb || node.listener == cb) {\n\t\t\t\t\n\t\t\t\tprev.next = node.next;\n\t\t\t\t// check for correct path as well?\n\t\t\t\tnode.listener = null;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t};\n\t};\n\treturn;\n};\n\n// emit event\nexport function emit(obj,event,params){\n\tlet cb;\n\t\n\tif (cb = obj[$__listeners__$]) {\n\t\t\n\t\tif (cb[event]) { emit__(event,params,cb[event]) };\n\t\tif (cb.all) { emit__(event,[event,params],cb.all) };\n\t};\n\treturn;\n};\n\nexport class Emitter {\n\t\n\temit(name,...params){\n\t\treturn emit(this,name,params);\n\t}\n\ton(name,...params){\n\t\treturn listen(this,name,...params);\n\t}\n\tonce(name,...params){\n\t\treturn once(this,name,...params);\n\t}\n\tun(name,...params){\n\t\treturn unlisten(this,name,...params);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Emitter');}\n};\n\nexport function defineConfig(config){\n\t\n\treturn config;\n};\n","dependencies":[],"map":{"version":3,"file":"utils.js","sourceRoot":"","sources":["/Users/sindre/repos/imba/packages/imba/src/imba/utils.imba"],"sourcesContent":["const dashRegex = /-./g\n\nexport const __served__ = new Set\n\nexport class LazyProxy\n\tstatic def for getter\n\t\tnew Proxy({}, new self(getter))\n\n\tdef constructor getter\n\t\tgetter = getter\n\n\tget target\n\t\tgetter!\n\n\tdef get _, key\n\t\ttarget[key]\n\n\tdef set _, key, value\n\t\ttarget[key] = value\n\t\treturn true\n\nexport def proxy getter, placeholder = {}\n\tnew Proxy(placeholder, new LazyProxy(getter))\n\nexport def parseTime value\n\tlet typ = typeof value\n\tif typ == 'number'\n\t\treturn value\n\n\tif typ == 'string'\n\t\tif (/^\\d+fps$/).test(value)\n\t\t\treturn 1000 / parseFloat(value)\n\t\telif (/^([-+]?[\\d\\.]+)s$/).test(value)\n\t\t\treturn parseFloat(value) * 1000\n\t\telif (/^([-+]?[\\d\\.]+)ms$/).test(value)\n\t\t\treturn parseFloat(value)\n\t# throw or return NaN?\n\treturn null\n\nexport def toCamelCase str\n\tif str.indexOf('-') >= 0\n\t\tstr.replace(dashRegex) do $1.charAt(1).toUpperCase!\n\telse\n\t\tstr\n\nexport def getDeepPropertyDescriptor item, key, stop\n\n\tif !item\n\t\treturn undefined\n\n\tlet desc = Object.getOwnPropertyDescriptor(item,key)\n\n\tif desc or item == stop\n\t\treturn desc or undefined\n\n\tgetDeepPropertyDescriptor(Reflect.getPrototypeOf(item),key,stop)\n\n# Basic events - move to separate file?\nconst emit__ = do(event, args, node)\n\tlet prev\n\tlet cb\n\tlet ret\n\n\twhile (prev = node) and (node = node.next)\n\t\tif cb = node.listener\n\t\t\tif node.path and cb[node.path]\n\t\t\t\tret = args ? cb[node.path].apply(cb,args) : cb[node.path]()\n\t\t\telse\n\t\t\t\t# check if it is a method?\n\t\t\t\tret = args ? cb.apply(node, args) : cb.call(node)\n\n\t\tif node.times && --node.times <= 0\n\t\t\tprev.next = node.next\n\t\t\tnode.listener = null\n\treturn\n\n# method for registering a listener on object\nexport def listen obj, event, listener, path\n\tlet cbs\n\tlet list\n\tlet tail\n\tcbs = obj.#__listeners__ ||= {}\n\tlist = cbs[event] ||= {}\n\ttail = list.tail || (list.tail = (list.next = {}))\n\ttail.listener = listener\n\ttail.path = path\n\tlist.tail = tail.next = {}\n\treturn tail\n\n# register a listener once\nexport def once obj, event, listener\n\tlet tail = listen(obj,event,listener)\n\ttail.times = 1\n\treturn tail\n\n# remove a listener\nexport def unlisten obj, event, cb, meth\n\treturn unless cb\n\tlet node\n\tlet prev\n\tlet meta = obj.#__listeners__\n\treturn unless meta\n\n\tif node = meta[event]\n\t\twhile (prev = node) and (node = node.next)\n\t\t\tif node == cb || node.listener == cb\n\t\t\t\tprev.next = node.next\n\t\t\t\t# check for correct path as well?\n\t\t\t\tnode.listener = null\n\t\t\t\tbreak\n\treturn\n\n# emit event\nexport def emit obj, event, params\n\tif let cb = obj.#__listeners__\n\t\temit__(event,params,cb[event]) if cb[event]\n\t\temit__(event,[event,params],cb.all) if cb.all\n\treturn\n\nexport class Emitter\n\tdef emit name, ...params do emit(self,name,params)\n\tdef on name, ...params do listen(self,name,...params)\n\tdef once name, ...params do once(self,name,...params)\n\tdef un name, ...params do unlisten(self,name,...params)\n\nexport def defineConfig config\n\tconfig\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
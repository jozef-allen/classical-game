{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};\n\n/*body*/\nconst SPLITTERS = '%^&*@#';\nconst PARTCACHE = {};\nimport * as mp from '../msgpack';\n\nexport class OPKey {\n\t\n\t\n\tstatic encode(...parts){\n\t\t\n\t\treturn parts.map(function(_0) { return String(_0).replace(/\\_/g,'__'); }).join('_');\n\t}\n\t\n\tstatic unnest(key,depth = 1,transformer = null){\n\t\tvar self = this;\n\t\t\n\t\tlet chr = SPLITTERS[depth];\n\t\t\n\t\tif (key.indexOf(SPLITTERS[depth + 1]) == -1) {\n\t\t\t\n\t\t\tkey = key.replaceAll(chr,'_');\n\t\t\t// p \"no more unnesting needed\",key\n\t\t};\n\t\t\n\t\tlet idx = key.indexOf(chr);\n\t\t\n\t\tif (idx == -1) {\n\t\t\t\n\t\t\t// now return the transformer?\n\t\t\treturn transformer ? transformer(key) : key;\n\t\t};\n\t\t\n\t\treturn key.split(chr).map(function(_0) { return self.unnest(_0,depth + 1,transformer); });\n\t}\n\t\n\tstatic split(key,transformer,shallow = true){\n\t\t\n\t\t// let depth = '%^&*@#'\n\t\tlet max = 0;\n\t\tlet replaced = key.replace(/_+/g,function(m) {\n\t\t\t\n\t\t\tlet l = m.length;\n\t\t\tif (max < l) { max = l };\n\t\t\treturn SPLITTERS[m.length];\n\t\t});\n\t\t\n\t\tlet out = this.unnest(replaced,1,transformer);\n\t\tif (max == 1 && shallow) {\n\t\t\t\n\t\t\treturn key;\n\t\t};\n\t\treturn out;\n\t}\n\t\n\tstatic parse(key,transformer){\n\t\t\n\t\tlet res = this.split(key,transformer,false);\n\t\tif (typeof res == 'string') {\n\t\t\t\n\t\t\treturn res.split('_');\n\t\t};\n\t\treturn res;\n\t}\n\t\n\tstatic decode(key,typemap = {},transformer){\n\t\t\n\t\tif (!(key)) { return };\n\t\t\n\t\tlet out = {\n\t\t\tid: null,\n\t\t\ttype: null,// typemap[parts[2]] or parts[2] # ? parts[1].slice(0,-1) : parts[1]\n\t\t\tmask: null,// parts[3] or 0\n\t\t\toid: null,// parts[4]\n\t\t\tpath: null\n\t\t};\n\t\t\n\t\tlet subidx = key.indexOf('.');\n\t\t\n\t\tif (subidx >= 0) {\n\t\t\t\n\t\t\tlet path = key.split('.');\n\t\t\tout.path = path.slice(1);\n\t\t\tkey = path[0];\n\t\t};\n\t\t\n\t\tlet parts = key.match(/^(([A-Za-z]+)(\\d|(?=_)))([^_]+)?/);\n\t\tout.id = key;\n\t\t\n\t\tif (!(parts)) {\n\t\t\t\n\t\t\treturn null;\n\t\t};\n\t\t\n\t\tout.type = typemap[parts[2]] || parts[2];\n\t\tlet m = out.mask = parts[3] || 0;\n\t\tout.oid = parts[4];\n\t\t\n\t\tif (m == '2') {\n\t\t\t\n\t\t\tout.payload = mp.parse(parts[4],58);\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t// enum\n\t\tif (m == '9') {\n\t\t\t\n\t\t\tout.oid = key.slice(parts[2].length + 1);\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t// doesnt make sense to have that be the id?\n\t\tlet parsed = out.params = this.parse(key,transformer);\n\t\t\n\t\t// let out = {\n\t\t// \tid: parsed\n\t\t// \ttype: typemap[parts[2]] or parts[2] # ? parts[1].slice(0,-1) : parts[1]\n\t\t// \tmask: parts[3] or 0\n\t\t// \toid: parts[4]\n\t\t// }\n\t\t\n\t\tif (parsed.length > 1) {\n\t\t\t\n\t\t\tlet f = out.type?.key;\n\t\t\tif (f) {\n\t\t\t\t\n\t\t\t\tlet props = out.data = {id: key};\n\t\t\t\tlet slots = f.slots;\n\t\t\t\t// let names = f.params\n\t\t\t\tfor (let i = 0, $1 = iter$__(slots), $2 = $1.length; i < $2; i++) {\n\t\t\t\t\tlet slot = $1[i];\n\t\t\t\t\tlet v = parsed[i + 1];\n\t\t\t\t\tif (slot instanceof OPField) { v = slot.$sanitize(v) };\n\t\t\t\t\tprops[slot] = v;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tout.composite = parsed.slice(1).map(function(k) {\n\t\t\t\t\n\t\t\t\tlet pre = k.split(/[\\d_]/)[0];\n\t\t\t\treturn typemap[pre] || pre;\n\t\t\t});\n\t\t};\n\t\t\n\t\treturn out;\n\t}\n\t\n\tstatic embed(key,name){\n\t\t\n\t\tlet idx = key.indexOf('_');\n\t\treturn (idx > 0) ? ((\"\" + key.slice(0,idx) + `.` + name + key.slice(idx))) : ((key + '.' + name));\n\t}\n\t\n\tstatic embedded(key){\n\t\t\n\t\tlet spl = key.indexOf('_');\n\t\tlet idx = key.indexOf('.');\n\t\tif (idx == -1 || (spl > 0 && idx > spl)) { return false };\n\t\tlet name = key.slice(idx + 1,(spl > 0) ? spl : key.length);\n\t\treturn name;\n\t}\n\t\n\tstatic random(len = 8){\n\t\t\n\t\t// TODO make cryptographically secure random ids using crypto.getRandomValues\n\t\tlet str = \"\";\n\t\twhile (len -- > 0){\n\t\t\t\n\t\t\tstr += Math.floor(Math.random() * 32).toString(32);\n\t\t};\n\t\treturn str;\n\t}\n\t\n\tstatic enc58(bin){\n\t\t\n\t\treturn this.nums.map(function(_0) { return _0.toString(32); }).join('w');\n\t}\n\t\n\tstatic decodenums(str){\n\t\t\n\t\treturn str.split('w').map(function(_0) { return parseInt(_0,32); });\n\t}\n\t\n\tstatic enctype(num){\n\t\t\n\t\treturn num.toString(32).padStart(2,'0');\n\t}\n\t\n\tstatic dectype(str){\n\t\t\n\t\treturn parseInt(str.slice(0,2),32);\n\t}\n\t\n\tstatic serialize(data){\n\t\t\n\t\treturn mp.stringify(data);\n\t}\n\t\n\tstatic deserialize(data){\n\t\t\n\t\treturn mp.parse(data);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPKey');}\n}; globalThis.OPKey = OPKey;\n","dependencies":[],"map":{"version":3,"file":"key.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/core/key.imba"],"sourcesContent":["const SPLITTERS = '%^&*@#'\nconst PARTCACHE = {}\nimport * as mp from '../msgpack'\n\nexport global class OPKey\n\n\tstatic def encode ...parts\n\t\tparts.map(do String($1).replace(/\\_/g,'__')).join('_')\n\n\tstatic def unnest key, depth = 1,transformer = null\n\t\tlet chr = SPLITTERS[depth]\n\n\t\tif key.indexOf(SPLITTERS[depth + 1]) == -1\n\t\t\tkey = key.replaceAll(chr,'_')\n\t\t\t# p \"no more unnesting needed\",key\n\n\t\tlet idx = key.indexOf(chr)\n\n\t\tif idx == -1\n\t\t\t# now return the transformer?\n\t\t\treturn transformer ? transformer(key) : key\n\n\t\tkey.split(chr).map do unnest($1,depth + 1,transformer)\n\n\tstatic def split key, transformer,shallow = yes\n\t\t# let depth = '%^&*@#'\n\t\tlet max = 0\n\t\tlet replaced = key.replace(/_+/g) do(m)\n\t\t\tlet l = m.length\n\t\t\tmax = l if max < l\n\t\t\tSPLITTERS[m.length]\n\n\t\tlet out = unnest(replaced,1,transformer)\n\t\tif max == 1 and shallow\n\t\t\treturn key\n\t\treturn out\n\n\tstatic def parse key, transformer\n\t\tlet res = split(key,transformer,no)\n\t\tif typeof res == 'string'\n\t\t\treturn res.split('_')\n\t\treturn res\n\n\tstatic def decode key,typemap = {},transformer\n\t\treturn unless key\n\n\t\tlet out = {\n\t\t\tid: null\n\t\t\ttype: null # typemap[parts[2]] or parts[2] # ? parts[1].slice(0,-1) : parts[1]\n\t\t\tmask: null # parts[3] or 0\n\t\t\toid: null # parts[4]\n\t\t\tpath: null\n\t\t}\n\n\t\tlet subidx = key.indexOf('.')\n\n\t\tif subidx >= 0\n\t\t\tlet path = key.split('.')\n\t\t\tout.path = path.slice(1)\n\t\t\tkey = path[0]\n\n\t\tlet parts = key.match(/^(([A-Za-z]+)(\\d|(?=_)))([^_]+)?/)\n\t\tout.id = key\n\n\t\tunless parts\n\t\t\treturn null\n\n\t\tout.type = typemap[parts[2]] or parts[2]\n\t\tlet m = out.mask = parts[3] or 0\n\t\tout.oid = parts[4]\n\n\t\tif m == '2'\n\t\t\tout.payload = mp.parse(parts[4],58)\n\t\t\treturn out\n\n\t\t# enum\n\t\tif m == '9'\n\t\t\tout.oid = key.slice(parts[2].length + 1)\n\t\t\treturn out\n\n\t\t# doesnt make sense to have that be the id?\n\t\tlet parsed = out.params = parse(key,transformer)\n\n\t\t# let out = {\n\t\t# \tid: parsed\n\t\t# \ttype: typemap[parts[2]] or parts[2] # ? parts[1].slice(0,-1) : parts[1]\n\t\t# \tmask: parts[3] or 0\n\t\t# \toid: parts[4]\n\t\t# }\n\n\t\tif parsed.length > 1\n\t\t\tlet f = out.type..key\n\t\t\tif f\n\t\t\t\tlet props = out.data = {id: key}\n\t\t\t\tlet slots = f.slots\n\t\t\t\t# let names = f.params\n\t\t\t\tfor slot,i in slots\n\t\t\t\t\tlet v = parsed[i + 1]\n\t\t\t\t\tv = slot.$sanitize(v) if slot isa OPField\n\t\t\t\t\tprops[slot] = v\n\n\t\t\tout.composite = parsed.slice(1).map do(k)\n\t\t\t\tlet pre = k.split(/[\\d_]/)[0]\n\t\t\t\ttypemap[pre] or pre\n\n\t\treturn out\n\n\tstatic def embed key, name\n\t\tlet idx = key.indexOf('_')\n\t\tidx > 0 ? `{key.slice(0,idx)}.{name}{key.slice(idx)}` : (key + '.' + name)\n\n\tstatic def embedded key\n\t\tlet spl = key.indexOf('_')\n\t\tlet idx = key.indexOf('.')\n\t\treturn no if idx == -1 or (spl > 0 and idx > spl)\n\t\tlet name = key.slice(idx + 1,spl > 0 ? spl : key.length)\n\t\treturn name\n\n\tstatic def random len = 8\n\t\t# TODO make cryptographically secure random ids using crypto.getRandomValues\n\t\tlet str = \"\"\n\t\twhile len-- > 0\n\t\t\tstr += Math.floor(Math.random() * 32).toString(32)\n\t\treturn str\n\n\tstatic def enc58 bin\n\t\tnums.map(do  $1.toString(32)).join('w')\n\n\tstatic def decodenums str\n\t\tstr.split('w').map do parseInt($1,32)\n\n\tstatic def enctype num\n\t\tnum.toString(32).padStart(2,'0')\n\n\tstatic def dectype str\n\t\tparseInt(str.slice(0,2),32)\n\n\tstatic def serialize data\n\t\tmp.stringify(data)\n\n\tstatic def deserialize data\n\t\tmp.parse(data)\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
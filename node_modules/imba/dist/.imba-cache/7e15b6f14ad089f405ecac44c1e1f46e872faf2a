{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction decorate$__(decorators,target,key,desc){\n\tvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\tif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\telse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\treturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};\nimport {αlazy as imba_αlazy, use_hooks as imba_use_hooks, hooks as imba_hooks} from 'imba';\n(imba_use_hooks());\nconst $__hooks__$ = Symbol.for('#__hooks__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $id$ = Symbol.for('#id'), $up$ = Symbol.for('#up'), $key$ = Symbol.for('#key');\nvar $1 = Symbol();\n\n/*body*/\nimport {Iterable,Index} from './iterable';\nimport {throttled,promising} from '../utils';\nimport './object';\n\n/*\nObject keeping track of user-specific properties for a model.\n\nThis and OPModel should rather both inherit from OPObject, and share\n$save,$update etc?\n\n*/\n\nexport class OPPov extends OPObject {\n\t\n\tstatic get columns(){\n\t\t\n\t\treturn this.$for.deepShape.$pov;\n\t}\n\t\n\tstatic get $shape(){\n\t\t\n\t\treturn this.$for.$shape.$pov;\n\t}\n\t\n\tstatic get $fields(){\n\t\t\n\t\treturn this.$for.$shape.$pov;\n\t}\n\t\n\tstatic get povΦ(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tstatic setup(parent){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tget $fields(){\n\t\t\n\t\t// and id etc?\n\t\treturn this.$type.$shape.$pov;\n\t}\n\t\n\tget $root(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tget $path(){\n\t\t\n\t\treturn null;\n\t}\n\t\n\t$sync(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tgenerateId(){\n\t\t\n\t\treturn super.generateId(...arguments);\n\t}\n\t\n\tget id(){\n\t\t\n\t\treturn this[$id$] ||= (\"\" + this.$up + `.` + this.$key);\n\t}\n\t\n\tset id(val){\n\t\t\n\t\tthis[$id$];\n\t}\n\t\n\tget existsΦ(){\n\t\t\n\t\treturn this.rev > 0;\n\t}\n\t\n\tget embedΦ(){\n\t\t\n\t\treturn false;\n\t}\n\t\n\t$willΞset(path,value){\n\t\t\n\t\tsuper.$willΞset(...arguments);\n\t\t// $up.$plain[\"~{$key}\"] ||= $plain\n\t\treturn true;\n\t}\n\t\n\tconstructor(up,pov){\n\t\t\n\t\tif (!((pov instanceof OPObject))) { pov = OP.get(pov) };\n\t\tlet id = (\"\" + (up.id) + `.` + pov);\n\t\tlet cloud = OP.$cloud[id];\n\t\tlet params = cloud || {id: id};\n\t\tif (up.localΦ) { params._rev = 0 };\n\t\tparams[$up$] = up;\n\t\tparams[$key$] = pov;\n\t\tsuper(params);\n\t\tthis[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\t__init__(params){\n\t\t\n\t\tlet id = (\"\" + (params[$up$]) + `.` + (params[$key$]));\n\t\tObject.defineProperties(this,{\n\t\t\t$up: {enumerable: false,value: params[$up$]},\n\t\t\t$key: {enumerable: false,value: params[$key$]},\n\t\t\tid: {enumerable: false,value: id},\n\t\t\t$memo: {enumerable: false,writable: true,value: {}}\n\t\t});\n\t\tOP.$rich[id] = this;\n\t\tthis.$plain = params;\n\t\treturn this;\n\t}\n\t\n\tget pov(){\n\t\t\n\t\treturn this.$key;\n\t}\n\t\n\trolesΞfor(agent){\n\t\t\n\t\treturn (agent == this.pov) ? OP.OWNER : 0;\n\t}\n\t\n\tget $refs(){\n\t\t\n\t\treturn new Index;\n\t}\n\t\n\tasync save(o = {}){\n\t\t\n\t\treturn await this.$save(o);\n\t\t// return self\n\t}\n\t\n\tget resolvedΦ(){\n\t\t\n\t\t// expect this to always be resolved?\n\t\treturn true;\n\t}\n\t\n\tget persistedΦ(){\n\t\t\n\t\treturn this.$up.persistedΦ;\n\t\t// Povs should always act as if they exist as long as their parent exists\n\t}\n\t\n\t$save(o = {}){\n\t\t\n\t\tif (!(this.$up.savedΦ)) {\n\t\t\t\n\t\t\t// eplicitly ask to be saved later?\n\t\t\tthrow `cannot save pov without first saving parent`;\n\t\t};\n\t\t\n\t\tthis.$cloud ||= {id: this.id};\n\t\t// TODO We should never try to 'cre' a pov? It should always act as if it was always there, no?\n\t\treturn super.$save(...arguments);\n\t}\n\t\n\t// Pov mutations should immediately save unless item is local?\n\t$mutated(mut){\n\t\t\n\t\tthis.$mutations.push(mut);\n\t\tif (false) {};\n\t\t// should we push the mutations to the parent so that they are included after save?\n\t\t// unless $up.saved?\n\t\t// imba.once($up,'save') do yes\n\t\treturn this;\n\t}\n\t\n\t// FIXME does not do reference counting at all now\n\t$promote(bits){\n\t\t\n\t\tlet pre = this.$roles;\n\t\tthis.$roles |= bits;\n\t\tlet diff = pre ^ bits;\n\t\tlet bit = 0;\n\t\tlet num;\n\t\tlet refs;\n\t\t\n\t\twhile ((num = 2 ** bit) <= bits){\n\t\t\t\n\t\t\tif (bits & num) {\n\t\t\t\t\n\t\t\t\tif (!((pre & num))) {\n\t\t\t\t\t\n\t\t\t\t\tlet k = bits & num;\n\t\t\t\t\tif (false) {};\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// increment reference count for this\n\t\t\t\t\trefs = this.$rolerefs ||= {};\n\t\t\t\t\trefs[bit] = (refs[bit] || 0) + 1;\n\t\t\t\t\ttrue;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tbit++;\n\t\t};\n\t\t\n\t\t// possibly add object to affiliations\n\t\tif (bits && !(pre)) {\n\t\t\t\n\t\t\tthis.pov.$affiliations.incr(this.$up,this);\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t// FIXME does not support reference counting at all now\n\t$demote(bits){\n\t\t\n\t\tlet pre = this.$roles;\n\t\tlet diff = pre ^ bits;\n\t\tlet refs = this.$rolerefs;\n\t\t// $roles ~= bits\n\t\t\n\t\tlet bit = 0;\n\t\tlet num;\n\t\t\n\t\twhile ((num = 2 ** bit) <= bits){\n\t\t\t\n\t\t\tif (bits & num) {\n\t\t\t\t\n\t\t\t\tif (refs && refs[bit]) {\n\t\t\t\t\t\n\t\t\t\t\trefs[bit] -= 1;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tthis.$up.removeΞlink(OP.role(bit).$pov(this.$key));\n\t\t\t\t\tthis.$roles &= ~num;\n\t\t\t\t};\n\t\t\t};\n\t\t\tbit++;\n\t\t};\n\t\t\n\t\t// Remove affiliation\n\t\tif (diff && !(this.$roles)) {\n\t\t\t\n\t\t\tthis.pov.$affiliations.decr(this.$up,this);\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t// def $resolve force=no\n\t\n\t$serialize(o = {}){\n\t\t\n\t\tlet obj = this.$fields.$serialize(this,o);\n\t\tobj.id = this.id;\n\t\tobj._pov = String(this.$key);\n\t\t// obj._exp = OP.now\n\t\treturn obj;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;this.prototype[$__hooks__$] = imba_hooks;\n\t\tdefineName$__(this,'OPPov');decorate$__([imba_αlazy.bind([])],this.prototype,'$refs',null);\n\t\tinheritClass$__(this);}\n}; globalThis.OPPov = OPPov;\n","dependencies":[],"map":{"version":3,"file":"pov.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/core/pov.imba"],"sourcesContent":["import { Iterable, Index } from './iterable'\nimport { throttled, promising } from '../utils'\nimport './object'\n\n###\nObject keeping track of user-specific properties for a model.\n\nThis and OPModel should rather both inherit from OPObject, and share\n$save,$update etc?\n\n###\nexport global class OPPov < OPObject\n\tdeclare static $for\\any\n\n\tdeclare id\\string\n\n\tstatic get columns\n\t\t$for.deepShape.$pov\n\n\tstatic get $shape\n\t\t$for.$shape.$pov\n\n\tstatic get $fields\n\t\t$for.$shape.$pov\n\n\tstatic get pov?\n\t\tyes\n\n\tstatic def setup parent\n\t\tself\n\n\tget $fields\n\t\t# and id etc?\n\t\t$type.$shape.$pov\n\n\tget $root\n\t\tself\n\n\tget $path\n\t\tnull\n\n\tdef $sync\n\t\tself\n\n\tdef generateId\n\t\tsuper\n\n\tget id\n\t\t#id ||= `{$up}.{$key}`\n\n\tset id val\n\t\t#id\n\n\tget exists?\n\t\trev > 0\n\n\tget embed?\n\t\tno\n\n\tdef $will-set path, value\n\t\tsuper\n\t\t# $up.$plain[\"~{$key}\"] ||= $plain\n\t\tyes\n\n\tdef constructor up,pov\n\t\tpov = OP.get(pov) unless pov isa OPObject\n\t\tlet id = `{up.id}.{pov}`\n\t\tlet cloud = OP.$cloud[id]\n\t\tlet params = cloud or {id:id}\n\t\tparams._rev = 0 if up.local?\n\t\tparams.#up = up\n\t\tparams.#key = pov\n\t\tsuper(params)\n\n\tdef __init__ params\n\t\tlet id = `{params.#up}.{params.#key}`\n\t\tObject.defineProperties(self,{\n\t\t\t$up: {enumerable: no, value: params.#up}\n\t\t\t$key: {enumerable: no, value: params.#key}\n\t\t\tid: {enumerable: no, value: id}\n\t\t\t$memo: {enumerable: no, writable: yes, value: {}}\n\t\t})\n\t\tOP.$rich[id] = self\n\t\t$plain = params\n\t\tself\n\n\tget pov\n\t\t$key\n\n\tdef roles-for agent\n\t\tagent == pov ? OP.OWNER : 0\n\n\t@lazy get $refs\n\t\tnew Index\n\n\tdef save o = {}\n\t\treturn await $save(o)\n\t\t# return self\n\n\tget resolved?\n\t\t# expect this to always be resolved?\n\t\tyes\n\n\tget persisted?\n\t\t$up.persisted?\n\t\t# Povs should always act as if they exist as long as their parent exists\n\n\tdef $save o = {}\n\t\tunless $up.saved?\n\t\t\t# eplicitly ask to be saved later?\n\t\t\tthrow `cannot save pov without first saving parent`\n\n\t\t$cloud ||= {id: id}\n\t\t# TODO We should never try to 'cre' a pov? It should always act as if it was always there, no?\n\t\tsuper\n\n\t# Pov mutations should immediately save unless item is local?\n\tdef $mutated mut\n\t\t$mutations.push(mut)\n\t\tmut.persist! if $web$\n\t\t# should we push the mutations to the parent so that they are included after save?\n\t\t# unless $up.saved?\n\t\t# imba.once($up,'save') do yes\n\t\tself\n\n\t# FIXME does not do reference counting at all now\n\tdef $promote bits\n\t\tlet pre = $roles\n\t\t$roles |= bits\n\t\tlet diff = pre ^ bits\n\t\tlet bit = 0\n\t\tlet num\n\t\tlet refs\n\n\t\twhile (num = 2 ** bit) <= bits\n\t\t\tif bits & num\n\t\t\t\tif !(pre & num)\n\t\t\t\t\tlet k = bits & num\n\t\t\t\t\tif $web$\n\t\t\t\t\t\tlet index = OP.role(bit).$pov($key)\n\t\t\t\t\t\t$up.add-link(index)\n\t\t\t\telse\n\t\t\t\t\t# increment reference count for this\n\t\t\t\t\trefs = $rolerefs ||= {}\n\t\t\t\t\trefs[bit] = (refs[bit] or 0) + 1\n\t\t\t\t\tyes\n\n\t\t\tbit++\n\n\t\t# possibly add object to affiliations\n\t\tif bits and !pre\n\t\t\tpov.$affiliations.incr($up,self)\n\t\tself\n\n\t# FIXME does not support reference counting at all now\n\tdef $demote bits\n\t\tlet pre = $roles\n\t\tlet diff = pre ^ bits\n\t\tlet refs = $rolerefs\n\t\t# $roles ~= bits\n\n\t\tlet bit = 0\n\t\tlet num\n\n\t\twhile (num = 2 ** bit) <= bits\n\t\t\tif bits & num\n\t\t\t\tif refs and refs[bit]\n\t\t\t\t\trefs[bit] -= 1\n\t\t\t\telse\n\t\t\t\t\t$up.remove-link( OP.role(bit).$pov($key) )\n\t\t\t\t\t$roles ~= num\n\t\t\tbit++\n\n\t\t# Remove affiliation\n\t\tif diff and !$roles\n\t\t\tpov.$affiliations.decr($up,self)\n\t\tself\n\n\t# def $resolve force=no\n\n\tdef $serialize o = {}\n\t\tlet obj = $fields.$serialize(self,o)\n\t\tobj.id = id\n\t\tobj._pov = String($key)\n\t\t# obj._exp = OP.now\n\t\treturn obj\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,MAAM,EAAG,QAAQ,CAAE,KAAK,OAAQ,YAAY;AAC5C,MAAM,EAAG,SAAS,CAAE,SAAS,OAAQ,UAAU;AAC/C,MAAM,CAAC,UAAU;;;;;;;;;;AASjB,MAAM,CAAQ,KAAK,CAAC,KAAK,SAAG,QAAQ,EAAA;;CAKnC,MAAM,CAAC,GAAG,CAAC,OAAO,EAAA;;EACjB,OAAA,KAAA,IAAI,CAAC,SAAS,CAAC,IAAI;EAAA;;CAEpB,MAAM,CAAC,GAAG,CAAC,MAAM,EAAA;;EAChB,OAAA,KAAA,IAAI,CAAC,MAAM,CAAC,IAAI;EAAA;;CAEjB,MAAM,CAAC,GAAG,CAAC,OAAO,EAAA;;EACjB,OAAA,KAAA,IAAI,CAAC,MAAM,CAAC,IAAI;EAAA;;CAEjB,MAAM,CAAC,GAAG,CAAC,IAAI,EAAA;;EACd,OAAA,IAAG;EAAA;;CAEJ,MAAM,CAAK,KAAK,CAAC,MAAM,CAAA;;EACtB,OAAA,IAAI;EAAA;;CAEL,GAAG,CAAC,OAAO,EAAA;;;EAEV,OAAA,KAAA,KAAK,CAAC,MAAM,CAAC,IAAI;EAAA;;CAElB,GAAG,CAAC,KAAK,EAAA;;EACR,OAAA,IAAI;EAAA;;CAEL,GAAG,CAAC,KAAK,EAAA;;EACR,OAAA,IAAI;EAAA;;CAED,KAAK,EAAA;;EACR,OAAA,IAAI;EAAA;;CAED,UAAU,EAAA;;EACb,OAAA,MADG,UAAU,cACR;EAAA;;CAEN,GAAG,CAAC,EAAE,EAAA;;mBACF,KAAK,MAAE,KAAA,GAAG,SAAG,KAAA,IAAI,CAAE;EAAA;;CAEvB,GAAG,CAAC,EAAE,CAAC,GAAG,CAAA;;YACN;EAAA;;CAEJ,GAAG,CAAC,OAAO,EAAA;;EACV,OAAA,KAAA,GAAG,CAAC,CAAC,CAAC,CAAC;EAAA;;CAER,GAAG,CAAC,MAAM,EAAA;;EACT,OAAA,KAAE;EAAA;;CAEC,SAAS,CAAC,IAAI,CAAE,KAAK,CAAA;;EACxB,MADG,SAAS,cACP;;EAEL,OAAA,IAAG;EAAA;;CAEA,WAAW,CAAC,EAAE,CAAC,GAAG,CAAA;;EACH,EAAM,IAAC,CAAA,GAAG,YAAK,QAAQ,CAAA,GAAzC,EAAA,GAAG,GAAG,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAA;MACb,EAAE,GAAG,MAAE,CAAA,EAAE,CAAC,EAAE,CAAA,SAAG,GAAG,CAAE;MACpB,KAAK,GAAG,EAAE,CAAC,MAAM,CAAA,EAAG,CAAC;MACrB,MAAM,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE,EAAC,EAAE,CAAC;EACb,EAAE,EAAC,EAAE,CAAC,MAAM,EAA5B,EAAA,MAAM,CAAC,IAAI,GAAG,CAAC,EAAA;EACf,MAAM,MAAI,GAAG,EAAE;EACf,MAAM,OAAK,GAAG,GAAG;EACjB,KAAK,CAAC,MAAM,CAAC;;EAAA;;CAEV,QAAQ,CAAC,MAAM,CAAA;;MACd,EAAE,GAAG,MAAE,CAAA,MAAM,OAAI,SAAG,CAAA,MAAM,QAAK,CAAE;EACrC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC;GAC5B,GAAG,EAAE,CAAC,UAAU,EAAE,KAAE,CAAE,KAAK,EAAE,MAAM,MAAI,CAAC;GACxC,IAAI,EAAE,CAAC,UAAU,EAAE,KAAE,CAAE,KAAK,EAAE,MAAM,OAAK,CAAC;GAC1C,EAAE,EAAE,CAAC,UAAU,EAAE,KAAE,CAAE,KAAK,EAAE,EAAE,CAAC;GAC/B,KAAK,EAAE,CAAC,UAAU,EAAE,KAAE,CAAE,QAAQ,EAAE,IAAG,CAAE,KAAK,EAAE,EAAE,CAAC;GACjD,CAAC;EACF,EAAE,CAAC,KAAK,CAAA,EAAG,CAAC,GAAG,IAAI;EACnB,KAAA,MAAM,GAAG,MAAM;EACf,OAAA,IAAI;EAAA;;CAEL,GAAG,CAAC,GAAG,EAAA;;EACN,OAAA,KAAA,IAAI;EAAA;;CAED,SAAS,CAAC,KAAK,CAAA;;SAClB,CAAA,KAAK,CAAC,EAAE,CAAC,KAAA,GAAG,CAAA,GAAG,EAAE,CAAC,KAAK,GAAG,CAAC;EAAA;;CAEtB,GAAG,CAAC,KAAK,EAAA;;EACd,OAAA,GAAG,CAAC,KAAK;EAAA;;OAEN,IAAI,CAAC,CAAC,GAAG,EAAE,CAAA;;EACd,MAAM,OAAO,KAAA,KAAK,CAAC,CAAC,CAAC;;EACR;;CAEd,GAAG,CAAC,SAAS,EAAA;;;EAEZ,OAAA,IAAG;EAAA;;CAEJ,GAAG,CAAC,UAAU,EAAA;;EACb,OAAA,KAAA,GAAG,CAAC,UAAU;;EAC0D;;CAErE,KAAK,CAAC,CAAC,GAAG,EAAE,CAAA;;EACf,EAAM,IAAC,KAAA,GAAG,CAAC,MAAM,GAAA;;;SAEV,6CAA6C;GAAA;;EAEpD,KAAA,MAAM,KAAK,CAAC,EAAE,EAAE,KAAA,EAAE,CAAC;;EAEnB,OAAA,MAPG,KAAK,cAOH;EAAA;;;CAGF,QAAQ,CAAC,GAAG,CAAA;;EACf,KAAA,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC;EACP,EAAE,EAAC,KAAK;;;;EAIrB,OAAA,IAAI;EAAA;;;CAGD,QAAQ,CAAC,IAAI,CAAA;;MACZ,GAAG,GAAG,KAAA,MAAM;EAChB,KAAA,MAAM,CAAC,EAAE,CAAC,IAAI;MACV,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI;MACjB,GAAG,GAAG,CAAC;MACP,GAAG;MACH,IAAI;;UAED,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAA;;GAC7B,EAAE,EAAC,IAAI,CAAC,CAAC,CAAC,GAAG,EAAA;;IACZ,EAAE,EAAC,GAAE,GAAG,CAAC,CAAC,CAAC,GAAG,IAAC;;SACV,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG;KAClB,EAAE,EAAC,KAAK;KAEY,MACjB;;;KAEH,IAAI,GAAG,KAAA,SAAS,KAAK,EAAE;KACvB,IAAI,CAAA,GAAI,CAAC,IAAI,IAAI,CAAA,GAAI,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;KAChC,IAAG;KAAA;IAAA;;GAEL,GAAG,EAAE;GAAA;;;EAGN,EAAE,EAAC,IAAI,CAAC,EAAG,CAAC,EAAC,GAAG,CAAA,EAAA;;GACf,KAAA,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,KAAA,GAAG,CAAC,IAAI,CAAC;GAAA;EACjC,OAAA,IAAI;EAAA;;;CAGD,OAAO,CAAC,IAAI,CAAA;;MACX,GAAG,GAAG,KAAA,MAAM;MACZ,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,IAAI;MACjB,IAAI,GAAG,KAAA,SAAS;;;MAGhB,GAAG,GAAG,CAAC;MACP,GAAG;;UAEA,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAA;;GAC7B,EAAE,EAAC,IAAI,CAAC,CAAC,CAAC,GAAG,EAAA;;IACZ,EAAE,EAAC,IAAI,CAAC,EAAG,CAAC,IAAI,CAAA,GAAI,CAAC,EAAA;;KACpB,IAAI,CAAA,GAAI,CAAC,IAAI,CAAC;KAAA,MACX;;KACH,KAAA,GAAG,CAAC,WAAW,CAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,KAAA,IAAI,CAAC,CAAE;KAC1C,KAAA,MAAM,KAAI,GAAG;KAAA;IAAA;GACf,GAAG,EAAE;GAAA;;;EAGN,EAAE,EAAC,IAAI,CAAC,EAAG,CAAC,EAAC,KAAA,MAAM,CAAA,EAAA;;GAClB,KAAA,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,KAAA,GAAG,CAAC,IAAI,CAAC;GAAA;EACjC,OAAA,IAAI;EAAA;;;;CAID,UAAU,CAAC,CAAC,GAAG,EAAE,CAAA;;MAChB,GAAG,GAAG,KAAA,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;EACpC,GAAG,CAAC,EAAE,GAAG,KAAA,EAAE;EACX,GAAG,CAAC,IAAI,GAAG,MAAM,CAAC,KAAA,IAAI,CAAC;;EAEvB,MAAM,CAAC,GAAG;EAAA;;;;;AAAA,cA9KQ,KAAK,GAAL,KAAK;AA+KzB;"}},"css":{"code":""},"warnings":[],"errors":[]}
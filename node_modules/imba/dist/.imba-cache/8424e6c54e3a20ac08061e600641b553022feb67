{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction decorate$__(decorators,target,key,desc){\n\tvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\tif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\telse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\treturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport {αlazy as imba_αlazy, use_hooks as imba_use_hooks, hooks as imba_hooks, accessor as imba_accessor, commit as imba_commit} from 'imba';\n(imba_use_hooks());\nvar $1 = Symbol('id'), $2 = Symbol(), $3 = Symbol('name'), $4 = Symbol(), $5 = Symbol(), $6 = Symbol('id'), $7 = Symbol(), $8 = Symbol('creator'), $9 = Symbol(), $10 = Symbol('name'), $11 = Symbol(), $12 = Symbol('type'), $13 = Symbol(), $14 = Symbol('size'), $15 = Symbol(), $16 = Symbol('hash'), $17 = Symbol(), $18 = Symbol(), $20, $21, $23, $24, $25, $26, $27, $28;\nconst $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__');\n\n/*body*/\nimport {BinaryStream,BinaryChunk,BinaryState} from '../fields/binarystream';\nimport {Index} from '../core/iterable';\nimport '../core/socket';\nimport * as os from '../util/os';\n\nclass OPBlobState extends OPObject {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $19;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\tfields && ($19 = $$.id) !== undefined && this.ααid.$init($19,this,$1,'id',$$);\n\t\tfields && ($19 = $$.name) !== undefined && this.ααname.$init($19,this,$3,'name',$$);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$5 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tfields && this.ααid.$init($$ ? $$.id : undefined,this,$1,'id',$$);\n\t\tfields && this.ααname.$init($$ ? $$.name : undefined,this,$3,'name',$$);\n\t\t\n\t}\n\tset id(val){ this.ααid.$set(val,this,$1,'id') }\n\tget id(){ return this.ααid.$get(this,$1,'id') }\n\tget ααid(){ return this[$2] || imba_accessor(($20 = this.αkey(),($20.virtual instanceof Function) ? $20.virtual() : ($20.virtual = true),$20),this,$1,'id',$2,OPBlobState.prototype) }\n\tset name(val){ this.ααname.$set(val,this,$3,'name') }\n\tget name(){ return this.ααname.$get(this,$3,'name') }\n\tget ααname(){ return this[$4] || imba_accessor(($21 = this.αstring(),$21),this,$3,'name',$4,OPBlobState.prototype) }\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $5;defineName$__(this,'OPBlobState');inheritClass$__(this);}\n}; globalThis.OPBlobState = OPBlobState;\n\n/*\nThis should be called stream, not blob? Or just binary\n*/\n\nexport class OPBlob extends OPObject {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $22;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\tfields && ($22 = $$.id) !== undefined && this.ααid.$init($22,this,$6,'id',$$);\n\t\tfields && ($22 = $$.creator) !== undefined && this.ααcreator.$init($22,this,$8,'creator',$$);\n\t\tfields && ($22 = $$.name) !== undefined && this.ααname.$init($22,this,$10,'name',$$);\n\t\tfields && ($22 = $$.type) !== undefined && this.ααtype.$init($22,this,$12,'type',$$);\n\t\tfields && ($22 = $$.size) !== undefined && this.ααsize.$init($22,this,$14,'size',$$);\n\t\tfields && ($22 = $$.hash) !== undefined && this.ααhash.$init($22,this,$16,'hash',$$);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$18 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tfields && this.ααid.$init($$ ? $$.id : undefined,this,$6,'id',$$);\n\t\tfields && this.ααcreator.$init($$ ? $$.creator : undefined,this,$8,'creator',$$);\n\t\tfields && this.ααname.$init($$ ? $$.name : undefined,this,$10,'name',$$);\n\t\tfields && this.ααtype.$init($$ ? $$.type : undefined,this,$12,'type',$$);\n\t\tfields && this.ααsize.$init($$ ? $$.size : undefined,this,$14,'size',$$);\n\t\tfields && this.ααhash.$init($$ ? $$.hash : undefined,this,$16,'hash',$$);\n\t\t\n\t}\n\t\n\t// all of this doesnt make sense?\n\tset id(val){ this.ααid.$set(val,this,$6,'id') }\n\tget id(){ return this.ααid.$get(this,$6,'id') }\n\tget ααid(){ return this[$7] || imba_accessor(($23 = this.αkey(),($23.size instanceof Function) ? $23.size(16) : ($23.size = 16),$23),this,$6,'id',$7,OPBlob.prototype) }\n\tset creator(val){ this.ααcreator.$set(val,this,$8,'creator') }\n\tget creator(){ return this.ααcreator.$get(this,$8,'creator') }\n\tget ααcreator(){ return this[$9] || imba_accessor(($24 = this.αref(OP.User),($24.as instanceof Function) ? $24.as(OP.CREATOR) : ($24.as = OP.CREATOR),$24.default = function() {\n\t\treturn OP.user;\n\t},$24),this,$8,'creator',$9,OPBlob.prototype) }\n\t\n\t// how do we handle write operations etc?\n\t// we're not using these properties anymore\n\tset name(val){ this.ααname.$set(val,this,$10,'name') }\n\tget name(){ return this.ααname.$get(this,$10,'name') }\n\tget ααname(){ return this[$11] || imba_accessor(($25 = this.αstring(),($25.w instanceof Function) ? $25.w(OP.CREATOR) : ($25.w = OP.CREATOR),$25),this,$10,'name',$11,OPBlob.prototype) }\n\tset type(val){ this.ααtype.$set(val,this,$12,'type') }\n\tget type(){ return this.ααtype.$get(this,$12,'type') }\n\tget ααtype(){ return this[$13] || imba_accessor(($26 = this.αstring(),($26.w instanceof Function) ? $26.w(OP.CREATOR) : ($26.w = OP.CREATOR),$26),this,$12,'type',$13,OPBlob.prototype) }\n\tset size(val){ this.ααsize.$set(val,this,$14,'size') }\n\tget size(){ return this.ααsize.$get(this,$14,'size') }\n\tget ααsize(){ return this[$15] || imba_accessor(($27 = this.αsize(),($27.w instanceof Function) ? $27.w(OP.CREATOR) : ($27.w = OP.CREATOR),$27.default = function() {\n\t\treturn 0;\n\t},$27.default.literal = 0,$27),this,$14,'size',$15,OPBlob.prototype) }\n\tset hash(val){ this.ααhash.$set(val,this,$16,'hash') }\n\tget hash(){ return this.ααhash.$get(this,$16,'hash') }\n\tget ααhash(){ return this[$17] || imba_accessor(($28 = this.αnumber(),($28.w instanceof Function) ? $28.w(OP.CREATOR) : ($28.w = OP.CREATOR),$28.default = function() {\n\t\treturn 0;\n\t},$28.default.literal = 0,$28),this,$16,'hash',$17,OPBlob.prototype) }\n\t\n\t// frozen? or state with rich enum vals\n\t\n\tget buffer(){\n\t\t\n\t\treturn new BinaryStream({size: (this.size || 0),hash: (this.hash || 0)});\n\t}\n\t\n\t/**\n\t@param {any[]} data\n\t*/\n\twrite(offset,data){\n\t\t\n\t\treturn;\n\t}\n\t\n\tget path(){\n\t\t\n\t\treturn ((\"\" + (process.env.OP_LFS_DIR) + `/` + this.id));\n\t}\n\t\n\tappend(chunk,at){\n\t\t\n\t\tlet before = this.buffer.state;\n\t\t\n\t\t// what should the interface return?\n\t\t// should it throw or simply return the same hash?\n\t\t// makes sense to be able to roll back to a specific position\n\t\tif (!(at)) {\n\t\t\t\n\t\t\tat = before;\n\t\t};\n\t\t\n\t\tlet after = this.buffer.append(chunk,at);\n\t\t\n\t\t// if we have a request from the server -\n\t\tif (after) {\n\t\t\t\n\t\t\tthis.socket.send(after);\n\t\t};\n\t\t\n\t\treturn after;\n\t}\n\t\n\t/**\n\t@param {BinaryPatch} chunk\n\t*/\n\tpatch(chunk){\n\t\t\n\t\tlet res = this.buffer.patch(chunk);\n\t\treturn this.socket.send(chunk);\n\t}\n\t\n\t$patch(val){\n\t\t\n\t\t// if this is fresh\n\t\t\n\t\tif (false && (val instanceof File)) {\n\t\t\t\n\t\t\tif (!(this.localΦ)) {\n\t\t\t\t\n\t\t\t\tthrow \"Cannot set blob on already existing OPBlob\";\n\t\t\t};\n\t\t\tthis.log(this.rolesΞfor(OP.user),!(!(this.$up)),this.$up?.creator,this.$up?.creator == OP.user);\n\t\t\t\n\t\t\tlet raw = {\n\t\t\t\tname: val.name,\n\t\t\t\ttype: val.type,\n\t\t\t\tsize: val.size\n\t\t\t};\n\t\t\treturn super.$patch(raw);\n\t\t} else {\n\t\t\t\n\t\t\treturn super.$patch(...arguments);\n\t\t};\n\t}\n\t\n\tget url(){\n\t\t\n\t\treturn (\"\" + (false ? true : '') + `/op/fs/` + this.id);\n\t}\n\t\n\tget socket(){\n\t\t\n\t\treturn new OPSocket(this,(`/op/room/` + this.id));\n\t}\n\t\n\tget handle(){\n\t\t\n\t\treturn new OPBlobHandle(this);\n\t}\n\t\n\topen(){\n\t\t\n\t\tthis.socket.open();\n\t\treturn this;\n\t}\n\t\n\tclose(){\n\t\t\n\t\tthis.socket?.close?.();\n\t\treturn this;\n\t}\n\t\n\tflush(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tget raw(){\n\t\t\n\t\treturn this.buffer.buffer;\n\t}\n\t\n\tget byteLength(){\n\t\t\n\t\treturn this.buffer.byteLength;\n\t}\n\t\n\trequest(req,to){\n\t\t\n\t\tif (!((req instanceof BinaryChunkRequest))) {\n\t\t\t\n\t\t\treq = new BinaryChunkRequest(req,to);\n\t\t};\n\t\treturn this.socket.send(req);\n\t}\n\t\n\tonmessage(msg,from){\n\t\t\n\t\tthis.log('message from socket',msg);\n\t\t// handle incoming messages\n\t\tif (msg instanceof BinaryState) {\n\t\t\t\n\t\t\t// log 'got state from server!',msg,self\n\t\t\tthis.serverState = msg;\n\t\t\tif (this.byteLength < msg.byteLength) {\n\t\t\t\t\n\t\t\t\tthis.log(`we have less bytes!`);\n\t\t\t\tthis.request(this.byteLength,msg.byteLength);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (msg instanceof BinaryChunkRequest) {\n\t\t\t\n\t\t\tthis.serverRequest = msg;\n\t\t\tlet chunk = this.buffer.chunk(msg.offset,msg.end);\n\t\t\tfrom.send(chunk);\n\t\t};\n\t\t\n\t\tif (msg instanceof BinaryChunk) {\n\t\t\t\n\t\t\t// what if it crashes?\n\t\t\tlet res = this.buffer.load(msg);\n\t\t\tthis.log('got data from server?',msg,res);\n\t\t\t// if there's a hole, respond with a request for the hole\n\t\t\tif (res instanceof BinaryChunkRequest) {\n\t\t\t\t\n\t\t\t\treturn from.send(res);\n\t\t\t};\n\t\t};\n\t}\n\t\n\tasync arrayBuffer(){\n\t\t\n\t\tawait this.fetch();\n\t\treturn this.buffer.slice(0).buffer;\n\t}\n\t\n\tasync fetch(){\n\t\t\n\t\tawait this;\n\t\tif (this.localΦ) { return this };\n\t\t// log 'resolved self - now fetch!',size\n\t\tlet url = this.url;\n\t\tlet start = 0;\n\t\tlet end = null;\n\t\tlet range = (`bytes=` + start + `-` + (end || ''));\n\t\t\n\t\tlet resp = await globalThis.fetch(url,{headers: {\n\t\t\tRange: range,\n\t\t\t'Cache-Control': 'no-cache'// why no cache?\n\t\t}});\n\t\t\n\t\tresp.body[Symbol.asyncIterator] = function() {\n\t\t\t\n\t\t\tlet reader = resp.body.getReader();\n\t\t\treturn {next: function() { return reader.read(); }};\n\t\t};\n\t\t\n\t\tlet from = start;\n\t\tfor await (let bytes of iter$__(resp.body)){\n\t\t\t\n\t\t\tlet chunk = new BinaryChunk(from,bytes);\n\t\t\tthis.buffer.load(chunk);\n\t\t\tfrom += bytes.length;\n\t\t\t// buffer.add(chunk,from)\n\t\t};\n\t\treturn imba_commit();\n\t\t// socket not for audiofiles etc? Only if they seem to still be open?\n\t\t// log 'done loading?!?'\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $18;this.prototype[$__hooks__$] = imba_hooks;\n\t\tdefineName$__(this,'OPBlob');this.alias = 'B';\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'buffer',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'socket',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'handle',null);\n\t\tinheritClass$__(this);}\n}; globalThis.OPBlob = OPBlob;\n\n","dependencies":[],"map":{"version":3,"file":"blob.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/types/blob.imba"],"sourcesContent":["import {BinaryStream, BinaryChunk, BinaryState} from '../fields/binarystream'\nimport {Index} from '../core/iterable'\nimport '../core/socket'\nimport * as os from '../util/os'\n\nglobal class OPBlobState < OPObject\n\tid @key.virtual\n\tname @string\n\n###\nThis should be called stream, not blob? Or just binary\n###\nexport global class OPBlob < OPObject\n\tstatic alias = 'B'\n\t# all of this doesnt make sense?\n\tid @key.size(16)\n\tcreator @ref(OP.User).as(OP.CREATOR) = OP.user\n\n\t# how do we handle write operations etc?\n\t# we're not using these properties anymore\n\tname @string.w(OP.CREATOR)\n\ttype @string.w(OP.CREATOR)\n\tsize @size.w(OP.CREATOR) = 0\n\thash @number.w(OP.CREATOR) = 0\n\n\t# frozen? or state with rich enum vals\n\n\t@lazy get buffer\n\t\tnew BinaryStream({size:(size or 0),hash:(hash or 0)})\n\n\tdef write offset, data\\any[]\n\t\treturn\n\n\tget path\n\t\t$node$ ? `{process.env.OP_LFS_DIR}/{id}` : `/op/fs/{id}`\n\n\tdef append chunk, at\n\t\tlet before = buffer.state\n\n\t\t# what should the interface return?\n\t\t# should it throw or simply return the same hash?\n\t\t# makes sense to be able to roll back to a specific position\n\t\tunless at\n\t\t\tat = before\n\n\t\tlet after = buffer.append(chunk,at)\n\n\t\t# if we have a request from the server -\n\t\tif after\n\t\t\tsocket.send(after)\n\n\t\treturn after\n\n\tdef patch chunk\\BinaryPatch\n\t\tlet res = buffer.patch(chunk)\n\t\tsocket.send(chunk)\n\n\tdef $patch val\n\t\t# if this is fresh\n\n\t\tif $web$ and val isa File\n\t\t\tunless local?\n\t\t\t\tthrow \"Cannot set blob on already existing OPBlob\"\n\t\t\tlog roles-for(OP.user),!!$up,$up..creator,$up..creator == OP.user\n\n\t\t\tlet raw = {\n\t\t\t\tname: val.name\n\t\t\t\ttype: val.type\n\t\t\t\tsize: val.size\n\t\t\t}\n\t\t\tsuper(raw)\n\t\telse\n\t\t\tsuper\n\n\tget url\n\t\t`{$web$ ? global.location.origin : ''}/op/fs/{id}`\n\n\t@lazy get socket\n\t\tnew OPSocket(self,`/op/room/{id}`)\n\n\t@lazy get handle\n\t\tnew OPBlobHandle(self)\n\n\tdef open\n\t\tsocket.open!\n\t\tself\n\n\tdef close\n\t\tsocket..close!\n\t\tself\n\n\tdef flush\n\t\tyes\n\n\tget raw\n\t\tbuffer.buffer\n\n\tget byteLength\n\t\tbuffer.byteLength\n\n\tdef request req,to\n\t\tunless req isa BinaryChunkRequest\n\t\t\treq = new BinaryChunkRequest(req,to)\n\t\tsocket.send(req)\n\n\tdef onmessage msg,from\n\t\tlog 'message from socket',msg\n\t\t# handle incoming messages\n\t\tif msg isa BinaryState\n\t\t\t# log 'got state from server!',msg,self\n\t\t\tserverState = msg\n\t\t\tif byteLength < msg.byteLength\n\t\t\t\tlog `we have less bytes!`\n\t\t\t\trequest(byteLength,msg.byteLength)\n\n\t\tif msg isa BinaryChunkRequest\n\t\t\tserverRequest = msg\n\t\t\tlet chunk = buffer.chunk(msg.offset,msg.end)\n\t\t\tfrom.send(chunk)\n\n\t\tif msg isa BinaryChunk\n\t\t\t# what if it crashes?\n\t\t\tlet res = buffer.load(msg)\n\t\t\tlog 'got data from server?',msg,res\n\t\t\t# if there's a hole, respond with a request for the hole\n\t\t\tif res isa BinaryChunkRequest\n\t\t\t\tfrom.send(res)\n\n\tdef arrayBuffer\n\t\tawait fetch!\n\t\treturn buffer.slice(0).buffer\n\n\tdef fetch\n\t\tawait self\n\t\treturn self if local?\n\t\t# log 'resolved self - now fetch!',size\n\t\tlet url = url\n\t\tlet start = 0\n\t\tlet end = null\n\t\tlet range = `bytes={start}-{end or ''}`\n\n\t\tlet resp = await global.fetch(url, headers: {\n\t\t\tRange: range\n\t\t\t'Cache-Control': 'no-cache' # why no cache?\n\t\t})\n\n\t\tresp.body[Symbol.asyncIterator] = do\n\t\t\tlet reader = resp.body.getReader!\n\t\t\treturn {next: do reader.read!}\n\n\t\tlet from = start\n\t\tfor await bytes of resp.body\n\t\t\tlet chunk = new BinaryChunk(from,bytes)\n\t\t\tbuffer.load(chunk)\n\t\t\tfrom += bytes.length\n\t\t\t# buffer.add(chunk,from)\n\t\timba.commit!\n\t\t# socket not for audiofiles etc? Only if they seem to still be open?\n\t\t# log 'done loading?!?'\n\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};\nconst $appendChild$ = Symbol.for('#appendChild'), $insertChild$ = Symbol.for('#insertChild'), $replaceWith$ = Symbol.for('#replaceWith'), $insertInto$ = Symbol.for('#insertInto'), $removeFrom$ = Symbol.for('#removeFrom'), $afterVisit$ = Symbol.for('#afterVisit'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $domFlags$ = Symbol.for('#domFlags'), $$parent$ = Symbol.for('##parent'), $end$ = Symbol.for('#end'), $removeChild$ = Symbol.for('#removeChild');\nvar $1 = Symbol();\n\n/*body*/\nimport {createComment} from './core';\nimport {Fragment} from './fragment';\nimport {RenderContext} from './context';\n\nclass KeyedTagFragment extends Fragment {\n\t\n\t\n\tconstructor(f,parent){\n\t\t\n\t\tsuper(...arguments);\n\t\tthis[$domFlags$] = f;\n\t\tthis[$$parent$] = parent;\n\t\tthis.changes = new Map;\n\t\tthis.dirty = false;\n\t\tthis.array = this.childNodes;\n\t\tthis.$ = new RenderContext(this,Symbol());\n\t\t\n\t\tif (!((f & 256))) {\n\t\t\t\n\t\t\tthis[$end$] = createComment('map');\n\t\t};\n\t\t\n\t\tif (parent) {\n\t\t\t\n\t\t\tparent[$appendChild$](this);\n\t\t};this[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\t[$appendChild$](item){\n\t\t\n\t\tif (this.parentNode) {\n\t\t\t\n\t\t\treturn this.parentNode[$insertChild$](item,this[$end$]);\n\t\t};\n\t}\n\t\n\thasChildNodes(){\n\t\t\n\t\tif (this.childNodes.length == 0) { return false };\n\t\treturn true;\n\t}\n\t\n\tpush(item,idx){\n\t\t\n\t\t// on first iteration we can merely run through\n\t\tif (!(this[$domFlags$] & 1)) {\n\t\t\t\n\t\t\t\n\t\t\tthis.array.push(item);\n\t\t\tthis[$appendChild$](item);\n\t\t\treturn;\n\t\t};\n\t\t\n\t\tlet toReplace = this.array[idx];\n\t\t\n\t\tif (toReplace === item) {\n\t\t\t\n\t\t\ttrue;\n\t\t} else {\n\t\t\t\n\t\t\tthis.dirty = true;\n\t\t\t// if this is a new item\n\t\t\tlet prevIndex = this.array.indexOf(item);\n\t\t\tlet changed = this.changes.get(item);\n\t\t\t\n\t\t\tif (prevIndex === -1) {\n\t\t\t\t\n\t\t\t\t// should we mark the one currently in slot as removed?\n\t\t\t\tthis.array.splice(idx,0,item);\n\t\t\t\tthis.insertChild(item,idx,prevIndex);\n\t\t\t} else if (prevIndex === idx + 1) {\n\t\t\t\t\n\t\t\t\tif (toReplace) {\n\t\t\t\t\t\n\t\t\t\t\tthis.changes.set(toReplace,-1);\n\t\t\t\t};\n\t\t\t\tthis.array.splice(idx,1);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (prevIndex >= 0) { this.array.splice(prevIndex,1) };\n\t\t\t\tthis.array.splice(idx,0,item);\n\t\t\t\tthis.moveChild(item,idx,prevIndex);\n\t\t\t};\n\t\t\t\n\t\t\tif (changed == -1) {\n\t\t\t\t\n\t\t\t\tthis.changes.delete(item);\n\t\t\t};\n\t\t};\n\t\treturn;\n\t}\n\t\n\tinsertChild(item,index,prevIndex){\n\t\t\n\t\tlet par = this.parentNode;\n\t\tif (!(par)) { return };\n\t\t// log 'insertBefore',index,item,parentNode\n\t\tif (index > 0) {\n\t\t\t\n\t\t\tlet other = this.array[index - 1];\n\t\t\t// will fail with text nodes\n\t\t\tpar[$insertChild$](item,other.nextSibling);\n\t\t} else {\n\t\t\t\n\t\t\tpar[$insertChild$](item,this.childNodes[index + 1] || this[$end$]);\n\t\t};\n\t\treturn;\n\t}\n\t\n\tmoveChild(item,index,prevIndex){\n\t\t\n\t\treturn this.insertChild(item,index,prevIndex);\n\t}\n\t\n\tremoveChild(item,index){\n\t\t\n\t\t// self.map.delete(item)\n\t\t// what if this is a fragment or virtual node?\n\t\tif (item.parentNode) {\n\t\t\t\n\t\t\t// log 'removeChild',item,item.parentNode\n\t\t\titem[$removeFrom$](item.parentNode);\n\t\t};\n\t\treturn;\n\t}\n\t\n\t[$insertChild$](node,relnode){\n\t\t\n\t\treturn;\n\t}\n\t\n\t// def #appendChild\n\t// return\n\t\n\t[$replaceWith$](rel,parent){\n\t\t\n\t\tlet res = rel[$insertInto$](parent,this[$end$]);\n\t\tthis[$removeFrom$](parent);\n\t\treturn res;\n\t}\n\t\n\t[$insertInto$](parent,before){\n\t\t\n\t\t// log 'insertInto',parent,before\n\t\tthis[$$parent$] = parent;\n\t\tlet prev = this.parentNode;\n\t\tif (parent != prev) {\n\t\t\t\n\t\t\tthis.parentNode = parent;\n\t\t\t// #start.#insertInto(parent,before) if #start\n\t\t\tfor (let i = 0, $2 = iter$__(this.array), $3 = $2.length; i < $3; i++) {\n\t\t\t\tlet item = $2[i];\n\t\t\t\titem[$insertInto$](parent,before);\n\t\t\t};\n\t\t\t\n\t\t\tif (this[$end$]) {\n\t\t\t\t\n\t\t\t\tthis[$end$][$insertInto$](parent,before);\n\t\t\t};\n\t\t\t// attachNodes!\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t[$removeFrom$](parent){\n\t\t\n\t\t// log '#removeFrom!',parent\n\t\t\n\t\tfor (let $4 = 0, $5 = iter$__(this.array), $6 = $5.length; $4 < $6; $4++) {\n\t\t\tlet item = $5[$4];\n\t\t\tparent[$removeChild$](item);\n\t\t};\n\t\tif (this[$end$]) { parent[$removeChild$](this[$end$]) };\n\t\t// parent.#removeChild(#start) if #start\n\t\treturn this.parentNode = null;\n\t}\n\t\n\t[$afterVisit$](index){\n\t\tvar self = this;\n\t\t\n\t\tif (!(this[$domFlags$] & 1)) {\n\t\t\t\n\t\t\tthis[$domFlags$] |= 1;\n\t\t\t// what if parent was not even set yet?\n\t\t\treturn;\n\t\t};\n\t\t\n\t\tif (this.dirty) {\n\t\t\t\n\t\t\t\n\t\t\tthis.changes.forEach(function(pos,item) {\n\t\t\t\t\n\t\t\t\tif (pos == -1) {\n\t\t\t\t\t\n\t\t\t\t\treturn self.removeChild(item);\n\t\t\t\t};\n\t\t\t});\n\t\t\tthis.changes.clear();\n\t\t\tthis.dirty = false;\n\t\t};\n\t\t\n\t\t// there are some items we should remove now\n\t\tif (this.array.length > index) {\n\t\t\t\n\t\t\t\n\t\t\t// remove the children below\n\t\t\twhile (this.array.length > index){\n\t\t\t\t\n\t\t\t\tlet item = this.array.pop();\n\t\t\t\tthis.removeChild(item);\n\t\t\t};\n\t\t};\n\t\treturn;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'KeyedTagFragment');inheritClass$__(this);}\n};\n\nexport function createKeyedList(bitflags,parent){\n\t\n\treturn new KeyedTagFragment(bitflags,parent);\n};\n","dependencies":[],"map":{"version":3,"file":"keyed-list.js","sourceRoot":"","sources":["/Users/sindre/repos/imba/packages/imba/src/imba/dom/keyed-list.imba"],"sourcesContent":["import {createComment} from './core'\nimport {Fragment} from './fragment'\nimport {RenderContext} from './context'\n\nclass KeyedTagFragment < Fragment\n\n\tdef constructor f, parent\n\t\tsuper\n\t\t#domFlags = f\n\t\t##parent = parent\n\t\tchanges = new Map\n\t\tdirty = no\n\t\tarray = childNodes\n\t\tself.$ = new RenderContext(self,Symbol!)\n\n\t\tif !(f & $TAG_LAST_CHILD$)\n\t\t\t#end = createComment('map')\n\n\t\tif parent\n\t\t\tparent.#appendChild(self)\n\n\tdef #appendChild item\n\t\tif parentNode\n\t\t\tparentNode.#insertChild(item,#end)\n\n\tdef hasChildNodes\n\t\treturn false if childNodes.length == 0\n\t\treturn true\n\n\tdef push item, idx\n\t\t# on first iteration we can merely run through\n\t\tunless #domFlags & $TAG_INITED$\n\n\t\t\tself.array.push(item)\n\t\t\tself.#appendChild(item)\n\t\t\treturn\n\n\t\tlet toReplace = self.array[idx]\n\n\t\tif toReplace === item\n\t\t\tyes\n\t\telse\n\t\t\tself.dirty = yes\n\t\t\t# if this is a new item\n\t\t\tlet prevIndex = self.array.indexOf(item)\n\t\t\tlet changed = self.changes.get(item)\n\n\t\t\tif prevIndex === -1\n\t\t\t\t# should we mark the one currently in slot as removed?\n\t\t\t\tself.array.splice(idx,0,item)\n\t\t\t\tself.insertChild(item,idx,prevIndex)\n\n\t\t\telif prevIndex === idx + 1\n\t\t\t\tif toReplace\n\t\t\t\t\tself.changes.set(toReplace,-1)\n\t\t\t\tself.array.splice(idx,1)\n\n\t\t\telse\n\t\t\t\tself.array.splice(prevIndex,1) if prevIndex >= 0\n\t\t\t\tself.array.splice(idx,0,item)\n\t\t\t\tself.moveChild(item,idx,prevIndex)\n\n\t\t\tif changed == -1\n\t\t\t\tself.changes.delete(item)\n\t\treturn\n\n\tdef insertChild item, index, prevIndex\n\t\tlet par = parentNode\n\t\treturn unless par\n\t\t# log 'insertBefore',index,item,parentNode\n\t\tif index > 0\n\t\t\tlet other = self.array[index - 1]\n\t\t\t# will fail with text nodes\n\t\t\tpar.#insertChild(item,other.nextSibling)\n\t\telse\n\t\t\tpar.#insertChild(item,childNodes[index + 1] or #end)\n\t\treturn\n\n\tdef moveChild item, index, prevIndex\n\t\tinsertChild(item,index, prevIndex)\n\n\tdef removeChild item, index\n\t\t# self.map.delete(item)\n\t\t# what if this is a fragment or virtual node?\n\t\tif item.parentNode\n\t\t\t# log 'removeChild',item,item.parentNode\n\t\t\titem.#removeFrom(item.parentNode)\n\t\treturn\n\n\tdef #insertChild node,relnode\n\t\treturn\n\n\t# def #appendChild\n\t#\treturn\n\n\tdef #replaceWith rel, parent\n\t\tlet res = rel.#insertInto(parent,#end)\n\t\t#removeFrom(parent)\n\t\treturn res\n\n\tdef #insertInto parent, before\n\t\t# log 'insertInto',parent,before\n\t\t##parent = parent\n\t\tlet prev = parentNode\n\t\tif parent != prev\n\t\t\tparentNode = parent\n\t\t\t# #start.#insertInto(parent,before) if #start\n\t\t\tfor item,i in self.array\n\t\t\t\titem.#insertInto(parent,before)\n\n\t\t\tif #end\n\t\t\t\t#end.#insertInto(parent,before)\n\t\t\t# attachNodes!\n\t\tself\n\n\tdef #removeFrom parent\n\t\t# log '#removeFrom!',parent\n\n\t\tfor item in self.array\n\t\t\tparent.#removeChild(item)\n\t\tparent.#removeChild(#end) if #end\n\t\t# parent.#removeChild(#start) if #start\n\t\tparentNode = null\n\n\tdef #afterVisit index\n\t\tunless #domFlags & $TAG_INITED$\n\t\t\t#domFlags |= $TAG_INITED$\n\t\t\t# what if parent was not even set yet?\n\t\t\treturn\n\n\t\tif self.dirty\n\n\t\t\tself.changes.forEach do(pos,item)\n\t\t\t\tif pos == -1\n\t\t\t\t\tself.removeChild(item)\n\t\t\tself.changes.clear()\n\t\t\tself.dirty = no\n\n\t\t# there are some items we should remove now\n\t\tif self.array.length > index\n\n\t\t\t# remove the children below\n\t\t\twhile self.array.length > index\n\t\t\t\tlet item = self.array.pop()\n\t\t\t\tself.removeChild(item)\n\t\treturn\n\nexport def createKeyedList bitflags, parent\n\treturn new KeyedTagFragment(bitflags,parent)\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
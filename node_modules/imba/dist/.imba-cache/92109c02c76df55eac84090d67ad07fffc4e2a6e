{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};\nconst $setup$ = Symbol.for('#setup'), $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $nr$ = Symbol.for('#nr');\nvar $1 = Symbol();\n\n/*body*/\nimport './any';\nimport * as mp from '../msgpack';\n\n// @template [Type=any]\nexport class OPKeyField extends OPField {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $2;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\t($2 = $$.pgtype) !== undefined && (this.pgtype = $2);\n\t\t($2 = $$.readonly) !== undefined && (this.readonly = $2);\n\t\t($2 = $$.size) !== undefined && (this.size = $2);\n\t\t($2 = $$.bit) !== undefined && (this.bit = $2);\n\t\t($2 = $$.virtual) !== undefined && (this.virtual = $2);\n\t\t($2 = $$.system) !== undefined && (this.system = $2);\n\t\t($2 = $$.base32) !== undefined && (this.base32 = $2);\n\t\t($2 = $$.base58) !== undefined && (this.base58 = $2);\n\t\t($2 = $$.rls) !== undefined && (this.rls = $2);\n\t\t($2 = $$.acl) !== undefined && (this.acl = $2);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $3;\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tthis.pgtype = ($$ && ($3 = $$.pgtype) !== undefined) ? ($3) : 'text';\n\t\tthis.readonly = ($$ && ($3 = $$.readonly) !== undefined) ? ($3) : true;\n\t\tthis.size = ($$ && ($3 = $$.size) !== undefined) ? ($3) : 8;\n\t\tthis.bit = ($$ && ($3 = $$.bit) !== undefined) ? ($3) : false;\n\t\tthis.virtual = ($$ && ($3 = $$.virtual) !== undefined) ? ($3) : false;\n\t\tthis.system = ($$ && ($3 = $$.system) !== undefined) ? ($3) : false;\n\t\tthis.base32 = ($$ && ($3 = $$.base32) !== undefined) ? ($3) : false;\n\t\tthis.base58 = ($$ && ($3 = $$.base58) !== undefined) ? ($3) : false;\n\t\tthis.rls = ($$ && ($3 = $$.rls) !== undefined) ? ($3) : false;\n\t\tthis.acl = ($$ && ($3 = $$.acl) !== undefined) ? ($3) : false;\n\t\t\n\t}\n\t\n\t\n\t// the length of non-composite random ids\n\t\n\t\n\t// keys are representing bits\n\t\n\t\n\t// or acl\n\t\n\t\n\t\n\t// structures - allow defining msgpackr structures for id-type?\n\t\n\t// who can create create such an object?\n\tc(roles){\n\t\t\n\t\treturn this.$rule({C: roles});\n\t}\n\t\n\t// Who can delete this object?\n\td(roles){\n\t\t\n\t\treturn this.$rule({D: roles});\n\t}\n\t\n\t/**\n\t\n\t\tThe potential composite fields\n\t\tIe @key(@@user,@@entity) - user and entity\n\t\trefer to other fields on this model - and they\n\t\tare part of the id\n\t\t\n\t*/\n\tget slots(){\n\t\t\n\t\treturn this.args;\n\t}\n\t\n\tget params(){\n\t\t\n\t\treturn this.slots.map(function(slot) {\n\t\t\t\n\t\t\treturn slot.name || slot;\n\t\t});\n\t}\n\t\n\tget signature(){\n\t\tvar $4;\n\t\t\n\t\t\n\t\t$4 = [];\n\t\tfor (let $5 = 0, $6 = iter$__(this.slots), $7 = $6.length; $5 < $7; $5++) {\n\t\t\tlet slot = $6[$5];\n\t\t\t\n\t\t\t// TODO Need to implement this for new fields\n\t\t\t$4.push(slot.valuetype);\n\t\t};\n\t\treturn $4;\n\t}\n\t\n\tget compositeΦ(){\n\t\t\n\t\treturn this.slots.length > 0;\n\t}\n\t\n\t// get number?\n\t// !!bit\n\tget numberΦ(){\n\t\t\n\t\treturn false;\n\t}\n\t\n\tforType(type){\n\t\t\n\t\tif (this.model == type) {\n\t\t\t\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tlet field = type.prototype[this.slot];\n\t\ttype.prototype[this.slot] = null;\n\t\t// shold only w\n\t\tlet out = type.prototype.ααid;\n\t\treturn out;\n\t}\n\t\n\tstructures(...combinations){\n\t\t\n\t\tconsole.log('set structures',combinations);\n\t\treturn this.baked = mp.bakeStructures(combinations);\n\t}\n\t\n\t[$setup$](){\n\t\t\n\t\tif (this.name != 'id') {\n\t\t\t\n\t\t\tthrow (\"OPKeyField only allowed for 'id' not '\" + this.name + \"'\");\n\t\t};\n\t\t\n\t\tif (this.virtual) {\n\t\t\t\n\t\t\tthis.model.virtual = true;\n\t\t};\n\t\t\n\t\treturn this;\n\t}\n\t\n\tencode(data){\n\t\t\n\t\t// what if the data is just a single number - use the numeric annotation?\n\t\tif (typeof data == 'number') {\n\t\t\t\n\t\t\t// will change this later?\n\t\t\treturn (\"\" + (this.model.id) + `0` + data.toString(32));// should use a different base32?\n\t\t};\n\t\t\n\t\treturn (\"\" + (this.model.id) + `2` + mp.stringify(data));\n\t}\n\t\n\tgenerate(target,data){\n\t\t\n\t\tlet prefix = target ? target.constructor.id : this.model.id;\n\t\tlet mask = 0;\n\t\tlet rest;\n\t\t\n\t\tif (this.slots.length) {\n\t\t\t\n\t\t\tlet vals = [];\n\t\t\t\n\t\t\tfor (let i = 0, $8 = iter$__(this.slots), $9 = $8.length; i < $9; i++) {\n\t\t\t\tlet part = $8[i];\n\t\t\t\t\n\t\t\t\t// this is a prefix\n\t\t\t\tif (typeof part == 'string') {\n\t\t\t\t\t\n\t\t\t\t\tvals.push(part);\n\t\t\t\t} else if ((part instanceof OPField)) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlet val = data ? (((data[part.name] ?? data[i]))) : null;\n\t\t\t\t\t\n\t\t\t\t\tif (val != undefined) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tvals.push(String(val));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tvals.push('');\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tprefix += mask;\n\t\t\treturn OPKey.encode(prefix,...vals);\n\t\t} else {\n\t\t\t\n\t\t\trest = (data?.oid || OPKey.random(this.size));\n\t\t};\n\t\t\n\t\tlet id = prefix + mask + rest;\n\t\t\n\t\treturn id;\n\t}\n\t\n\tparse(value,data = {}){\n\t\t\n\t\tlet parts = OPKey.parse(value);\n\t\t\n\t\tfor (let i = 0, $10 = iter$__(this.slots), $11 = $10.length; i < $11; i++) {\n\t\t\tlet arg = $10[i];\n\t\t\tlet val = parts[i + 1];\n\t\t\tif ((arg instanceof OPField)) {\n\t\t\t\t\n\t\t\t\t// Don't remember what this is used for.\n\t\t\t\tlet chr = val.charCodeAt(0);\n\t\t\t\tif (arg.valuetype == Number || 58 > chr && chr > 47) {\n\t\t\t\t\t\n\t\t\t\t\tval = Number(val);\n\t\t\t\t};\n\t\t\t\t// nah\n\t\t\t\targ.load(val,data);\n\t\t\t};\n\t\t};\n\t\treturn data;\n\t}\n\t\n\t// not supposed to be able to set the id directly - ever\n\t$set(value,target,key){\n\t\t\n\t\treturn;\n\t}\n\t\n\t$init(value,target){\n\t\tlet emb;\n\t\t\n\t\tif (value === undefined) {\n\t\t\t\n\t\t\treturn;\n\t\t};\n\t\t\n\t\tif (value !== undefined) {\n\t\t\t\n\t\t\tlet typ = typeof value;\n\t\t\tif (typ == 'number') { // is this used now?\n\t\t\t\t\n\t\t\t\tObject.defineProperty(target,'id',{value: value,enumerable: true});\n\t\t\t\ttarget.sys.type[value] = value;\n\t\t\t\treturn;\n\t\t\t};\n\t\t\t\n\t\t\tObject.defineProperty(target,'id',{value: value,enumerable: true});\n\t\t\t\n\t\t\tif (typ == 'string') {\n\t\t\t\t\n\t\t\t\tif (emb = OPKey.embedded(value)) {\n\t\t\t\t\t\n\t\t\t\t\t// update the sys? Include the name?\n\t\t\t\t\treturn;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tOP.$rich[value] = target;\n\t\t\t\n\t\t\tlet offset = target.constructor.id.length;\n\t\t\tlet kind = value[offset];\n\t\t\tif (kind == '8') {\n\t\t\t\t\n\t\t\t\tlet nr = target[$nr$] = target.$nr = parseInt(value.slice(offset + 1));\n\t\t\t\ttarget.valueOf = target[Symbol.toPrimitive] = function(hint) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// weirdness here?!\n\t\t\t\t\treturn 2 ** this[$nr$];\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\t// Has to be called\n\t\t\t\n\t\t\tif (this.compositeΦ) {\n\t\t\t\t\n\t\t\t\tthis.parse(value,target);\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn;\n\t}\n\t\n\t$get(target,key){\n\t\t\n\t\t\n\t\tif (target.hasOwnProperty('id')) {\n\t\t\t\n\t\t\treturn target.id;\n\t\t};\n\t\t\n\t\tlet value = target[key];\n\t\tif (value === undefined) {\n\t\t\t\n\t\t\tvalue = this.generate(target);\n\t\t\tOP.$rich[value] = target;\n\t\t};\n\t\tObject.defineProperty(target,'id',{value: value,enumerable: true});\n\t\treturn value;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'OPKeyField');inheritClass$__(this);}\n}; globalThis.OPKeyField = OPKeyField;\n\nclass ΩOPObject {\n\t\n\tαkey(...types){\n\t\t\n\t\treturn new OPKeyField(...types);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPObject');}\n};\nextend$__(OPObject.prototype,ΩOPObject.prototype);\n;\n","dependencies":[],"map":{"version":3,"file":"key.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/fields/key.imba"],"sourcesContent":["import './any'\nimport * as mp from '../msgpack'\n\n# @template [Type=any]\nexport global class OPKeyField < OPField\n\tpgtype = 'text'\n\n\treadonly = yes\n\n\t# the length of non-composite random ids\n\tsize = 8\n\n\t# keys are representing bits\n\tbit = no\n\n\tvirtual = no\n\n\tsystem = no\n\n\tbase32 = no\n\tbase58 = no\n\n\trls = no # or acl\n\n\tacl = no\n\n\t# structures - allow defining msgpackr structures for id-type?\n\n\t# who can create create such an object?\n\tdef c roles\n\t\t$rule(C: roles)\n\n\t# Who can delete this object?\n\tdef d roles\n\t\t$rule(D: roles)\n\n\t###\n\tThe potential composite fields\n\tIe @key(@@user,@@entity) - user and entity\n\trefer to other fields on this model - and they\n\tare part of the id\n\t###\n\tget slots\n\t\targs\n\n\tget params\n\t\tslots.map do(slot)\n\t\t\tslot.name or slot\n\n\tget signature\n\n\t\tfor slot in slots\n\t\t\t# TODO Need to implement this for new fields\n\t\t\tslot.valuetype\n\n\tget composite?\n\t\tslots.length > 0\n\n\t# get number?\n\t#\t!!bit\n\tget number?\n\t\tfalse\n\n\tdef forType type\n\t\tif model == type\n\t\t\treturn self\n\n\t\tlet field = type.prototype[slot]\n\t\ttype.prototype[slot] = null\n\t\t# shold only w\n\t\tlet out = type.prototype.@@id\n\t\treturn out\n\n\tdef structures ...combinations\n\t\tconsole.log 'set structures',combinations\n\t\tbaked = mp.bakeStructures(combinations)\n\n\tdef #setup\n\t\tunless name == 'id'\n\t\t\tthrow \"OPKeyField only allowed for 'id' not '{name}'\"\n\n\t\tif virtual\n\t\t\tmodel.virtual = yes\n\n\t\tself\n\n\tdef encode data\n\t\t# what if the data is just a single number - use the numeric annotation?\n\t\tif typeof data == 'number'\n\t\t\t# will change this later?\n\t\t\treturn `{model.id}0{data.toString(32)}` # should use a different base32?\n\n\t\t`{model.id}2{mp.stringify(data)}`\n\n\tdef generate target, data\n\t\tlet prefix = target ? target.constructor.id : model.id\n\t\tlet mask = 0\n\t\tlet rest\n\n\t\tif slots.length\n\t\t\tlet vals = []\n\n\t\t\tfor part,i in slots\n\t\t\t\t# this is a prefix\n\t\t\t\tif typeof part == 'string'\n\t\t\t\t\tvals.push(part)\n\t\t\t\telif (part isa OPField)\n\n\t\t\t\t\tlet val = data ? (data[part.name] ?? data[i]) : null\n\n\t\t\t\t\tif val != undefined\n\t\t\t\t\t\tvals.push String(val)\n\t\t\t\t\telse\n\t\t\t\t\t\tvals.push('')\n\n\t\t\tprefix += mask\n\t\t\treturn OPKey.encode(prefix,...vals)\n\n\t\telse\n\t\t\trest = (data..oid or OPKey.random(size))\n\n\t\tlet id = prefix + mask + rest\n\n\t\treturn id\n\n\tdef parse value, data = {}\n\t\tlet parts = OPKey.parse(value)\n\n\t\tfor arg,i in slots\n\t\t\tlet val = parts[i + 1]\n\t\t\tif (arg isa OPField)\n\t\t\t\t# Don't remember what this is used for.\n\t\t\t\tlet chr = val.charCodeAt(0)\n\t\t\t\tif arg.valuetype == Number or 58 > chr > 47\n\t\t\t\t\tval = Number(val)\n\t\t\t\t# nah\n\t\t\t\targ.load(val,data)\n\t\treturn data\n\n\t# not supposed to be able to set the id directly - ever\n\tdef $set value, target, key\n\t\treturn\n\n\tdef $init value, target\n\t\tif value === undefined\n\t\t\treturn\n\n\t\tif value !== undefined\n\t\t\tlet typ = typeof value\n\t\t\tif typ == 'number' # is this used now?\n\t\t\t\tObject.defineProperty(target,'id',value: value,enumerable: true)\n\t\t\t\ttarget.sys.type[value] = value\n\t\t\t\treturn\n\n\t\t\tObject.defineProperty(target,'id',value: value,enumerable: true)\n\n\t\t\tif typ == 'string'\n\t\t\t\tif let emb = OPKey.embedded(value)\n\t\t\t\t\t# update the sys? Include the name?\n\t\t\t\t\treturn\n\n\t\t\tOP.$rich[value] = target\n\n\t\t\tlet offset = target.constructor.id.length\n\t\t\tlet kind = value[offset]\n\t\t\tif kind == '8'\n\t\t\t\tlet nr = target.#nr = target.$nr = parseInt(value.slice(offset + 1))\n\t\t\t\ttarget.valueOf = target[Symbol.toPrimitive] = do(hint)\n\n\t\t\t\t\t# weirdness here?!\n\t\t\t\t\t2 ** this.#nr\n\n\t\t\t# Has to be called\n\n\t\t\tif composite?\n\t\t\t\tparse(value,target)\n\n\t\treturn\n\n\tdef $get target, key\n\n\t\tif target.hasOwnProperty('id')\n\t\t\treturn target.id\n\n\t\tlet value = target[key]\n\t\tif value === undefined\n\t\t\tvalue = generate(target)\n\t\t\tOP.$rich[value] = target\n\t\tObject.defineProperty(target,'id',value: value,enumerable: true)\n\t\treturn value\n\nextend class OPObject\n\tdef @key ...types\n\t\tnew OPKeyField(...types)\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};\nconst $afterVisit$ = Symbol.for('#afterVisit'), $insertInto$ = Symbol.for('#insertInto'), $appendChild$ = Symbol.for('#appendChild'), $replaceWith$ = Symbol.for('#replaceWith'), $removeFrom$ = Symbol.for('#removeFrom'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $domFlags$ = Symbol.for('#domFlags'), $$parent$ = Symbol.for('##parent'), $end$ = Symbol.for('#end'), $removeChild$ = Symbol.for('#removeChild'), $insertChild$ = Symbol.for('#insertChild');\nvar $1 = Symbol();\n\n/*body*/\nimport {createComment} from './core';\nimport {Fragment} from './fragment';\n\nclass IndexedTagFragment extends Fragment {\n\t\n\t\n\tconstructor(f,parent){\n\t\t\n\t\tsuper(...arguments);\n\t\tthis[$domFlags$] = f;\n\t\tthis[$$parent$] = parent;\n\t\t\n\t\tif (!(f & 256)) {\n\t\t\t\n\t\t\tthis[$end$] = createComment('list');\n\t\t\t// #end.node = self\n\t\t};\n\t\t\n\t\tthis.$ = this.childNodes;\n\t\tthis.length = 0;\n\t\t\n\t\tif (parent) {\n\t\t\t\n\t\t\tparent[$appendChild$](this);\n\t\t};this[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\thasChildNodes(){\n\t\t\n\t\tif (this.length == 0) { return false };\n\t\treturn true;\n\t}\n\t\n\t[$afterVisit$](len){\n\t\t\n\t\tlet from = this.length;\n\t\tthis.length = len;\n\t\t\n\t\tif (from == len) { return };\n\t\tlet par = this.parentNode;\n\t\tif (!(par)) { return };\n\t\t\n\t\tlet array = this.childNodes;\n\t\tlet end = this[$end$];\n\t\t\n\t\tif (from > len) {\n\t\t\t\n\t\t\twhile (from > len){\n\t\t\t\t\n\t\t\t\tpar[$removeChild$](array[--from]);\n\t\t\t};\n\t\t} else if (len > from) {\n\t\t\t\n\t\t\twhile (len > from){\n\t\t\t\t\n\t\t\t\tpar[$insertChild$](array[from++],end);\n\t\t\t};\n\t\t};\n\t\tthis.length = len;\n\t\treturn;\n\t}\n\t\n\t[$insertInto$](parent,before){\n\t\t\n\t\tthis.parentNode = parent;\n\t\t\n\t\t// if parent isa Node\n\t\t// FIXME need to work with non-dom elements as well\n\t\tif (this[$end$]) {\n\t\t\t\n\t\t\tthis[$end$][$insertInto$](parent,before);\n\t\t};\n\t\t\n\t\tbefore = this[$end$];\n\t\t\n\t\tfor (let i = 0, $2 = iter$__(this.childNodes), $3 = $2.length; i < $3; i++) {\n\t\t\tlet item = $2[i];\n\t\t\tif (i == this.length) { break; };\n\t\t\t// log 'insert child',parent,item,before\n\t\t\titem[$insertInto$](parent,before);\n\t\t\t// log 'insert child',parent,item,before,parent.innerHTML\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t[$appendChild$](item){\n\t\t\n\t\t// this should be a noop\n\t\t// log 'list #appendChild',item\n\t\treturn;\n\t}\n\t\n\t[$replaceWith$](rel,parent){\n\t\t\n\t\tlet res = rel[$insertInto$](parent,this[$end$]);\n\t\tthis[$removeFrom$](parent);\n\t\treturn res;\n\t}\n\t\n\t[$removeFrom$](parent){\n\t\t\n\t\t// log '#removeFrom',parent\n\t\tlet i = this.length;\n\t\twhile (i > 0){\n\t\t\t\n\t\t\tlet el = this.childNodes[--i];\n\t\t\tel[$removeFrom$](parent);\n\t\t\t// parent.#removeChild(el)\n\t\t};\n\t\tif (this[$end$]) { parent.removeChild(this[$end$]) };\n\t\tthis.parentNode = null;\n\t\treturn;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'IndexedTagFragment');inheritClass$__(this);}\n};\n\nexport function createIndexedList(bitflags,parent){\n\t\n\treturn new IndexedTagFragment(bitflags,parent);\n};\n","dependencies":[],"map":{"version":3,"file":"indexed-list.js","sourceRoot":"","sources":["/Users/sindre/repos/imba/packages/imba/src/imba/dom/indexed-list.imba"],"sourcesContent":["import {createComment} from './core'\nimport {Fragment} from './fragment'\n\nclass IndexedTagFragment < Fragment\n\n\tdef constructor f, parent\n\t\tsuper\n\t\t#domFlags = f\n\t\t##parent = parent\n\n\t\tunless f & $TAG_LAST_CHILD$\n\t\t\t#end = createComment('list')\n\t\t\t# #end.node = self\n\n\t\tself.$ = childNodes\n\t\tself.length = 0\n\n\t\tif parent\n\t\t\tparent.#appendChild(self)\n\n\tdef hasChildNodes\n\t\treturn false if length == 0\n\t\treturn true\n\n\tdef #afterVisit len\n\t\tlet from = self.length\n\t\tself.length = len\n\n\t\treturn if from == len\n\t\tlet par = parentNode\n\t\treturn if !par\n\n\t\tlet array = self.childNodes\n\t\tlet end = #end\n\n\t\tif from > len\n\t\t\twhile from > len\n\t\t\t\tpar.#removeChild(array[--from])\n\t\telif len > from\n\t\t\twhile len > from\n\t\t\t\tpar.#insertChild(array[from++],end)\n\t\tself.length = len\n\t\treturn\n\n\tdef #insertInto parent, before\n\t\tparentNode = parent\n\n\t\t# if parent isa Node\n\t\t# FIXME need to work with non-dom elements as well\n\t\tif #end\n\t\t\t#end.#insertInto(parent,before)\n\n\t\tbefore = #end\n\n\t\tfor item,i in childNodes\n\t\t\tbreak if i == self.length\n\t\t\t# log 'insert child',parent,item,before\n\t\t\titem.#insertInto(parent,before)\n\t\t\t# log 'insert child',parent,item,before,parent.innerHTML\n\t\treturn self\n\n\tdef #appendChild item\n\t\t# this should be a noop\n\t\t# log 'list #appendChild',item\n\t\treturn\n\n\tdef #replaceWith rel, parent\n\t\tlet res = rel.#insertInto(parent,#end)\n\t\t#removeFrom(parent)\n\t\treturn res\n\n\tdef #removeFrom parent\n\t\t# log '#removeFrom',parent\n\t\tlet i = length\n\t\twhile i > 0\n\t\t\tlet el = childNodes[--i]\n\t\t\tel.#removeFrom(parent)\n\t\t\t# parent.#removeChild(el)\n\t\tparent.removeChild(#end) if #end\n\t\tparentNode = null\n\t\treturn\n\nexport def createIndexedList bitflags, parent\n\treturn new IndexedTagFragment(bitflags,parent)\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,MAAM,EAAE,aAAa,OAAO,QAAQ;AACpC,MAAM,EAAE,QAAQ,OAAO,YAAY;;AAEnC,KAAK,CAAC,kBAAkB,SAAG,QAAQ,EAAA;;;CAE9B,WAAW,CAAC,CAAC,CAAE,MAAM,CAAA;;EACxB,mBAAK;EACL,gBAAS,GAAG,CAAC;EACb,eAAQ,GAAG,MAAM;;EAEjB,EAAM,IAAC,CAAC,CAAC,CAAC,CAAC,GAAgB,GAAA;;GAC1B,WAAI,GAAG,aAAa,CAAC,MAAM,CAAC;;GACV;;EAEnB,IAAI,CAAC,CAAC,GAAG,KAAA,UAAU;EACnB,IAAI,CAAC,MAAM,GAAG,CAAC;;EAEf,EAAE,EAAC,MAAM,EAAA;;GACR,MAAM,eAAa,CAAC,IAAI,CAAC;GAAA;EAAA;;CAEvB,aAAa,EAAA;;EACH,EAAE,EAAC,KAAA,MAAM,CAAC,EAAE,CAAC,CAAC,EAA3B,EAAA,MAAM,CAAC,KAAK;EACZ,MAAM,CAAC,IAAI;EAAA;;gBAEI,GAAG,CAAA;;MACd,IAAI,GAAG,IAAI,CAAC,MAAM;EACtB,IAAI,CAAC,MAAM,GAAG,GAAG;;EAEV,EAAE,EAAC,IAAI,CAAC,EAAE,CAAC,GAAG,EAArB,EAAA,MAAM;MACF,GAAG,GAAG,KAAA,UAAU;EACb,EAAE,EAAC,EAAC,GAAG,CAAA,EAAd,EAAA,MAAM;;MAEF,KAAK,GAAG,IAAI,CAAC,UAAU;MACvB,GAAG,cAAO;;EAEd,EAAE,EAAC,IAAI,CAAC,CAAC,CAAC,GAAG,EAAA;;UACN,IAAI,CAAC,CAAC,CAAC,GAAG,CAAA;;IACf,GAAG,eAAa,CAAC,KAAK,CAAA,EAAG,IAAI,CAAC,CAAC;IAAA;GAAA,MACjC,EAAA,EAAK,GAAG,CAAC,CAAC,CAAC,IAAI,EAAA;;UACR,GAAG,CAAC,CAAC,CAAC,IAAI,CAAA;;IACf,GAAG,eAAa,CAAC,KAAK,CAAA,IAAK,EAAE,CAAC,CAAC,GAAG,CAAC;IAAA;GAAA;EACrC,IAAI,CAAC,MAAM,GAAG,GAAG;EACjB,MAAM;EAAA;;gBAES,MAAM,CAAE,MAAM,CAAA;;EAC7B,KAAA,UAAU,GAAG,MAAM;;;;EAInB,EAAE,aAAK,EAAA;;cACF,cAAY,CAAC,MAAM,CAAC,MAAM,CAAC;GAAA;;EAEhC,MAAM,cAAO;;EAEb,GAAG,0BAAW,KAAA,UAAU,gCAAA;OAApB,IAAI;GACD,EAAE,EAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM;;GAEzB,IAAI,cAAY,CAAC,MAAM,CAAC,MAAM,CAAC;;GACyB;EACzD,MAAM,CAAC,IAAI;EAAA;;iBAEK,IAAI,CAAA;;;;EAGpB,MAAM;EAAA;;iBAEU,GAAG,CAAE,MAAM,CAAA;;MACvB,GAAG,GAAG,GAAG,cAAY,CAAC,MAAM,YAAK,CAAC;oBAC3B,CAAC,MAAM,CAAC;EACnB,MAAM,CAAC,GAAG;EAAA;;gBAEK,MAAM,CAAA;;;MAEjB,CAAC,GAAG,KAAA,MAAM;SACR,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;;OACN,EAAE,GAAG,KAAA,UAAU,CAAA,EAAG,CAAC,CAAC;GACxB,EAAE,cAAY,CAAC,MAAM,CAAC;;GACG;EACD,EAAE,aAAK,EAAhC,EAAA,MAAM,CAAC,WAAW,YAAK,CAAC,EAAA;EACxB,KAAA,UAAU,GAAG,IAAI;EACjB,MAAM;EAAA;;;AAAA,CAAA;;AAER,MAAM,CAAC,QAAG,CAAC,iBAAiB,CAAC,QAAQ,CAAE,MAAM,CAAA;;CAC5C,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CAAC;CAAA;AAC/C;"}},"css":{"code":""},"warnings":[],"errors":[]}
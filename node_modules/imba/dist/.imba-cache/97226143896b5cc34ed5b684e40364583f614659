{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction decorate$__(decorators,target,key,desc){\n\tvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\tif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\telse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\treturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport {αlazy as imba_αlazy, use_hooks as imba_use_hooks, hooks as imba_hooks, emit as imba_emit, listen as imba_listen, once as imba_once, unlisten as imba_unlisten} from 'imba';\n(imba_use_hooks());\nconst $call$ = Symbol.for('#call'), $call__$ = Symbol.for('#call__'), $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__hooks__$ = Symbol.for('#__hooks__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $oid$ = Symbol.for('#oid'), $v$ = Symbol.for('#v'), $sort$ = Symbol.for('#sort');\n\n/*body*/\nimport {MemoMap,compare,nameToTable,getDeepDescriptor,NamedSet,now,promising,random} from '../utils';\nimport {Index} from './iterable';\nimport * as msgpack from '../msgpack';\nimport {STACK} from '../stack';\nimport differ from '../util/differnew.ts';\n\nclass OPObjectRegistry {\nstatic {\n\tdefineName$__(this,'OPObjectRegistry');}}; globalThis.OPObjectRegistry = OPObjectRegistry;\n\nlet WeakCache = {};\n\n/**\n\nInternal decorator for memoized results of things like Model.shape\nwhich are invalidated whenever a new model class has been declared\nby clearing the WeakCache in .inherit\n\nMove into utils?\n\n*/\nfunction αmemo(target,key,desc){\n\tvar get, self = this;\n\t\n\tif (get = desc.get) {\n\t\t\n\t\tdesc.get = function() {\n\t\t\t\n\t\t\tlet map = WeakCache[key] ??= new WeakMap;\n\t\t\tif (map.has(this)) { return map.get(this) };\n\t\t\tlet val = get.call(this);\n\t\t\tmap.set(this,val);\n\t\t\treturn val;\n\t\t};\n\t} else if (desc.value instanceof Function) {\n\t\t\n\t\tlet fn = desc.value;\n\t\tdesc.value = function(_0) {\n\t\t\t\n\t\t\tlet map = WeakCache[key] ??= new WeakMap;\n\t\t\tif (map.has(this)) { let mem = map.get(this) };\n\t\t\tself.mem || map.set(this,self.mem = new Map);\n\t\t\tif (map.has(_0)) { let res = self.mem.get(_0) };\n\t\t\t(self.res ?? map.set(_0,self.res = fn.apply(this,arguments)));\n\t\t\treturn self.res;\n\t\t};\n\t};\n\t\n\treturn desc;\n};\n\nlet InitialSetup = false;\nlet EMBED = null;\n\n// Base object that can have fields and all that\nclass OPObject {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $1;\n\t\t($1 = $$.$flags) !== undefined && (this.$flags = $1);\n\t\t\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $2;\n\t\tthis.$flags = ($$ && ($2 = $$.$flags) !== undefined) ? ($2) : 0;\n\t\t\n\t}\n\tstatic toString(){\n\t\t\n\t\treturn this.id;\n\t}\n\t\n\tstatic get povΦ(){\n\t\t\n\t\treturn false;\n\t}\n\t\n\tstatic get virtualΦ(){\n\t\t\n\t\treturn this.key.virtual;\n\t}\n\t\n\t/**\n\t\n\t\tReturns the id field for model\n\t\t\n\t@returns { OPKeyField }\n\t*/\n\tstatic get key(){\n\t\t\n\t\treturn this.prototype.ααid.forType(this);\n\t}\n\t\n\tstatic async find(query){\n\t\t\n\t\tif (false) {};\n\t\t\n\t\treturn await OP.findΞone(this,query);\n\t}\n\t\n\tstatic async filter(query){\n\t\t\n\t\tif (false) {};\n\t\t\n\t\treturn await OP.findΞmany(this,query);\n\t}\n\t\n\tstatic fetchΞall(){\n\t\t\n\t\treturn OP.preload`select * from ${this}`;\n\t}\n\t\n\tstatic inherited(subclass){\n\t\t\n\t\tWeakCache = {};\n\t\t// Run setup on OPObject the first time we subclass it.\n\t\tif (this == OPObject && !(InitialSetup)) {\n\t\t\t\n\t\t\tInitialSetup = true;\n\t\t\tthis.types = new NamedSet;\n\t\t\tthis.setup(null);\n\t\t};\n\t\t\n\t\tsubclass.setup(this);\n\t\treturn subclass;\n\t}\n\t\n\t/**\n\t\n\t\tMethods we need to rename to get correct typings\n\t\t\n\t*/\n\tstatic toIterable(){\n\t\t\n\t\treturn OP.all(this);\n\t}\n\t\n\tstatic get size(){\n\t\t\n\t\treturn this.toIterable().size;\n\t}\n\t\n\tstatic all__(refinements){\n\t\t\n\t\t// TODO maybe just use OP.all?\n\t\treturn refinements ? OP.all(this).select(refinements) : OP.all(this);\n\t}\n\t\n\tstatic embed(target,field,data = {}){\n\t\t\n\t\t// let name = String(field)\n\t\t// let id = OPKey.embed(target.id,name)\n\t\t// let data = target.$plain[field] ||= defaults\n\t\t// Should we just disable support for defaults?\n\t\t// How would we mark this as resolved etc?\n\t\t// let data = Object.assign({},defaults,{ref: name, parent: target, id: id,$up: target, $key: name})\n\t\t// TODO Include EMBEDDED flag in _ ?\n\t\t// Should we always set the value on plain immediately?\n\t\t// data ||= Object.assign({},defaults,{id: id})\n\t\tEMBED = [data,target,field];\n\t\treturn this.construct(data);\n\t}\n\t\n\t// Why the difference between data and patch-data?\n\tstatic construct(data,store,id){\n\t\tvar self = this;\n\t\t\n\t\tlet type = this;\n\t\tlet idkey = this.key;\n\t\t\n\t\tif (this.polymorphic) {\n\t\t\t\n\t\t\tconsole.warn('polymorphic not supported?');\n\t\t\tlet parsed = OPKey.decode(data.id,OPObjectRegistry);\n\t\t\tlet args = parsed.id.slice(1).map(function(_0) { return self.root.get(_0,store); });\n\t\t\t\n\t\t\tfor (let si = 0, $3 = iter$__(this.signatures), $4 = $3.length; si < $4; si++) {\n\t\t\t\tlet [polytype,sign] = $3[si];\n\t\t\t\t\n\t\t\t\t// hardcode max length for signatures?\n\t\t\t\tif (!((args[0] instanceof sign[0]))) { continue; };\n\t\t\t\tif (args[1] && !((args[1] instanceof sign[1]))) { continue; };\n\t\t\t\ttype = polytype;break;\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (!(type.hasOwnProperty('finalized'))) {\n\t\t\t\n\t\t\ttype.finalize();\n\t\t};\n\t\t\n\t\tif (this.prototype[$call$] instanceof Function) {\n\t\t\t\n\t\t\tlet fn;\n\t\t\tfn = function(...args) { return fn[$call$](this,args); };\n\t\t\tObject.setPrototypeOf(fn,type.prototype);\n\t\t\tlet nameprop = getDeepDescriptor(type.prototype,'name') || {value: this.name,writable: true};\n\t\t\tif (nameprop) { Object.defineProperty(fn,'name',nameprop) };\n\t\t\t\n\t\t\tfn.__init__(data);\n\t\t\tfn[$__init__$](data,true,false);// do we want to allow setting these base items?\n\t\t\tfn.__wake__(data);\n\t\t\t\n\t\t\t// wake already or not?\n\t\t\treturn fn;\n\t\t} else {\n\t\t\t\n\t\t\treturn new type(data);\n\t\t};\n\t}\n\t\n\t// Called for type after it has been setup\n\tstatic finalize(){\n\t\t\n\t\tif (!((this.finalized != true) ? ((this.finalized = true,true)) : false)) { return };\n\t\t\n\t\tlet key = this.key;\n\t\t\n\t\tif (key.bit) {\n\t\t\t\n\t\t\treturn this.prototype[Symbol.toPrimitive] = function(hint) {\n\t\t\t\t\n\t\t\t\treturn this._bit ??= parseInt(this.oid,32);\n\t\t\t};\n\t\t};\n\t}\n\t\n\tstatic setup(base){\n\t\tvar $5;\n\t\t\n\t\t\n\t\tlet name = this.name;\n\t\t\n\t\tlet mapping = OPObjectRegistry;\n\t\tlet ns = this.namespace;\n\t\tlet sysname = (name.match(/^OP([A-Z]\\w+)$/) || [])[1];\n\t\t\n\t\tthis.$name = sysname || name;\n\t\t\n\t\tif (this.prototype[Symbol.match]) {\n\t\t\t\n\t\t\tthis.prototype[$call$] ||= this.prototype[$call__$];\n\t\t};\n\t\t\n\t\tthis.root = OPObject;\n\t\tthis.parent = base;\n\t\tthis.enums = Object.create(base?.enums || {});\n\t\tthis.meta = Object.create(base?.meta || {});\n\t\t\n\t\tif (!(base)) { return };\n\t\t\n\t\tthis.Pov = (class Pov extends (this.parent.Pov || OPPov) {\n\t\tstatic {\n\t\t\tdefineName$__(this,'Pov');inheritClass$__(this);}});\n\t\tthis.Pov.$for = this;\n\t\tthis.table = base.table || this;\n\t\t\n\t\tif (((($5 = this.abstract),delete this.abstract, $5))) {\n\t\t\t\n\t\t\tthis.table = null;\n\t\t};\n\t\t\n\t\tif (this.alias == base.alias) {\n\t\t\t\n\t\t\tthis.alias = null;\n\t\t};\n\t\t\n\t\tif (!(this.virtual) && !(ns)) {\n\t\t\t\n\t\t\tlet orig = OPAdapter.prototype[name];\n\t\t\tOPAdapter.prototype[name] = this;\n\t\t\t\n\t\t\tif (sysname) {\n\t\t\t\t\n\t\t\t\tOPAdapter.prototype[sysname] = this;\n\t\t\t};\n\t\t};\n\t\t\n\t\tthis.pgname = nameToTable(name);\n\t\t\n\t\tif (name == base.$name) {\n\t\t\t\n\t\t\tif (base.implementation) {\n\t\t\t\t\n\t\t\t\tthrow (\"\" + name + ` model cannot be extended more than once`);\n\t\t\t};\n\t\t\t\n\t\t\t// only allow for system tables?\n\t\t\tbase.implementation = this;\n\t\t\tbase.abstract = true;\n\t\t\tthis.alias ??= base.alias;\n\t\t\t\n\t\t\tif (base.table == base) {\n\t\t\t\t\n\t\t\t\tbase.table = null;\n\t\t\t\tthis.table = this;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tconsole.log('doesnt have base table?!');\n\t\t\t};\n\t\t\t\n\t\t\t// override all mapping\n\t\t\tfor (let $6 = 0, $7 = Object.keys(mapping), $8 = $7.length, k, v; $6 < $8; $6++){\n\t\t\t\tk = $7[$6];v = mapping[k];\n\t\t\t\tif (v == base) {\n\t\t\t\t\t\n\t\t\t\t\tmapping[k] = this;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (this.alias) {\n\t\t\t\t\n\t\t\t\tmapping[this.alias] = this;\n\t\t\t};\n\t\t} else if (base.polymorphic) {\n\t\t\t\n\t\t\t// p 'subclass of polymorphic',name,base.id\n\t\t\tthis.alias = base.id;\n\t\t} else if (!(ns)) {\n\t\t\t\n\t\t\tmapping[name] = mapping[name.toLowerCase()] = this;\n\t\t\tif (sysname) {\n\t\t\t\t\n\t\t\t\tmapping[sysname] = mapping[sysname.toLowerCase()] = this;\n\t\t\t};\n\t\t\t\n\t\t\tif (this.alias) {\n\t\t\t\t\n\t\t\t\tmapping[this.alias] = this;\n\t\t\t};\n\t\t};\n\t\t\n\t\tthis.id = this.alias || name.toLowerCase();\n\t\t\n\t\tthis.types = new NamedSet;\n\t\tthis.types[this.id] = this.types[name] = this.types.add(this);\n\t\tthis.ref = name.toLowerCase();\n\t\t// TODO id should not be the shorthand - but rather lowercased versio\n\t\t\n\t\t// Make the id field a plain property\n\t\tObject.defineProperty(this.prototype,'id',{\n\t\t\tvalue: null,\n\t\t\tenumerable: true,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t\t\n\t\t// Make these actions\n\t\t// FIXME Not needed anymore?\n\t\t// self.create = Action.wrap(Mixin.create.value.bind(self),{oid: 'create', type: self})\n\t\t// self.build = Action.wrap(Mixin.build.value.bind(self),{oid: 'build', type: self})\n\t\t\n\t\tlet par = this.parent;\n\t\twhile (par && par.types){\n\t\t\t\n\t\t\tpar.types.add(this);\n\t\t\tif (this.alias) {\n\t\t\t\t\n\t\t\t\tpar.types[this.alias] ||= this;\n\t\t\t};\n\t\t\tpar = par.parent;\n\t\t};\n\t\treturn this;\n\t}\n\t\n\tstatic get $shape(){\n\t\tvar $12;\n\t\t\n\t\tlet all = {};\n\t\tlet curr = this;\n\t\t\n\t\twhile (curr){\n\t\t\t\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(curr.prototype);\n\t\t\tfor (let $9 = 0, $10 = Object.keys(proto), $11 = $10.length, name, val; $9 < $11; $9++){\n\t\t\t\tname = $10[$9];val = proto[name];if (name.indexOf('αα') != 0) { continue; };\n\t\t\t\tall[name.slice(2)] ||= curr;\n\t\t\t};\n\t\t\tcurr = curr.parent;\n\t\t};\n\t\t\n\t\t$12 = [];\n\t\tfor (let $13 = 0, $14 = Object.keys(all), $15 = $14.length, k, v; $13 < $15; $13++){\n\t\t\tk = $14[$13];v = all[k];\n\t\t\t$12.push(v.prototype[(`αα` + k)]);\n\t\t};\n\t\tlet fields = $12;\n\t\t\n\t\treturn new OPShape(this,fields);\n\t}\n\t\n\tstatic get $fields(){\n\t\t\n\t\treturn this.$shape.$shared;\n\t}\n\t\n\tstatic get deepShape(){\n\t\tvar $22;\n\t\t\n\t\tlet all = {};\n\t\tlet curr = this.parent;\n\t\t\n\t\twhile (curr){\n\t\t\t\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(curr.prototype);\n\t\t\tfor (let $16 = 0, $17 = Object.keys(proto), $18 = $17.length, name, val; $16 < $18; $16++){\n\t\t\t\tname = $17[$16];val = proto[name];if (name.indexOf('αα') != 0) { continue; };\n\t\t\t\tall[name.slice(2)] = curr;\n\t\t\t};\n\t\t\tcurr = curr.parent;\n\t\t};\n\t\t\n\t\tfor (let type of iter$__(this.types)){\n\t\t\t\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(type.prototype);\n\t\t\tfor (let $19 = 0, $20 = Object.keys(proto), $21 = $20.length, name, val; $19 < $21; $19++){\n\t\t\t\tname = $20[$19];val = proto[name];if (name.indexOf('αα') != 0) { continue; };\n\t\t\t\tall[name.slice(2)] = type;\n\t\t\t};\n\t\t};\n\t\t\n\t\t$22 = [];\n\t\tfor (let $23 = 0, $24 = Object.keys(all), $25 = $24.length, k, v; $23 < $25; $23++){\n\t\t\tk = $24[$23];v = all[k];\n\t\t\t$22.push(v.prototype[(`αα` + k)]);\n\t\t};\n\t\tlet fields = $22;\n\t\t\n\t\treturn (new OPShape(this,fields));\n\t}\n\t\n\t// all the potential columns of a model\n\tstatic get columns(){\n\t\tvar $32;\n\t\t\n\t\tlet all = {};\n\t\tlet curr = this.parent;\n\t\t\n\t\twhile (curr){\n\t\t\t\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(curr.prototype);\n\t\t\tfor (let $26 = 0, $27 = Object.keys(proto), $28 = $27.length, name, val; $26 < $28; $26++){\n\t\t\t\tname = $27[$26];val = proto[name];if (name.indexOf('αα') != 0) { continue; };\n\t\t\t\tall[name.slice(2)] = curr;\n\t\t\t};\n\t\t\tcurr = curr.parent;\n\t\t};\n\t\t\n\t\tfor (let type of iter$__(this.types)){\n\t\t\t\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(type.prototype);\n\t\t\tfor (let $29 = 0, $30 = Object.keys(proto), $31 = $30.length, name, val; $29 < $31; $29++){\n\t\t\t\tname = $30[$29];val = proto[name];if (name.indexOf('αα') != 0) { continue; };\n\t\t\t\tall[name.slice(2)] = type;\n\t\t\t};\n\t\t};\n\t\t\n\t\t$32 = [];\n\t\tfor (let $33 = 0, $34 = Object.keys(all), $35 = $34.length, k, v; $33 < $35; $33++){\n\t\t\tk = $34[$33];v = all[k];\n\t\t\t$32.push(v.prototype[(`αα` + k)]);\n\t\t};\n\t\tlet fields = $32;\n\t\t\n\t\treturn (new OPShape(this,fields)).$columns;\n\t}\n\t\n\tstatic get signatures(){\n\t\t\n\t\tlet all = [];\n\t\tfor (let typ of iter$__(this.types)){\n\t\t\t\n\t\t\tlet key = typ.key.forType(typ);\n\t\t\tall.unshift([typ,key.signature]);\n\t\t};\n\t\treturn all;\n\t}\n\t\n\t/**\n\t@param {(string | {id: any})} data\n\t*/\n\tstatic getType(data){\n\t\t\n\t\tif (data instanceof this) {\n\t\t\t\n\t\t\treturn data.constructor;\n\t\t};\n\t\tif (typeof data == 'string' && data.indexOf('.') == -1) {\n\t\t\t\n\t\t\tlet pre = (data.match(/^[a-zA-Z]+(?=\\d)/) || [])[0];\n\t\t\tlet typ = OPObjectRegistry[pre];\n\t\t\treturn typ;\n\t\t};\n\t\t\n\t\tlet parsed = OPKey.decode(data.id || data);\n\t\tlet type = OPObjectRegistry[parsed.type];\n\t\t\n\t\tif (parsed.path) {\n\t\t\t\n\t\t\tlet f = type.$shape[parsed.path[0]];\n\t\t\tif (!(f)) {\n\t\t\t\t\n\t\t\t\treturn type.Pov;\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn type;\n\t}\n\t\n\t// part can be id or object with id\n\t// strictly does not need to live here?\n\tstatic groupByType(...parts){\n\t\t\n\t\t// only belongs to this here?\n\t\tlet groups = new MemoMap(function() { return []; });\n\t\t\n\t\tfor (let $36 = 0, $37 = iter$__(parts), $38 = $37.length; $36 < $38; $36++) {\n\t\t\tlet item = $37[$36];\n\t\t\tlet type = this.getType(item);\n\t\t\tif (type) {\n\t\t\t\t\n\t\t\t\tgroups.get(type).push(item);\n\t\t\t};\n\t\t};\n\t\treturn groups;\n\t}\n\t\n\tstatic [Symbol.match](item){\n\t\t\n\t\treturn item instanceof this;\n\t}\n\t\n\t// Santize plain object version of a type\n\t// eventually with options etc\n\tstatic sanitize(data){\n\t\tvar $41;\n\t\t\n\t\t// should not work destructively?\n\t\tfor (let $39 = 0, $40 = Object.keys(data), $42 = $40.length, k, v; $39 < $42; $39++){\n\t\t\tk = $40[$39];v = data[k];\n\t\t\tif (v == null) { ((($41 = data[k]),delete data[k], $41)) };\n\t\t};\n\t\treturn data;\n\t}\n\t\n\t// Default fields for all models\n\t\n\t\n\tget $ns(){\n\t\t\n\t\treturn OP;\n\t}\n\t\n\tthenable(ok,err){\n\t\t\n\t\treturn Promise.resolve(this.$resolve()).then(ok,err);\n\t}\n\t\n\tconstructor(params){\n\t\t\n\t\tthis.__init__(params);\n\t\tthis[$__init__$](params,true,false);\n\t\tthis.__wake__(params);\n\t\t\n\t\t// if we are fresh - go through fields with defaults and generate values\n\t\t// awaken any field that will set up listeners / indices etc\n\t\t// other props don't need to do anything\n\t\t!this[$__initor__$] && this[$__hooks__$].inited(this);\n\t}\n\t\n\t__init__(params){\n\t\tvar self = this;\n\t\t\n\t\t// if we are just building an item - does it make sense to not generate an id immediately?\n\t\t// This should be a setter that defines a property by default\n\t\tif (params.id) {\n\t\t\t\n\t\t\tthis.id = params.id;\n\t\t};\n\t\t\n\t\tObject.defineProperty(this,'$memo',{\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tvalue: {}\n\t\t});\n\t\t\n\t\tif (EMBED && EMBED[0] == params) {\n\t\t\t\n\t\t\tlet [pars,up,key] = EMBED;\n\t\t\tEMBED = null;\n\t\t\tthis.$embed(up,key,pars);\n\t\t} else if (params.$up) { // slow?\n\t\t\t\n\t\t\t\n\t\t\tthis.$up = params.$up;\n\t\t\tthis.$key = params.$key;\n\t\t} else {\n\t\t\t\n\t\t\tthis.$plain = params;\n\t\t\t\n\t\t\tif (this.id) {\n\t\t\t\t\n\t\t\t\t// Why not just use OP.map?\n\t\t\t\t// @ts-ignore\n\t\t\t\tOP.$rich[this.id] = this;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tObject.defineProperty(this,'id',{\n\t\t\t\t\tget: function() { return self.generatedId(); },\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t// Object.defineProperty(self,'sys',value: new State(self,params))\n\t\t};\n\t\t\n\t\treturn this;\n\t}\n\t\n\t__wake__(params){\n\t\t\n\t\tlet s = this.$fields;\n\t\tlet d = this.$plain;\n\t\tlet r = this.rev;\n\t\t\n\t\tif (4 > r && r > -1) { // this was created locally\n\t\t\t\n\t\t\tfor (let $43 = 0, $44 = Object.keys(d), $45 = $44.length, k, v, f; $43 < $45; $43++){\n\t\t\t\tk = $44[$43];v = d[k];\n\t\t\t\tif (f = s[k]) {\n\t\t\t\t\t\n\t\t\t\t\tif (f.$sanitize) {\n\t\t\t\t\t\t\n\t\t\t\t\t\td[k] = f.$sanitize(v,this);\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tif (f.embeddedΦ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// wake the field\n\t\t\t\t\t\tthis[k];\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// would this not be nested for items?\n\t\t\t\t\t// if f.embedded?\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\t// all fields that have defaults should be prepopulated\n\t\t\tfor (let f of iter$__(s.$default)){\n\t\t\t\t\n\t\t\t\tlet v0 = d[f.name];\n\t\t\t\tif (v0 !== undefined) { continue; };\n\t\t\t\tlet v = f.default.call(this);\n\t\t\t\tif (v != undefined && f.$sanitize) { v = f.$sanitize(v,this) };\n\t\t\t\t// has to be a dumb value?\n\t\t\t\tif (v != undefined) { d[f.name] = v };\n\t\t\t};\n\t\t\t\n\t\t\t// ensure that the underlying data is plain\n\t\t};\n\t\t\n\t\t// if typeof r == 'number'\n\t\t\n\t\tlet complex = s.$complex;\n\t\tif (complex.anyΦ) {\n\t\t\t\n\t\t\tfor (let f of iter$__(complex)){\n\t\t\t\t\n\t\t\t\tlet v = d[f.name];\n\t\t\t\t// what if it is on pov though?\n\t\t\t\tf.$wake(this,v);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (r > 0) { this.$sync() };\n\t\treturn this;\n\t}\n\t\n\t// Rename and move\n\tgeneratedId(){\n\t\t\n\t\tlet id = this.ααid.generate(this);\n\t\tObject.defineProperty(this,'id',{value: id,writable: true});\n\t\tthis.$plain.id = id;\n\t\tOP.$rich[id] = this;\n\t\treturn id;\n\t}\n\t\n\ttoString(){\n\t\t\n\t\treturn this.id;\n\t}\n\t\n\t[Symbol.toPrimitive](hint){\n\t\t\n\t\treturn this.id;\n\t}\n\t\n\tget rev(){\n\t\t\n\t\treturn this.$plain._rev;\n\t}\n\t\n\tget oid(){\n\t\t\n\t\treturn this[$oid$] || this.id.split(/(^[A-Za-z]+\\d|_)/)[2];\n\t}\n\t\n\tset oid(value){\n\t\t\n\t\tthis[$oid$] = value;\n\t}\n\t\n\tlog(...params){\n\t\t\n\t\treturn console.log(this.id.blue,...params);\n\t}\n\t\n\tget $type(){\n\t\t\n\t\treturn this.constructor;\n\t}\n\t\n\tsubΞadded(sub){\n\t\tvar $46, $47;\n\t\t\n\t\tif (((this.$flags & ($46 = OPFLAGS.REFCOUNTED))==0) ? ((this.$flags |= $46,true)) : false) {\n\t\t\t\n\t\t\tthis.$subs = new Set;\n\t\t};\n\t\tthis.$subs.add(sub);\n\t\tif ((this.$flags & ($47 = OPFLAGS.DEREFERENCED)) ? ((this.$flags &= ~$47,true)) : false) {\n\t\t\t\n\t\t\tthis.$sync();\n\t\t};\n\t\treturn this;\n\t}\n\t\n\tsubΞremoved(sub){\n\t\t\n\t\tthis.$subs.delete(sub);\n\t\tif (this.$subs.size == 0) {\n\t\t\t\n\t\t\tthis.$flags |= OPFLAGS.DEREFERENCED;\n\t\t\tthis.$sync();\n\t\t};\n\t\treturn this;\n\t}\n\t\n\taddΞlink(coll,name,rich){\n\t\t\n\t\tif (coll == undefined) {\n\t\t\t\n\t\t\tthis.p('link',coll,name,rich,this);\n\t\t\tthrow \"cannot link\";\n\t\t};\n\t\tthis.$links.add(coll);\n\t\tif (this.registeredΦ) {\n\t\t\t\n\t\t\treturn coll.add(this);\n\t\t};\n\t}\n\t\n\tremoveΞlink(coll){\n\t\t\n\t\tif (this.registeredΦ) {\n\t\t\t\n\t\t\tcoll.delete(this);\n\t\t};\n\t\treturn this.$links.delete(coll);\n\t}\n\t\n\t$sync(){\n\t\tvar $48, $49;\n\t\t\n\t\tlet prev = this.$flags;\n\t\tlet curr = prev;\n\t\tlet up = this.$up;\n\t\t\n\t\tlet dereg = this.deletedΦ || prev & OPFLAGS.DEREFERENCED;\n\t\t\n\t\tif (dereg && (curr & ($48 = OPFLAGS.REGISTERED)) ? ((curr &= ~$48,true)) : false) {\n\t\t\t\n\t\t\tup ? (up?.$deregister?.(this)) : OP.deregister(this);\n\t\t\t// type.$deregister(target,store)\n\t\t\tfor (let coll of iter$__(this.$links)){\n\t\t\t\t\n\t\t\t\tcoll.delete(this);\n\t\t\t};\n\t\t} else if (this.existsΦ && ((curr & ($49 = OPFLAGS.REGISTERED))==0) ? ((curr |= $49,true)) : false) {\n\t\t\t\n\t\t\tup ? (up?.$register?.(this)) : OP.register(this);\n\t\t\t\n\t\t\tfor (let coll of iter$__(this.$links)){\n\t\t\t\t\n\t\t\t\tcoll.add(this);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (this.persistedΦ && (prev & OPFLAGS.PERSISTED)==0) {\n\t\t\t\n\t\t\tcurr |= OPFLAGS.PERSISTED;\n\t\t\t\n\t\t\t// save povs and other related things?\n\t\t\t// only if we go from local to persisted?\n\t\t};\n\t\t\n\t\tif (prev != curr) {\n\t\t\t\n\t\t\tthis.$flags = curr;\n\t\t};\n\t\t\n\t\treturn this;\n\t\t// (deleted? or $flags & FLAGS.DEREFERENCED) ? deregister! : (exists? and register!)\n\t}\n\t\n\t// For now used to persist mutations instead of current save\n\t// Will end up just using save after refactor is done\n\t/**\n\t@returns { this }\n\t*/\n\tpersist(){\n\t\t\n\t\treturn this.$persist();\n\t\t// persisted? ? self : save!\n\t}\n\t\n\t$persist(){\n\t\t\n\t\treturn this.$save();\n\t}\n\t\n\t// wraps underlying save\n\tsave(o = {}){\n\t\t\n\t\treturn this.$save(o);\n\t}\n\t\n\t/**\n\t@returns { Promise<this> }\n\t*/\n\tasync $save(o = {}){\n\t\tvar self = this;\n\t\t\n\t\t// TODO if already saving but we have additional changes\n\t\t// wrap the previous saving promise\n\t\t\n\t\tif (this.virtualΦ) {\n\t\t\t\n\t\t\t// Should rather return?\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tlet promise;\n\t\tlet current = this.$saving;\n\t\t\n\t\tif (current) {\n\t\t\t\n\t\t\t// fast exist if nothing to save?\n\t\t\tawait (async ()=>{ try { return await this.$saving } catch(e) { return e; } })();\n\t\t\t// $saving = null\n\t\t};\n\t\t\n\t\t// TODO add force = no argument?\n\t\tthis.$saving ||= (promise = new Promise(async function(resolve,reject) {\n\t\t\tlet pov;\n\t\t\t\n\t\t\tlet res = true;\n\t\t\tlet err;\n\t\t\t\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tif (self.embedΦ) {\n\t\t\t\t\t\n\t\t\t\t\tif (!(self.$up.persistedΦ)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tconsole.warn(\"cannot save embedded object when owner is not saved\");\n\t\t\t\t\t\treturn res = false;\n\t\t\t\t\t\t// return resolve(false)\n\t\t\t\t\t};\n\t\t\t\t\treturn await self.$root.$save({only: [self.$pathary]});\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tlet v = self.$plain[$v$];\n\t\t\t\tlet patchres;\n\t\t\t\t\n\t\t\t\tif (!(self.persistedΦ)) {\n\t\t\t\t\t\n\t\t\t\t\t// Respect o.only etc?\n\t\t\t\t\tself.$saved = globalThis.structuredClone(self.$plain);\n\t\t\t\t\tself.$plain[$v$] = 0;\n\t\t\t\t\tlet res = await (false ? true : OP.db.insert(self.id,self.$plain));\n\t\t\t\t\t// $saving = null if $saving == promise\n\t\t\t\t\tself.$patch(res);\n\t\t\t\t\treturn self;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\t// if $initial\n\t\t\t\tif (self.$cloud != self.$plain) {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlet full = self.$diff();\n\t\t\t\t\t\n\t\t\t\t\tlet delta = o.only ? self.$diff(o) : full;\n\t\t\t\t\tself.$saved = globalThis.structuredClone(self.$plain);\n\t\t\t\t\t\n\t\t\t\t\t// unsaved should immediately be false?\n\t\t\t\t\t// send all the diffs from the client, or send the resulting updates?\n\t\t\t\t\t// diffs are cleaner I guess\n\t\t\t\t\t\n\t\t\t\t\t// FIXME create failing test for this with the only thing\n\t\t\t\t\tif (!(full) || full.length == 0) { self.$plain[$v$] = 0 };\n\t\t\t\t\t// FIX ensure that this method is always async\n\t\t\t\t\t// works differently in browser?\n\t\t\t\t\tawait new Promise(function(_0) { return _0(); });\n\t\t\t\t\tif (!(delta) || delta.length == 0) { return self };\n\t\t\t\t\t\n\t\t\t\t\t// or rather\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tlet upd = {};\n\t\t\t\t\tfor (let $50 = 0, $51 = iter$__(delta), $52 = $51.length; $50 < $52; $50++) {\n\t\t\t\t\t\tlet d = $51[$50];\n\t\t\t\t\t\tlet path = d.path.map(function(_0,_1) { return _1 ? ((`[` + _0 + `]`)) : (_0); }).join('');\n\t\t\t\t\t\tupd[path] = d.value;\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tpatchres = await OP.db.update(self.id,upd);\n\t\t\t\t\t// Should the res indicate that it is from the server?\n\t\t\t\t\tself.$patch(patchres);\n\t\t\t\t\t;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\treturn self;\n\t\t\t} catch (error) {\n\t\t\t\t\n\t\t\t\t// TODO handle errors\n\t\t\t\terror.object = self;\n\t\t\t\tself.$error = error;\n\t\t\t\treturn err = error;\n\t\t\t} finally {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif (pov = (!((self instanceof OPPov)) && !(o.only) && self[OP.agent])) {\n\t\t\t\t\t\n\t\t\t\t\t// not if we save only specific items\n\t\t\t\t\tawait pov.$save();\n\t\t\t\t};\n\t\t\t\t// resolve(yes)\n\t\t\t\tif (self.$saving == promise) { self.$saving = null };\n\t\t\t\terr ? reject(err) : resolve(res);\n\t\t\t\t// resolve(res)\n\t\t\t};\n\t\t}));\n\t\tthis.$saving.options = o;\n\t\treturn this.$saving;\n\t}\n\t\n\tget saved(){\n\t\t\n\t\treturn this;\n\t\t// $saved ? $saved.then(do self) : self\n\t}\n\t\n\tdestroy(){\n\t\t\n\t\treturn this.$destroy();\n\t}\n\t\n\t// Or archive?\n\t$destroy(){\n\t\t\n\t\tthis._del = OP.now;\n\t\treturn this;\n\t}\n\t\n\treset(...args){\n\t\t\n\t\treturn this.$reset(...args);\n\t}\n\t\n\t// clear existing commits / changes\n\t$reset(){\n\t\t\n\t\tif (!(this.unsavedΦ)) { return this };\n\t\tlet diffs = differ(this.$plain,this.$cloud);\n\t\tthis.$applyΞdiffs(diffs,0);\n\t\t// now mark as saved?\n\t\tthis.$plain;\n\t\treturn this;\n\t}\n\t\n\t$pov(key){\n\t\t\n\t\tif (!(key)) { return };\n\t\t// TODO should not store directly here?\n\t\tlet val = this[key];\n\t\tif (!(val)) {\n\t\t\t\n\t\t\tval = new this.$type.Pov(this,key);\n\t\t\tObject.defineProperty(this,String(key),{value: val,enumerable: false});\n\t\t\tthis.$povs[key] = val;\n\t\t};\n\t\treturn val;\n\t}\n\t\n\t/**\n\t@returns { OPPov }\n\t*/\n\tget pov(){\n\t\t\n\t\treturn this.$pov(OP.agent);\n\t}\n\t\n\tset(params = {}){\n\t\t\n\t\t// TODO fixme\n\t\t// compare with existing params\n\t\t// if the object is said to be missing - do we turn it into another state?\n\t\t// do it with a shared mutation\n\t\tfor (let $53 = 0, $54 = Object.keys(params), $55 = $54.length, k, v; $53 < $55; $53++){\n\t\t\tk = $54[$53];v = params[k];\n\t\t\t// why not just self[k] = v ?\n\t\t\tthis.$fields[k].$set(v,this);\n\t\t};\n\t\t\n\t\treturn this;\n\t}\n\t\n\tupdate(params){\n\t\t\n\t\treturn this.$update(params);\n\t}\n\t\n\t/**\n\t@returns { this }\n\t*/\n\tasync $update(params){\n\t\t\n\t\t\n\t\t// resolve with parents and all?\n\t\tif (!(this.resolvedΦ)) { await this.resolve() };\n\t\t\n\t\t// Very shallow check to see if we can write to each field\n\t\t// We should also check if the values are valid, and _valid_\n\t\t// for the user who is saving.\n\t\tlet pre = OP.clone(this.$plain);\n\t\tlet o = {only: []};\n\t\tfor (let $56 = 0, $57 = Object.keys(params), $58 = $57.length, k, v; $56 < $58; $56++){\n\t\t\tk = $57[$56];v = params[k];\n\t\t\tif (OP.agent && (OP.rights(this,k) & 2)==0) {\n\t\t\t\t\n\t\t\t\tthrow new OPNotAllowed((\"Cannot edit \" + k));\n\t\t\t};\n\t\t\to.only.push([String(k)]);\n\t\t\tthis[k] = v;\n\t\t};\n\t\t\n\t\t// TODO - only include the specific updates as part of save?\n\t\treturn this.save(o);\n\t}\n\t\n\t// For debugging / testing only\n\tasync $setraw(o = {}){\n\t\t\n\t\tlet res = await OP.db.update(this.id,o);\n\t\treturn this.$patch(res);\n\t}\n\t\n\t// Marks as embedded object\n\t$embed(up,key,data){\n\t\t\n\t\tlet id = this.id;\n\t\t\n\t\treturn Object.defineProperties(this,{\n\t\t\tid: {\n\t\t\t\tenumerable: false,\n\t\t\t\tget: function() { return (\"\" + (up.id) + `.` + key); }\n\t\t\t},\n\t\t\t$up: {enumerable: false,value: up},\n\t\t\t$key: {enumerable: false,value: key},\n\t\t\t$cloud: key.virtual ? {value: null} : {\n\t\t\t\tget: function() { return this.$up.$cloud?.[this.$key]; },\n\t\t\t\tset: function(val) { return this.$up.$cloud[this.$key] = val; }\n\t\t\t},\n\t\t\t$plain: key.virtual ? {value: data} : {\n\t\t\t\tget: function() { return this.$up.$plain?.[this.$key]; },\n\t\t\t\tset: function(val) { return this.$up.$plain[this.$key] = val; }\n\t\t\t},\n\t\t\trev: {\n\t\t\t\tget: function() { return this.$up.rev; }\n\t\t\t}\n\t\t});\n\t}\n\t\n\tclone(o = {}){\n\t\t\n\t\treturn this.$clone(o);\n\t}\n\t\n\t$clone(o = {}){\n\t\tvar $59, $60;\n\t\t\n\t\tlet data = OP.clone(this.$plain);\n\t\t((($59 = data.id),delete data.id, $59));\n\t\t((($60 = data._mod),delete data._mod, $60));\n\t\tif (data._rev) { data._rev = 1 };\n\t\tif (data._cre) { data._cre = OP.now };\n\t\t\n\t\treturn this.$type.new(data);\n\t}\n\t\n\tresolve(force = false){\n\t\t\n\t\treturn this.$resolve(force);\n\t}\n\t\n\tasync $resolve(force = false){\n\t\tvar self = this;\n\t\t\n\t\tif (this.embedΦ) {\n\t\t\t\n\t\t\tawait this.$up;\n\t\t};\n\t\t\n\t\tawait this.$saving;\n\t\t\n\t\tif (this.resolvedΦ && !(force)) {\n\t\t\t\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t// TODO use try/catch/finally here like in save\n\t\treturn this.$resolving ||= promising(async function(resolve,reject) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif (self.rev < 4) {\n\t\t\t\t\n\t\t\t\t// resolved if our object is still local\n\t\t\t\tself.$resolving = null;\n\t\t\t\treturn resolve(self);\n\t\t\t};\n\t\t\t// return true if already resolved?\n\t\t\tlet res = await OP.db.get(self.id);// `select * from {$type} where id = {id}`\n\t\t\tself.$patch(res || {_rev: -4},0,self.$cloud);\n\t\t\tself.$resolving = null;\n\t\t\treturn resolve(self);\n\t\t\t;\n\t\t});\n\t}\n\t\n\t// will move\n\tresolveΞchildren(){\n\t\t\n\t\tlet types = OPFieldRegistry.childrenΞof(this.$type);\n\t\t\n\t\t// creat\n\t\treturn true;\n\t}\n\t\n\t$willΞset(path,value){\n\t\t\n\t\tthis.$plain[$v$] = (this.$plain[$v$] || 0) + 1;\n\t\t// #diff = undefined\n\t\t\n\t\tif (this.$up && !(this.$key.virtual)) {\n\t\t\t\n\t\t\t// not clear that we should check the virtual here?\n\t\t\tthis.$up?.$willΞset?.([this].concat(path),value);\n\t\t} else if (this.$cloud == this.$plain) {\n\t\t\t\n\t\t\tthis.$cloud = globalThis.structuredClone(this.$plain || {});\n\t\t\t// for f in $fields.$embeds\n\t\t\t// \t$cloud[f.name] ??= {}\n\t\t\t// make sure to add the embeds here\n\t\t};\n\t\treturn true;\n\t}\n\t\n\t/**\n\t@returns { this }\n\t*/\n\t$patch(data,d = 0,cloud = this.$cloud){\n\t\tlet diffs;\n\t\t\n\t\tlet plain = this.$plain;\n\t\tconsole.log(\"%s %s %s %O\",'\u001b[90m::\u001b[0m','\u001b[40m\u001b[32m\\'patch\\'\u001b[0m','\u001b[44m\u001b[97mdata\u001b[0m',data);\n\t\t\n\t\tif (!(data)) {\n\t\t\t\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tif (data instanceof OPMUT) {\n\t\t\t\n\t\t\tthis.$applyΞdiffs(data,d);\n\t\t\tthis.$sync();\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\tif (false) {};\n\t\t\n\t\t\n\t\t\n\t\tif (cloud && cloud._rev && cloud._rev == data._rev) {\n\t\t\t\n\t\t\treturn this;\n\t\t};\n\t\t;\n\t\t\n\t\t// what if pov?\n\t\tif (data._rev < 3) {\n\t\t\t\n\t\t\t// Cleanup\n\t\t\tplain._rev = data._rev;\n\t\t\treturn this.$sync();\n\t\t};\n\t\t\n\t\tthis.$memo = {};\n\t\t// If this object was not really loaded before we should __wake__\n\t\t\n\t\t// Only used in one place now - to quickly return if there are no changes\n\t\t// and the flags from server hasnt changed. This is only to deal with\n\t\t// shallow vs full. Should potentially do this another way?\n\t\t\n\t\tlet dflags = (plain._ || 0) ^ (data._ || 0);\n\t\t// Add special case for when we literally havent done anything with object\n\t\t// just waited for it to resolve\n\t\t\n\t\t// Same revision we were already on\n\t\t// TODO On the web we may have received additional fields\n\t\tif (cloud && cloud._rev && cloud._rev == data._rev && !(dflags)) {\n\t\t\t\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t// if we don't have cloud data this is now it\n\t\t// but we need to apply it all directly? A bit tricky indeed.\n\t\t// changes to be added to the cloud properties\n\t\ttry {\n\t\t\tdiffs = differ(this.$cloud || plain,data);\n\t\t} catch (e) {\n\t\t\t\n\t\t\tconsole.trace(\"\");\n\t\t\treturn this;\n\t\t};\n\t\t\n\t\t// If we now get data with lazy properties we need to not remove them\n\t\t\n\t\tif (!(this.$cloud)) {\n\t\t\t\n\t\t\t// should we really set this here?\n\t\t\tthis.$cloud = cloud ||= data;\n\t\t};\n\t\t\n\t\t// call apply-diff directly?\n\t\tif (diffs) { this.$applyΞdiffs(diffs,d,cloud) };\n\t\t\n\t\t// not clear logic - what if we get a shallow version with a later reference?\n\t\t// FIXME several cases where this can be wrong\n\t\tthis.$cloud._ = (this.$cloud._ || 0) | (data._ || 0);\n\t\t// should be no diffs remaining\n\t\t// let unsaved = mdiff($cloud,$plain)\n\t\t\n\t\tif (this.$cloud != this.$plain) {\n\t\t\t\n\t\t\tlet diff = this.$diff();\n\t\t\t// here we could actually revert to making cloud and plain\n\t\t\t// be represented through the same item again\n\t\t\tif (!(diff)) {\n\t\t\t\t\n\t\t\t\tthis.$plain[$v$] = 0;// hack\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tthis.$plain[$v$] ||= 1;\n\t\t\t};\n\t\t};\n\t\t\n\t\tthis.$sync();\n\t\t\n\t\treturn this;\n\t\t// $patch2(data,src)\n\t}\n\t\n\t$applyΞdiffs(diffs,d = 0,cloud = this.$cloud,plain = this.$plain){\n\t\t\n\t\t// let cloud = $cloud\n\t\t\n\t\t\n\t\t// for convenience now\n\t\tif ((diffs instanceof OPMUT) && !((diffs instanceof OPDIFF))) {\n\t\t\t\n\t\t\tdiffs = [diffs];\n\t\t};\n\t\t\n\t\tconsole.log(\"%s %s %s %O\",'\u001b[90m::\u001b[0m','\u001b[40m\u001b[32m\\'apply\\'\u001b[0m','\u001b[44m\u001b[97mdiffs\u001b[0m',diffs);\n\t\t\n\t\tfor (let diff of iter$__(diffs)){\n\t\t\t\n\t\t\t// applying a patch\n\t\t\tlet k = diff.key;\n\t\t\tlet v = diff.value;\n\t\t\tlet f = this.$fields[k];\n\t\t\t\n\t\t\tconsole.log(\"%s %s %s %O %s %O %s %O\",'\u001b[90m::\u001b[0m','\u001b[40m\u001b[32m\\'diff\\'\u001b[0m','\u001b[44m\u001b[97mk\u001b[0m',k,'\u001b[44m\u001b[97mv\u001b[0m',v,'\u001b[44m\u001b[97mplain\u001b[0m',plain);\n\t\t\t\n\t\t\t// full object we're trying to set\n\t\t\tif ((diff instanceof OPSET) && k == null) {\n\t\t\t\t\n\t\t\t\treturn this.$patch(v,0);\n\t\t\t};\n\t\t\t\n\t\t\tif (!(f)) { continue; };\n\t\t\t\n\t\t\tif (f.embeddedΦ) {\n\t\t\t\t\n\t\t\t\t// Could just be a single CREATE patch?\n\t\t\t\tthis[k].$patch(v,d + 1,cloud[k] ||= {});\n\t\t\t\t// f.$patch([diff],self,d)\n\t\t\t} else if (f.refΦ || f.richΦ || f.complexΦ) {\n\t\t\t\t\n\t\t\t\t// doing these checks costs more than just calling?\n\t\t\t\tf.$set(v,this);\n\t\t\t\tif (cloud) { cloud[k] = v };\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// only if not deep?\n\t\t\t\t// and not saved?\n\t\t\t\tif (cloud) { cloud[k] = v };\n\t\t\t\t// what if our local data has changed?\n\t\t\t\tplain[k] = v;\n\t\t\t};\n\t\t};\n\t\t\n\t\tconsole.log(\"%s %s\",'\u001b[90m::\u001b[0m','\u001b[40m\u001b[32m\\'applied\\'\u001b[0m');\n\t\t\n\t\treturn this;\n\t}\n\t\n\t$sub(key){\n\t\t\n\t\tlet f = this.$fields[key];\n\t\t\n\t\t// return the actual object?\n\t\tif (f && f.embeddedΦ) {\n\t\t\t\n\t\t\treturn f.$get(this);\n\t\t} else if (f) {\n\t\t\t\n\t\t\treturn f.$bound(this);\n\t\t};\n\t\t\n\t\tlet v = this[key];\n\t\tif (v) { return v };\n\t\t\n\t\t// unless this key has a type\n\t\tlet typ = OPObject.getType(key);\n\t\tif (typ) {\n\t\t\t\n\t\t\treturn this.$pov(key);\n\t\t} else {\n\t\t\t\n\t\t\treturn null;\n\t\t};\n\t}\n\t\n\tget $path(){\n\t\t\n\t\tlet pre = this.$up && this.$up.$path;\n\t\treturn pre ? ((\"\" + pre + `.` + this.$key)) : ((this.$up ? ((\"\" + this.$key)) : null));\n\t}\n\t\n\tget $pathary(){\n\t\t\n\t\treturn this.$up ? this.$up.$pathary.concat(String(this.$key)) : [];\n\t}\n\t\n\t// how long since created - in milliseconds\n\tget $age(){\n\t\t\n\t\treturn this._cre ? ((OP.now - this._cre) * 1000) : Infinity;\n\t}\n\t\n\tget $shape(){\n\t\t\n\t\treturn this.$type.$shape;\n\t}\n\t\n\tget $fields(){\n\t\t\n\t\treturn this.$type.$shape.$shared;\n\t}\n\t\n\t// The raw data that is actually persisted for this object\n\tget $cloud(){\n\t\t\n\t\treturn OP.$cloud[this.id];\n\t}\n\t\n\tset $cloud(value){\n\t\t\n\t\t// Should never be overwritten if it existed already tbh\n\t\tlet prev = OP.$cloud[this.id];\n\t\t// if prev\n\t\t// \tthrow \"Cannot override $$persisted data for {id}\"\n\t\tOP.$cloud[this.id] = value;\n\t}\n\t\n\tget $$rich(){\n\t\t\n\t\tconsole.warn(`$$rich deprecated - use $rich`);\n\t\treturn this.$rich;\n\t}\n\t\n\t// closest item that exists in a table by itself\n\tget $root(){\n\t\t\n\t\treturn this.$up ? this.$up.$root : this;\n\t}\n\t\n\tget $rich(){\n\t\t\n\t\treturn {};\n\t}\n\t\n\tget $localdata(){\n\t\t\n\t\treturn false ? true : {};\n\t}\n\t\n\tget $sessiondata(){\n\t\t\n\t\treturn false ? true : {};\n\t}\n\t\n\tget $povs(){\n\t\t\n\t\treturn {};\n\t}\n\t\n\tget $povsΦ(){\n\t\t\n\t\treturn this.hasOwnProperty('$povs');\n\t}\n\t\n\tget $mutations(){\n\t\t\n\t\treturn this.$muts;\n\t}\n\t\n\tget $links(){\n\t\t\n\t\treturn new Set;\n\t}\n\t\n\tget $children(){\n\t\t\n\t\treturn new OPChildrenIndex(this);\n\t}\n\t\n\tget children(){\n\t\t\n\t\treturn this.$children;\n\t}\n\t\n\tget $parents(){\n\t\t\n\t\treturn new Index(this);\n\t}\n\t\n\t// models where this model has one or more explicit roles\n\tget $affiliations(){\n\t\t\n\t\treturn new Index(this);\n\t}\n\t\n\t$mutated(mut){\n\t\t\n\t\tthrow new Error('$mutated should not be called!');\n\t}\n\t\n\t$changed(mut){\n\t\t\n\t\treturn true;\n\t}\n\t\n\temit(name,...params){\n\t\treturn imba_emit(this,name,params);\n\t}\n\ton(name,cb){\n\t\treturn imba_listen(this,name,cb);\n\t}\n\tonce(name,cb){\n\t\treturn imba_once(this,name,cb);\n\t}\n\tun(name,cb){\n\t\treturn imba_unlisten(this,name,cb);\n\t}\n\t\n\t[Symbol.hasInstance](item){\n\t\t\n\t\treturn this[Symbol.match] ? this[Symbol.match](item) : false;\n\t}\n\t\n\t[$call__$](target,args){\n\t\t\n\t\tif (!(target)) {\n\t\t\t\n\t\t\tif (args.length == 2 && this[$sort$]) {\n\t\t\t\t\n\t\t\t\t// could also test that both args are of OP type\n\t\t\t\treturn this[$sort$](args[0],args[1]);\n\t\t\t};\n\t\t\t\n\t\t\t// matching the signature of .filter\n\t\t\tif (args.length == 3 && this[Symbol.match] && typeof args[1] == 'number') {\n\t\t\t\t\n\t\t\t\treturn this[Symbol.match](args[0]);\n\t\t\t};\n\t\t};\n\t}\n\t\n\t$serialize(o = {}){\n\t\t\n\t\treturn this.dehydrateΞfor(OP.agent);\n\t}\n\t\n\ttoDataTransfer(){\n\t\t\n\t\treturn {\n\t\t\t[(`op-id-` + this.id)]: '',\n\t\t\t'op-id': this.id,\n\t\t\t'text/uri-list': globalThis.location.origin + (this.url || '')\n\t\t};\n\t}\n\t\n\ttoJSON(){\n\t\t\n\t\treturn this.$serialize();\n\t}\n\t\n\tstatic serialize(item,o){\n\t\t\n\t\t\n\t\tif (item.constructor.serialize != this.serialize) {\n\t\t\t\n\t\t\treturn item.constructor.serialize(item,o);\n\t\t};\n\t\t\n\t\treturn item.dehydrateΞfor(OP.agent);\n\t\t\n\t\tif ((o instanceof OP.Client) || (o instanceof OP.Server)) {\n\t\t\t\n\t\t\treturn item.$serialize();\n\t\t} else {\n\t\t\t\n\t\t\treturn item.id;\n\t\t};\n\t}\n\t\n\tstatic deserialize(item,ctx){\n\t\t\n\t\tif (item._) {\n\t\t\t\n\t\t\t// clients should patch objects directly upon deserializing?\n\t\t\t// This could be risky if receiving data from untrusted sources\n\t\t\treturn false ? true : item;\n\t\t};\n\t\treturn this.get(item);\n\t}\n\t\n\t/**\n\t\n\t\n\t\t$diff(only: [ [string,...], [string,...] ] )\n\t\t\n\t@param {(string|string[]|string[][])} o\n\t*/\n\t$diff(o = {}){\n\t\tlet only;\n\t\t\n\t\tif (this.$plain != this.$cloud) {\n\t\t\t\n\t\t\tif (this.$cloud) {\n\t\t\t\t\n\t\t\t\tlet diffs = differ(this.$cloud,this.$plain);\n\t\t\t\t// Need to fix this - implement on the diffs themselves\n\t\t\t\t// Each filter is an array of strings\n\t\t\t\tif (only = o.only) {\n\t\t\t\t\t\n\t\t\t\t\tif (!((only instanceof Array))) { only = [only] };\n\t\t\t\t\t\n\t\t\t\t\tdiffs = diffs.filter(function(diff) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (let $61 = 0, $62 = iter$__(only), $63 = $62.length; $61 < $63; $61++) {\n\t\t\t\t\t\t\tlet path = $62[$61];\n\t\t\t\t\t\t\tif (typeof path == 'string') {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (diff.path[0] == path) { return true };\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (path.every(function(v,i) { return v == diff.path[i]; })) { return true };\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\treturn diffs;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\treturn this.$plain;\n\t\t\t};\n\t\t};\n\t\treturn;\n\t}\n\t\n\t// Tests if item quacks like this type\n\tstatic test(item){\n\t\t\n\t\treturn item instanceof this;\n\t}\n\t\n\t/**\n\t@param {number} bit\n\t*/\n\tstatic bit__(bit,data){\n\t\t\n\t\t// only allow if model key type is bit?\n\t\t\n\t\t// should _not_ be supported for all types right?\n\t\tlet nr = 1 << bit;\n\t\t\n\t\tlet id = this.id + '8' + nr.toString(32);// (1 << nr)\n\t\t\n\t\tif (data) {\n\t\t\t\n\t\t\tdata.id = id;\n\t\t\tdata._cre = data._mod = 1;\n\t\t\tOP.$cloud[id] = data;\n\t\t};\n\t\t\n\t\treturn this[nr] ||= this.get(id);\n\t}\n\t\n\tstatic bits__(val = 0){\n\t\t\n\t\t// should cache?\n\t\tlet vals = [];\n\t\tlet b = 0;\n\t\tlet num;\n\t\twhile ((num = 2 ** b) <= val){\n\t\t\t\n\t\t\tif (val & num) { vals.push(this.bit(b)) };\n\t\t\tb++;\n\t\t};\n\t\treturn vals;\n\t}\n\t\n\t/**\n\t\n\t\tDeclare and get static models with know oids\n\t\t\n\t*/\n\tstatic enum__(id,data){\n\t\t\n\t\tlet item = this.get(this.id + '9' + id);\n\t\tif (data) {\n\t\t\t\n\t\t\tthis.enums[id] ||= item;\n\t\t\t// TODO use $patch instead, but also apply the properties that are not in shape?\n\t\t\tdata._cre = data._mod = 1;\n\t\t\t// only the items that are not fields, right?\n\t\t\tfor (let $64 = 0, $65 = Object.keys(data), $66 = $65.length, k, v; $64 < $66; $64++){\n\t\t\t\tk = $65[$64];v = data[k];\n\t\t\t\tlet f = item.$shape[k];\n\t\t\t\tif (!(f)) {\n\t\t\t\t\t\n\t\t\t\t\titem[k] = v;\n\t\t\t\t};\n\t\t\t};\n\t\t\t// Object.assign(item,data)\n\t\t\titem.$patch(data);\n\t\t};\n\t\treturn item;\n\t}\n\t\n\t/**\n\t\t@template T\n\t\t@overload\n\t\t@param {T} this\n\t\t@return {InstanceType<T>}\n\t\t*/\n\t\n\tstatic get2(id,ctx = OP.context){\n\t\t\n\t\treturn this.get__(id,ctx);\n\t}\n\t\n\t// should never get a full object?\n\tstatic get__(id,ctx = OP.context){\n\t\t\n\t\t\n\t\tlet item = null;\n\t\tlet idtype = typeof id;\n\t\t\n\t\tif (idtype == 'number') {\n\t\t\t\n\t\t\treturn this.get(this.id + '0' + id.toString(32),ctx);\n\t\t};\n\t\t\n\t\tif (!(id)) { return };\n\t\t\n\t\tif (idtype == 'string') {\n\t\t\t\n\t\t\t\n\t\t\titem = OP.$rich[id];\n\t\t\tif (item) { return item };\n\t\t\t\n\t\t\tlet key = OPKey.decode(id,OPObjectRegistry);\n\t\t\t\n\t\t\tif (!(key)) {\n\t\t\t\t\n\t\t\t\tlet enumid = this.id + '9' + id;\n\t\t\t\t\n\t\t\t\tid = enumid;\n\t\t\t\tkey = OPKey.decode(id,OPObjectRegistry);\n\t\t\t};\n\t\t\t\n\t\t\tlet raw = OP.$cloud[id];\n\t\t\t\n\t\t\t// this is a subpath!\n\t\t\tif (key.path) {\n\t\t\t\t\n\t\t\t\titem = OP.get(key.id,ctx);\n\t\t\t\t\n\t\t\t\tfor (let $67 = 0, $68 = iter$__(key.path), $69 = $68.length; $67 < $69; $67++) {\n\t\t\t\t\tlet segment = $68[$67];\n\t\t\t\t\tlet sub = item.$sub(segment);\n\t\t\t\t\tif (sub) {\n\t\t\t\t\t\t\n\t\t\t\t\t\titem = sub;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (item) {\n\t\t\t\t\n\t\t\t\treturn item;\n\t\t\t};\n\t\t\t\n\t\t\tif (key.type) {\n\t\t\t\t\n\t\t\t\t// if there are slots - transform the data as well?\n\t\t\t\tif (key.data) {\n\t\t\t\t\t\n\t\t\t\t\tif (raw) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tObject.assign(raw,key.data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\traw = key.data;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif (!(key.type?.construct)) {\n\t\t\t\t\t\n\t\t\t\t\tconsole.warn('cannot generate key!',raw,key,id);\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\treturn key.type.construct(raw || {id: id},ctx);\n\t\t\t};\n\t\t};\n\t\t\n\t\t// should not get here anymore?\n\t\t\n\t\tif (id instanceof this) {\n\t\t\t\n\t\t\treturn id;\n\t\t};\n\t\t\n\t\tif (id == null) {\n\t\t\t\n\t\t\treturn null;\n\t\t};\n\t\t\n\t\tconsole.warn(\"should not get here in Model.get?\",id);\n\t\treturn;\n\t}\n\t\n\tstatic get any__(){\n\t\t\n\t\treturn this.enum('any');\n\t}\n\t\n\tstatic get unknown__(){\n\t\t\n\t\treturn this.enum('unknown');\n\t}\n\t\n\t/**\n\t\n\t\tGenerate a unique id for model\n\t\t\n\t*/\n\tstatic generateId(data = {}){\n\t\t\n\t\treturn this.key.generate(this.prototype,data);\n\t}\n\t\n\tstatic new__(data = {},ctx = null){\n\t\t\n\t\tlet raw = {};\n\t\tlet pov = null;\n\t\t\n\t\tfor (let $70 = 0, $71 = Object.keys(data), $72 = $71.length, k, v, f; $70 < $72; $70++){\n\t\t\tk = $71[$70];v = data[k];\n\t\t\tif (v == undefined) { continue; };\n\t\t\tif (f = this.$shape[k]) {\n\t\t\t\t\n\t\t\t\tif (f.$sanitize) { v = f.$sanitize(v) };\n\t\t\t\tif (f.pov) {\n\t\t\t\t\t\n\t\t\t\t\t(pov ||= {})[k] = v;\n\t\t\t\t\tcontinue;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\traw[k] = v;\n\t\t};\n\t\t\n\t\traw._ ??= 0;\n\t\traw._rev ??= 0;\n\t\t// raw._cre ??= now!\n\t\t// raw._rev ??= 1\n\t\t\n\t\t// build the id here already?\n\t\tSTACK.push(raw);\n\t\tlet item = this.construct(raw,ctx,raw);\n\t\tSTACK.pop(raw);\n\t\treturn item;\n\t}\n\t\n\tstatic build__(data = {},ctx = null){\n\t\t\n\t\t\n\t\tlet raw = {};\n\t\tlet pov = null;\n\t\t\n\t\tfor (let $73 = 0, $74 = Object.keys(data), $75 = $74.length, k, v, f; $73 < $75; $73++){\n\t\t\tk = $74[$73];v = data[k];\n\t\t\tif (v == undefined) { continue; };\n\t\t\tif (f = this.$shape[k]) {\n\t\t\t\t\n\t\t\t\tif (f.$sanitize) { v = f.$sanitize(v) };\n\t\t\t\tif (f.pov) {\n\t\t\t\t\t\n\t\t\t\t\t(pov ||= {})[k] = v;\n\t\t\t\t\tcontinue;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\traw[k] = v;\n\t\t};\n\t\t\n\t\t// raw._ = OPFLAGS.WEB\n\t\traw._cre ??= now();\n\t\traw._rev ??= 1;\n\t\t\n\t\t// build the id here already?\n\t\tSTACK.push(raw);\n\t\tlet item = this.construct(raw,ctx,raw);\n\t\tif (pov) {\n\t\t\t\n\t\t\tif (OP.agent) {\n\t\t\t\t\n\t\t\t\tfor (let $76 = 0, $77 = Object.keys(pov), $78 = $77.length, k, v; $76 < $78; $76++){\n\t\t\t\t\tk = $77[$76];v = pov[k];\n\t\t\t\t\titem[k] = v;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\t// set the pov properties?\n\t\t\t// let target = item.$pov(OP.pov)\n\t\t};\n\t\t\n\t\tSTACK.pop(raw);\n\t\treturn item;\n\t}\n\t\n\t/**\n\t\n\t\tImmediately try to persist the object. Awaiting the value\n\t\twill wait for saving to be finished instead of regular resolving\n\t\t\n\t*/\n\tstatic create__(data = {},ctx = null){\n\t\t\n\t\tlet item = this.build(data,ctx);\n\t\titem.save();\n\t\t// Create will always return the item itself even if the\n\t\t// initial save doesnt work.\n\t\treturn item;\n\t}\n\t\n\tstatic from__(...params){\n\t\t\n\t\tlet field = this.key;\n\t\tlet id = field.generate(this.prototype,params);\n\t\treturn OP.$rich[id] || this.get(id);\n\t}\n\tstatic {\n\t\tthis.prototype[$__hooks__$] = imba_hooks;\n\t\tdefineName$__(this,'OPObject');decorate$__([αmemo.bind([])],this,'$shape',null);\n\t\tdecorate$__([αmemo.bind([])],this,'deepShape',null);\n\t\tdecorate$__([αmemo.bind([])],this,'columns',null);\n\t\tdecorate$__([αmemo.bind([])],this,'signatures',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$rich',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$localdata',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$sessiondata',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$povs',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$links',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$children',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$parents',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'$affiliations',null);\n\t}\n}; globalThis.OPObject = OPObject;\n\n// To work around typing issues\nfor (let $81 = Object.getOwnPropertyDescriptors(OPObject), $79 = 0, $80 = Object.keys($81), $82 = $80.length, key, desc; $79 < $82; $79++){\n\tkey = $80[$79];desc = $81[key];\n\tif (key.slice(-2) == '__') {\n\t\t\n\t\tObject.defineProperty(OPObject,key.slice(0,-2),desc);\n\t};\n};\n\nmsgpack.register(0,OPObject);\n\n// Object.defineProperties(OPObject,Mixin)\n\n// Hack to set the .then method on items without typescript\n// noticing it - because we don't want typescript to believe\n// that models are thenable. We dynamically remove the .then\n// property when models are resolved, so that you can do\n// `await model` to ensure that a model is resolved.\n// Can use global state for partial / whole here?\n// (OPObject.prototype\\any).then = do(ok,err)\n// Promise.resolve(this.sys.resolve!).then(ok,err)\nObject.defineProperty(/**@type {any}*/(OPObject.prototype),'then',{\n\tget: function() { return this.resolvedΦ ? null : this.thenable; }\n});\n\n// export class SystemType < OPObject\n","dependencies":[],"map":{"version":3,"file":"object.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/core/object.imba"],"sourcesContent":["import { MemoMap, compare, nameToTable, getDeepDescriptor, NamedSet, now, promising, random } from '../utils'\nimport { Index } from './iterable'\nimport * as msgpack from '../msgpack'\nimport { STACK } from '../stack'\nimport differ from '../util/differnew.ts'\n\nglobal class OPObjectRegistry\n\nlet WeakCache = {}\n\n###\nInternal decorator for memoized results of things like Model.shape\nwhich are invalidated whenever a new model class has been declared\nby clearing the WeakCache in .inherit\n\nMove into utils?\n###\ndef @memo target, key, desc\n\tif let get = desc.get\n\t\tdesc.get = do\n\t\t\tlet map = WeakCache[key] ??= new WeakMap\n\t\t\treturn map.get(this) if map.has(this)\n\t\t\tlet val = get.call(this)\n\t\t\tmap.set(this,val)\n\t\t\treturn val\n\telif desc.value isa Function\n\t\tlet fn = desc.value\n\t\tdesc.value = do\n\t\t\tlet map = WeakCache[key] ??= new WeakMap\n\t\t\tlet mem = map.get(this) if map.has(this)\n\t\t\tmem || map.set(this,mem = new Map)\n\t\t\tlet res = mem.get($1) if map.has($1)\n\t\t\tres ?? map.set($1,res = fn.apply(this,$0))\n\t\t\treturn res\n\n\treturn desc\n\nlet InitialSetup = no\nlet EMBED = null\n\n# Base object that can have fields and all that\nglobal class OPObject\n\tdeclare #call\\any\n\tdeclare static enum = self.enum_\n\tdeclare static polymorphic\\boolean\n\n\tstatic def toString\n\t\tself.id\n\n\tstatic get pov?\n\t\tno\n\n\tstatic get virtual?\n\t\tkey.virtual\n\n\t###\n\tReturns the id field for model\n\t###\n\tstatic get key\\OPKeyField\n\t\tself.prototype.@@id.forType(self)\n\n\tstatic def find query\n\t\tif $web$\n\t\t\treturn self.all!.find do(item)\n\t\t\t\tfor own k,v of query\n\t\t\t\t\treturn false unless item[k] == v\n\t\t\t\treturn yes\n\n\t\tawait OP.find-one self, query\n\n\tstatic def filter query\n\t\tif $web$\n\t\t\treturn self.all!.find do(item)\n\t\t\t\tfor own k,v of query\n\t\t\t\t\treturn false unless item[k] == v\n\t\t\t\treturn yes\n\n\t\tawait OP.find-many self, query\n\n\tstatic def fetch-all\n\t\tOP.preload`select * from {self}`\n\n\tstatic def inherited subclass\n\t\tWeakCache = {}\n\t\t# Run setup on OPObject the first time we subclass it.\n\t\tif self == OPObject and !InitialSetup\n\t\t\tInitialSetup = yes\n\t\t\ttypes = new NamedSet\n\t\t\tself.setup(null)\n\n\t\tsubclass.setup(self)\n\t\treturn subclass\n\n\t###\n\tMethods we need to rename to get correct typings\n\t###\n\tstatic def toIterable\n\t\tOP.all(self)\n\n\tstatic get size\n\t\ttoIterable!.size\n\n\tstatic def all__ refinements\n\t\t# TODO maybe just use OP.all?\n\t\trefinements ? OP.all(self).select(refinements) : OP.all(self)\n\n\tstatic def embed target, field, data = {}\n\t\t# let name = String(field)\n\t\t# let id = OPKey.embed(target.id,name)\n\t\t# let data = target.$plain[field] ||= defaults\n\t\t# Should we just disable support for defaults?\n\t\t# How would we mark this as resolved etc?\n\t\t# let data = Object.assign({},defaults,{ref: name, parent: target, id: id,$up: target, $key: name})\n\t\t# TODO Include EMBEDDED flag in _ ?\n\t\t# Should we always set the value on plain immediately?\n\t\t# data ||= Object.assign({},defaults,{id: id})\n\t\tEMBED = [data,target,field]\n\t\tself.construct(data)\n\n\t# Why the difference between data and patch-data?\n\tstatic def construct data,store,id\n\t\tlet type = self\n\t\tlet idkey = key\n\n\t\tif polymorphic\n\t\t\tconsole.warn 'polymorphic not supported?'\n\t\t\tlet parsed = OPKey.decode(data.id,OPObjectRegistry)\n\t\t\tlet args = parsed.id.slice(1).map do root.get($1,store)\n\n\t\t\tfor [polytype,sign],si in signatures\n\t\t\t\t# hardcode max length for signatures?\n\t\t\t\tcontinue unless args[0] isa sign[0]\n\t\t\t\tcontinue if args[1] and !(args[1] isa sign[1])\n\t\t\t\tbreak type = polytype\n\n\t\tif !type.hasOwnProperty('finalized')\n\t\t\ttype.finalize!\n\n\t\tif prototype.#call isa Function\n\t\t\tlet fn\n\t\t\tfn = do(...args) return fn.#call(this,args)\n\t\t\tObject.setPrototypeOf(fn,type.prototype)\n\t\t\tlet nameprop = getDeepDescriptor(type.prototype,'name') or {value: name, writable: true}\n\t\t\tObject.defineProperty(fn,'name',nameprop) if nameprop\n\n\t\t\tfn.__init__(data)\n\t\t\tfn.#__init__(data,yes,no) # do we want to allow setting these base items?\n\t\t\tfn.__wake__(data)\n\n\t\t\t# wake already or not?\n\t\t\treturn fn\n\n\t\telse\n\t\t\tnew type(data)\n\n\t# Called for type after it has been setup\n\tstatic def finalize\n\t\treturn unless finalized =? yes\n\n\t\tlet key = key\n\n\t\tif key.bit\n\t\t\tprototype[Symbol.toPrimitive] = do(hint)\n\t\t\t\tthis._bit ??= parseInt(this.oid,32)\n\n\tstatic def setup base\n\n\t\tlet name = self.name\n\n\t\tlet mapping = OPObjectRegistry\n\t\tlet ns = self.namespace\n\t\tlet sysname = (name.match(/^OP([A-Z]\\w+)$/) or [])[1]\n\n\t\tself.$name = sysname or name\n\n\t\tif self.prototype[Symbol.match]\n\t\t\tself.prototype.#call ||= self.prototype.#call__\n\n\t\troot = OPObject\n\t\tparent = base\n\t\tenums = Object.create(base..enums or {})\n\t\tmeta = Object.create(base..meta or {})\n\n\t\treturn unless base\n\n\t\tself.Pov = (class Pov < (parent.Pov or OPPov))\n\t\tself.Pov.$for = self\n\t\ttable = base.table or self\n\n\t\tif delete self.abstract\n\t\t\ttable = null\n\n\t\tif alias == base.alias\n\t\t\talias = null\n\n\t\tif !virtual and !ns\n\t\t\tlet orig = OPAdapter.prototype[name]\n\t\t\tOPAdapter.prototype[name] = self\n\n\t\t\tif sysname\n\t\t\t\tOPAdapter.prototype[sysname] = self\n\n\t\tpgname = nameToTable(name)\n\n\t\tif name == base.$name\n\t\t\tif base.implementation\n\t\t\t\tthrow `{name} model cannot be extended more than once`\n\n\t\t\t# only allow for system tables?\n\t\t\tbase.implementation = self\n\t\t\tbase.abstract = yes\n\t\t\talias ??= base.alias\n\n\t\t\tif base.table == base\n\t\t\t\tbase.table = null\n\t\t\t\ttable = self\n\t\t\telse\n\t\t\t\tconsole.log 'doesnt have base table?!'\n\n\t\t\t# override all mapping\n\t\t\tfor own k,v of mapping\n\t\t\t\tif v == base\n\t\t\t\t\tmapping[k] = self\n\n\t\t\tif alias\n\t\t\t\tmapping[alias] = self\n\n\t\telif base.polymorphic\n\t\t\t# p 'subclass of polymorphic',name,base.id\n\t\t\talias = base.id\n\t\telif !ns\n\t\t\tmapping[name] = mapping[name.toLowerCase!] = self\n\t\t\tif sysname\n\t\t\t\tmapping[sysname] = mapping[sysname.toLowerCase!] = self\n\n\t\t\tif alias\n\t\t\t\tmapping[alias] = self\n\n\t\tid = alias or name.toLowerCase!\n\n\t\ttypes = new NamedSet\n\t\ttypes[id] = types[name] = types.add(self)\n\t\tref = name.toLowerCase!\n\t\t# TODO id should not be the shorthand - but rather lowercased versio\n\n\t\t# Make the id field a plain property\n\t\tObject.defineProperty(prototype,'id',{\n\t\t\tvalue: null,\n\t\t\tenumerable: true,\n\t\t\twritable:true,\n\t\t\tconfigurable:true\n\t\t})\n\n\t\t# Make these actions\n\t\t# FIXME Not needed anymore?\n\t\t# self.create = Action.wrap(Mixin.create.value.bind(self),{oid: 'create', type: self})\n\t\t# self.build = Action.wrap(Mixin.build.value.bind(self),{oid: 'build', type: self})\n\n\t\tlet par = parent\n\t\twhile par and par.types\n\t\t\tpar.types.add(self)\n\t\t\tif alias\n\t\t\t\tpar.types[alias] ||= self\n\t\t\tpar = par.parent\n\t\tself\n\n\t@memo static get $shape\n\t\tlet all = {}\n\t\tlet curr = self\n\n\t\twhile curr\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(curr.prototype)\n\t\t\tfor own name,val of proto when name.indexOf('αα') == 0\n\t\t\t\tall[name.slice(2)] ||= curr\n\t\t\tcurr = curr.parent\n\n\t\tlet fields = for own k,v of all\n\t\t\tv.prototype[`αα{k}`]\n\n\t\treturn new OPShape(self,fields)\n\n\tstatic get $fields\n\t\t$shape.$shared\n\n\t@memo static get deepShape\n\t\tlet all = {}\n\t\tlet curr = parent\n\n\t\twhile curr\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(curr.prototype)\n\t\t\tfor own name,val of proto when name.indexOf('αα') == 0\n\t\t\t\tall[name.slice(2)] = curr\n\t\t\tcurr = curr.parent\n\n\t\tfor type of types\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(type.prototype)\n\t\t\tfor own name,val of proto when name.indexOf('αα') == 0\n\t\t\t\tall[name.slice(2)] = type\n\n\t\tlet fields = for own k,v of all\n\t\t\tv.prototype[`αα{k}`]\n\n\t\treturn (new OPShape(self,fields))\n\n\t# all the potential columns of a model\n\t@memo static get columns\n\t\tlet all = {}\n\t\tlet curr = parent\n\n\t\twhile curr\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(curr.prototype)\n\t\t\tfor own name,val of proto when name.indexOf('αα') == 0\n\t\t\t\tall[name.slice(2)] = curr\n\t\t\tcurr = curr.parent\n\n\t\tfor type of types\n\t\t\tlet proto = Object.getOwnPropertyDescriptors(type.prototype)\n\t\t\tfor own name,val of proto when name.indexOf('αα') == 0\n\t\t\t\tall[name.slice(2)] = type\n\n\t\tlet fields = for own k,v of all\n\t\t\tv.prototype[`αα{k}`]\n\n\t\treturn (new OPShape(self,fields)).$columns\n\n\t@memo static get signatures\n\t\tlet all = []\n\t\tfor typ of types\n\t\t\tlet key = typ.key.forType(typ)\n\t\t\tall.unshift([typ,key.signature])\n\t\treturn all\n\n\tstatic def getType data\\(string | {id: any})\n\t\tif data isa self\n\t\t\treturn data.constructor\n\t\tif typeof data == 'string' and data.indexOf('.') == -1\n\t\t\tlet pre = (data.match(/^[a-zA-Z]+(?=\\d)/) or [])[0]\n\t\t\tlet typ = OPObjectRegistry[pre]\n\t\t\treturn typ\n\n\t\tlet parsed = OPKey.decode(data.id or data)\n\t\tlet type = OPObjectRegistry[parsed.type]\n\n\t\tif parsed.path\n\t\t\tlet f = type.$shape[parsed.path[0]]\n\t\t\tunless f\n\t\t\t\treturn type.Pov\n\n\t\treturn type\n\n\t# part can be id or object with id\n\t# strictly does not need to live here?\n\tstatic def groupByType ...parts\n\t\t# only belongs to this here?\n\t\tlet groups = new MemoMap do []\n\n\t\tfor item in parts\n\t\t\tlet type = getType(item)\n\t\t\tif type\n\t\t\t\tgroups.get(type).push(item)\n\t\treturn groups\n\n\tstatic def [Symbol.match] item\n\t\titem isa self\n\n\t# Santize plain object version of a type\n\t# eventually with options etc\n\tstatic def sanitize data\n\t\t# should not work destructively?\n\t\tfor own k,v of data\n\t\t\tdelete data[k] if v == null\n\t\treturn data\n\n\t# Default fields for all models\n\t$flags = 0\n\n\tget $ns\n\t\tOP\n\n\tdef thenable ok, err\n\t\tPromise.resolve(this.$resolve!).then(ok,err)\n\n\tdef constructor params\n\t\t__init__(params)\n\t\tsuper(params,yes,no)\n\t\t__wake__(params)\n\n\t\t# if we are fresh - go through fields with defaults and generate values\n\t\t# awaken any field that will set up listeners / indices etc\n\t\t# other props don't need to do anything\n\n\tdef __init__ params\n\t\t# if we are just building an item - does it make sense to not generate an id immediately?\n\t\t# This should be a setter that defines a property by default\n\t\tif params.id\n\t\t\tid = params.id\n\n\t\tObject.defineProperty(this,'$memo',{\n\t\t\tenumerable: no\n\t\t\twritable: yes\n\t\t\tvalue: {}\n\t\t})\n\n\t\tif EMBED and EMBED[0] == params\n\t\t\tlet [pars,up,key] = EMBED\n\t\t\tEMBED = null\n\t\t\t$embed(up,key,pars)\n\n\t\telif params.$up # slow?\n\n\t\t\tself.$up = params.$up\n\t\t\tself.$key = params.$key\n\t\telse\n\t\t\t$plain = params\n\n\t\t\tif id\n\t\t\t\t# Why not just use OP.map?\n\t\t\t\t# @ts-ignore\n\t\t\t\tOP.$rich[id] = self\n\t\t\telse\n\t\t\t\tObject.defineProperty(this,'id',{\n\t\t\t\t\tget: do generatedId!\n\t\t\t\t\tconfigurable: yes\n\t\t\t\t})\n\n\t\t\t# Object.defineProperty(self,'sys',value: new State(self,params))\n\n\t\treturn self\n\n\tdef __wake__ params\n\t\tlet s = $fields\n\t\tlet d = $plain\n\t\tlet r = rev\n\n\t\tif 4 > r > -1 # this was created locally\n\t\t\tfor own k,v of d\n\t\t\t\tif let f = s[k]\n\t\t\t\t\tif f.$sanitize\n\t\t\t\t\t\td[k] = f.$sanitize(v,self)\n\n\t\t\t\t\tif f.embedded?\n\t\t\t\t\t\t# wake the field\n\t\t\t\t\t\tself[k]\n\n\t\t\t\t\t# would this not be nested for items?\n\t\t\t\t\t# if f.embedded?\n\n\t\t\t# all fields that have defaults should be prepopulated\n\t\t\tfor f of s.$default\n\t\t\t\tlet v0 = d[f.name]\n\t\t\t\tcontinue unless v0 === undefined\n\t\t\t\tlet v = f.default.call(self)\n\t\t\t\tv = f.$sanitize(v,self) if v != undefined and f.$sanitize\n\t\t\t\t# has to be a dumb value?\n\t\t\t\td[f.name] = v unless v == undefined\n\n\t\t\t# ensure that the underlying data is plain\n\n\t\t# if typeof r == 'number'\n\n\t\tlet complex = s.$complex\n\t\tif complex.any?\n\t\t\tfor f of complex\n\t\t\t\tlet v = d[f.name]\n\t\t\t\t# what if it is on pov though?\n\t\t\t\tf.$wake(self,v)\n\n\t\t$sync! if r > 0\n\t\tself\n\n\t# Rename and move\n\tdef generatedId\n\t\tlet id = @@id.generate(this)\n\t\tObject.defineProperty(this,'id',value: id,writable: yes)\n\t\tthis.$plain.id = id\n\t\tOP.$rich[id] = this\n\t\treturn id\n\n\tdef toString\n\t\tid\n\n\tdef [Symbol.toPrimitive] hint\n\t\tid\n\n\tget rev\n\t\t$plain._rev\n\n\tget oid\n\t\t#oid or id.split(/(^[A-Za-z]+\\d|_)/)[2]\n\n\tset oid value\n\t\t#oid = value\n\n\tdef log ...params\n\t\tconsole.log id.blue,...params\n\n\tget $type\n\t\tconstructor\n\n\tdef sub-added sub\n\t\tif $flags |=? OPFLAGS.REFCOUNTED\n\t\t\t$subs = new Set\n\t\t$subs.add(sub)\n\t\tif $flags ~=? OPFLAGS.DEREFERENCED\n\t\t\t$sync!\n\t\tself\n\n\tdef sub-removed sub\n\t\t$subs.delete(sub)\n\t\tif $subs.size == 0\n\t\t\t$flags |= OPFLAGS.DEREFERENCED\n\t\t\t$sync!\n\t\tself\n\n\tdef add-link coll,name,rich\n\t\tif coll == undefined\n\t\t\tp 'link',coll,name,rich,self\n\t\t\tthrow \"cannot link\"\n\t\t$links.add(coll)\n\t\tif registered?\n\t\t\tcoll.add(self)\n\n\tdef remove-link coll\n\t\tif registered?\n\t\t\tcoll.delete(self)\n\t\t$links.delete(coll)\n\n\tdef $sync\n\t\tlet prev = $flags\n\t\tlet curr = prev\n\t\tlet up = $up\n\n\t\tlet dereg = deleted? or prev & OPFLAGS.DEREFERENCED\n\n\t\tif dereg and curr ~=? OPFLAGS.REGISTERED\n\t\t\tup ? up..$deregister(self) : OP.deregister(self)\n\t\t\t# type.$deregister(target,store)\n\t\t\tfor coll of $links\n\t\t\t\tcoll.delete(self)\n\n\t\telif exists? and curr |=? OPFLAGS.REGISTERED\n\t\t\tup ? up..$register(self) : OP.register(self)\n\n\t\t\tfor coll of $links\n\t\t\t\tcoll.add(self)\n\n\t\tif persisted? and prev !& OPFLAGS.PERSISTED\n\t\t\tcurr |= OPFLAGS.PERSISTED\n\n\t\t\t# save povs and other related things?\n\t\t\t# only if we go from local to persisted?\n\n\t\tif prev != curr\n\t\t\t$flags = curr\n\n\t\tself\n\t\t# (deleted? or $flags & FLAGS.DEREFERENCED) ? deregister! : (exists? and register!)\n\n\t# For now used to persist mutations instead of current save\n\t# Will end up just using save after refactor is done\n\tdef persist\\this\n\t\t$persist()\n\t\t# persisted? ? self : save!\n\n\tdef $persist\n\t\t$save!\n\n\t# wraps underlying save\n\tdef save o = {}\n\t\t$save(o)\n\n\tdef $save\\Promise<this> o = {}\n\t\t# TODO if already saving but we have additional changes\n\t\t# wrap the previous saving promise\n\n\t\tif virtual?\n\t\t\t# Should rather return?\n\t\t\treturn self\n\n\t\tlet promise\n\t\tlet current = $saving\n\n\t\tif current\n\t\t\t# fast exist if nothing to save?\n\t\t\trescue await $saving\n\t\t\t# $saving = null\n\n\t\t# TODO add force = no argument?\n\t\t$saving ||= promise = new Promise do(resolve,reject)\n\t\t\tlet res = yes\n\t\t\tlet err\n\n\t\t\ttry\n\t\t\t\tif embed?\n\t\t\t\t\tunless $up.persisted?\n\t\t\t\t\t\tconsole.warn \"cannot save embedded object when owner is not saved\"\n\t\t\t\t\t\treturn res = false\n\t\t\t\t\t\t# return resolve(false)\n\t\t\t\t\treturn await $root.$save(only: [$pathary])\n\n\t\t\t\tlet v = $plain.#v\n\t\t\t\tlet patchres\n\n\t\t\t\tif !persisted?\n\t\t\t\t\t# Respect o.only etc?\n\t\t\t\t\t$saved = global.structuredClone($plain)\n\t\t\t\t\t$plain.#v = 0\n\t\t\t\t\tlet res = await ($web$ ? OP.server.cre(id,$plain) : OP.db.insert(id,$plain))\n\t\t\t\t\t# $saving = null if $saving == promise\n\t\t\t\t\t$patch(res)\n\t\t\t\t\treturn self\n\n\t\t\t\t# if $initial\n\t\t\t\tif $cloud != $plain\n\n\t\t\t\t\tlet full = $diff!\n\n\t\t\t\t\tlet delta = o.only ? $diff(o) : full\n\t\t\t\t\t$saved = global.structuredClone($plain)\n\n\t\t\t\t\t# unsaved should immediately be false?\n\t\t\t\t\t# send all the diffs from the client, or send the resulting updates?\n\t\t\t\t\t# diffs are cleaner I guess\n\n\t\t\t\t\t# FIXME create failing test for this with the only thing\n\t\t\t\t\t$plain.#v = 0 if !full or full.length == 0\n\t\t\t\t\t# FIX ensure that this method is always async\n\t\t\t\t\t# works differently in browser?\n\t\t\t\t\tawait new Promise do $1()\n\t\t\t\t\treturn self if !delta or delta.length == 0\n\n\t\t\t\t\t# or rather\n\t\t\t\t\tif $node$\n\t\t\t\t\t\tlet upd = {}\n\t\t\t\t\t\tfor d in delta\n\t\t\t\t\t\t\tlet path = d.path.map(do $2 ? `[{$1}]` : $1).join('')\n\t\t\t\t\t\t\tupd[path] = d.value\n\n\t\t\t\t\t\tpatchres = await OP.db.update(id,upd)\n\t\t\t\t\t\t# Should the res indicate that it is from the server?\n\t\t\t\t\t\t$patch(patchres)\n\n\t\t\t\t\telse\n\t\t\t\t\t\tpatchres = await OP.server.patch(id,delta)\n\t\t\t\t\t\t$patch(patchres)\n\n\t\t\t\treturn self\n\t\t\tcatch error\n\t\t\t\t# TODO handle errors\n\t\t\t\terror.object = self\n\t\t\t\t$error = error\n\t\t\t\terr = error\n\t\t\tfinally\n\n\t\t\t\tif let pov = (self !isa OPPov and !o.only and self[OP.agent])\n\t\t\t\t\t# not if we save only specific items\n\t\t\t\t\tawait pov.$save!\n\t\t\t\t# resolve(yes)\n\t\t\t\t$saving = null if $saving == promise\n\t\t\t\terr ? reject(err) : resolve(res)\n\t\t\t\t# resolve(res)\n\t\t$saving.options = o\n\t\treturn $saving\n\n\tget saved\n\t\tself\n\t\t# $saved ? $saved.then(do self) : self\n\n\tdef destroy\n\t\t$destroy!\n\n\t# Or archive?\n\tdef $destroy\n\t\t_del = OP.now\n\t\tself\n\n\tdef reset(...args)\n\t\t$reset(...args)\n\n\t# clear existing commits / changes\n\tdef $reset\n\t\treturn self unless unsaved?\n\t\tlet diffs = differ($plain,$cloud)\n\t\t$apply-diffs(diffs,0)\n\t\t# now mark as saved?\n\t\t$plain\n\t\tself\n\n\tdef $pov key\n\t\treturn unless key\n\t\t# TODO should not store directly here?\n\t\tlet val = self[key]\n\t\tunless val\n\t\t\tval = new $type.Pov(self,key)\n\t\t\tObject.defineProperty(self,String(key),value: val, enumerable: no)\n\t\t\t$povs[key] = val\n\t\treturn val\n\n\tget pov\\OPPov\n\t\t$pov(OP.agent)\n\n\tdef set params = {}\n\t\t# TODO fixme\n\t\t# compare with existing params\n\t\t# if the object is said to be missing - do we turn it into another state?\n\t\t# do it with a shared mutation\n\t\tfor own k,v of params\n\t\t\t# why not just self[k] = v ?\n\t\t\t$fields[k].$set(v,self)\n\n\t\treturn self\n\n\tdef update params\n\t\t$update(params)\n\n\tdef $update\\this params\n\n\t\t# resolve with parents and all?\n\t\tawait resolve! unless resolved?\n\n\t\t# Very shallow check to see if we can write to each field\n\t\t# We should also check if the values are valid, and _valid_\n\t\t# for the user who is saving.\n\t\tlet pre = OP.clone($plain)\n\t\tlet o = {only: []}\n\t\tfor own k,v of params\n\t\t\tif OP.agent and OP.rights(self,k) !& 2\n\t\t\t\tthrow new OPNotAllowed(\"Cannot edit {k}\")\n\t\t\to.only.push([String(k)])\n\t\t\tself[k] = v\n\n\t\t# TODO - only include the specific updates as part of save?\n\t\treturn save(o)\n\n\t# For debugging / testing only\n\tdef $setraw o = {}\n\t\tlet res = await OP.db.update(id,o)\n\t\t$patch( res )\n\n\t# Marks as embedded object\n\tdef $embed up, key, data\n\t\tlet id = self.id\n\n\t\tObject.defineProperties(self,{\n\t\t\tid: {\n\t\t\t\tenumerable: no\n\t\t\t\tget: do `{up.id}.{key}`\n\t\t\t}\n\t\t\t$up: {enumerable: no, value: up}\n\t\t\t$key: {enumerable: no, value: key}\n\t\t\t$cloud: key.virtual ? {value: null} : {\n\t\t\t\tget: do this.$up.$cloud..[this.$key]\n\t\t\t\tset: do(val) this.$up.$cloud[this.$key] = val\n\t\t\t}\n\t\t\t$plain: key.virtual ? {value: data} : {\n\t\t\t\tget: do this.$up.$plain..[this.$key]\n\t\t\t\tset: do(val) this.$up.$plain[this.$key] = val\n\t\t\t}\n\t\t\trev: {\n\t\t\t\tget: do this.$up.rev\n\t\t\t}\n\t\t})\n\n\tdef clone(o = {})\n\t\t$clone(o)\n\n\tdef $clone o = {}\n\t\tlet data = OP.clone($plain)\n\t\tdelete data.id\n\t\tdelete data._mod\n\t\tdata._rev = 1 if data._rev\n\t\tdata._cre = OP.now if data._cre\n\n\t\treturn $type.new(data)\n\n\tdef resolve force=no\n\t\t$resolve(force)\n\n\tdef $resolve force=no\n\t\tif embed?\n\t\t\tawait $up\n\n\t\tawait $saving\n\n\t\tif resolved? and !force\n\t\t\treturn self\n\n\t\t# TODO use try/catch/finally here like in save\n\t\t$resolving ||= promising do(resolve,reject)\n\t\t\tif $node$\n\t\t\t\tif rev < 4\n\t\t\t\t\t# resolved if our object is still local\n\t\t\t\t\t$resolving = null\n\t\t\t\t\treturn resolve(self)\n\t\t\t\t# return true if already resolved?\n\t\t\t\tlet res = await OP.db.get(id) # `select * from {$type} where id = {id}`\n\t\t\t\t$patch(res or {_rev: -4},0,$cloud)\n\t\t\t\t$resolving = null\n\t\t\t\tresolve(self)\n\t\t\telse\n\t\t\t\t# Calls rpc method on OPServer - should batch probably\n\t\t\t\tlet patch = await OP.server.lookup(id)\n\t\t\t\t$patch(patch)\n\t\t\t\t$resolving = null\n\t\t\t\tresolve(self)\n\n\t# will move\n\tdef resolve-children\n\t\tlet types = OPFieldRegistry.children-of($type)\n\n\t\t# creat\n\t\tyes\n\n\tdef $will-set path, value\n\t\t$plain.#v = ($plain.#v or 0) + 1\n\t\t# #diff = undefined\n\n\t\tif $up and !$key.virtual\n\t\t\t# not clear that we should check the virtual here?\n\t\t\t$up..$will-set([self].concat(path),value)\n\t\telif $cloud == $plain\n\t\t\t$cloud = global.structuredClone($plain or {})\n\t\t\t# for f in $fields.$embeds\n\t\t\t# \t$cloud[f.name] ??= {}\n\t\t\t# make sure to add the embeds here\n\t\tyes\n\n\tdef $patch\\this data, d = 0,cloud = $cloud\n\t\tlet plain = $plain\n\t\tL 'patch',data\n\n\t\tif !data\n\t\t\treturn self\n\n\t\tif data isa OPMUT\n\t\t\t$apply-diffs(data,d)\n\t\t\t$sync()\n\t\t\treturn self\n\n\t\tif $web$\n\t\t\tif data and !cloud\n\t\t\t\tyes\n\t\t\t\t# go through deep - use wake instead of patch?\n\t\t\t\t# if we have no changes - make $cloud $plain?\n\t\t\t\t# for own k,v of data\n\n\t\tif $node$\n\t\t\tif cloud and cloud._rev and cloud._rev == data._rev\n\t\t\t\treturn self\n\n\t\t# what if pov?\n\t\tif data._rev < 3\n\t\t\t# Cleanup\n\t\t\tplain._rev = data._rev\n\t\t\treturn $sync!\n\n\t\t$memo = {}\n\t\t# If this object was not really loaded before we should __wake__\n\n\t\t# Only used in one place now - to quickly return if there are no changes\n\t\t# and the flags from server hasnt changed. This is only to deal with\n\t\t# shallow vs full. Should potentially do this another way?\n\n\t\tlet dflags = (plain._ or 0) ^ (data._ or 0)\n\t\t# Add special case for when we literally havent done anything with object\n\t\t# just waited for it to resolve\n\n\t\t# Same revision we were already on\n\t\t# TODO On the web we may have received additional fields\n\t\tif cloud and cloud._rev and cloud._rev == data._rev and !dflags\n\t\t\treturn self\n\n\t\t# if we don't have cloud data this is now it\n\t\t# but we need to apply it all directly? A bit tricky indeed.\n\t\t# changes to be added to the cloud properties\n\t\tlet diffs = try differ($cloud or plain,data) catch e\n\t\t\tconsole.trace(\"\")\n\t\t\treturn self\n\n\t\t# If we now get data with lazy properties we need to not remove them\n\n\t\tif !$cloud\n\t\t\t# should we really set this here?\n\t\t\t$cloud = cloud ||= data\n\n\t\t# call apply-diff directly?\n\t\t$apply-diffs(diffs,d,cloud) if diffs\n\n\t\t# not clear logic - what if we get a shallow version with a later reference?\n\t\t# FIXME several cases where this can be wrong\n\t\t$cloud._ = ($cloud._ or 0) | (data._ or 0)\n\t\t# should be no diffs remaining\n\t\t# let unsaved = mdiff($cloud,$plain)\n\n\t\tif $cloud != $plain\n\t\t\tlet diff = $diff!\n\t\t\t# here we could actually revert to making cloud and plain\n\t\t\t# be represented through the same item again\n\t\t\tif !diff\n\t\t\t\t$plain.#v = 0 # hack\n\t\t\telse\n\t\t\t\t$plain.#v ||= 1\n\n\t\t$sync()\n\n\t\tself\n\t\t# $patch2(data,src)\n\n\tdef $apply-diffs diffs,d = 0,cloud = $cloud, plain = $plain\n\t\t# let cloud = $cloud\n\n\n\t\t# for convenience now\n\t\tif diffs isa OPMUT and diffs !isa OPDIFF\n\t\t\tdiffs = [diffs]\n\n\t\tL 'apply',diffs\n\n\t\tfor diff of diffs\n\t\t\t# applying a patch\n\t\t\tlet k = diff.key\n\t\t\tlet v = diff.value\n\t\t\tlet f = $fields[k]\n\n\t\t\tL 'diff',k,v,plain\n\n\t\t\t# full object we're trying to set\n\t\t\tif diff isa OPSET and k == null\n\t\t\t\treturn $patch(v,0)\n\n\t\t\tcontinue unless f\n\n\t\t\tif f.embedded?\n\t\t\t\t# Could just be a single CREATE patch?\n\t\t\t\tself[k].$patch(v,d + 1,cloud[k] ||= {})\n\t\t\t\t# f.$patch([diff],self,d)\n\n\t\t\telif f.ref? or f.rich? or f.complex?\n\t\t\t\t# doing these checks costs more than just calling?\n\t\t\t\tf.$set(v,self)\n\t\t\t\tcloud[k] = v if cloud\n\n\t\t\telse\n\t\t\t\t# only if not deep?\n\t\t\t\t# and not saved?\n\t\t\t\tcloud[k] = v if cloud\n\t\t\t\t# what if our local data has changed?\n\t\t\t\tplain[k] = v\n\t\t\n\t\tL 'applied'\n\n\t\treturn self\n\n\tdef $sub key\n\t\tlet f = $fields[key]\n\n\t\t# return the actual object?\n\t\tif f and f.embedded?\n\t\t\treturn f.$get(self)\n\n\t\telif f\n\t\t\treturn f.$bound(self)\n\n\t\tlet v = self[key]\n\t\treturn v if v\n\n\t\t# unless this key has a type\n\t\tlet typ = OPObject.getType(key)\n\t\tif typ\n\t\t\treturn $pov(key)\n\t\telse\n\t\t\treturn null\n\n\tget $path\n\t\tlet pre = $up and $up.$path\n\t\tpre ? `{pre}.{$key}` : ($up ? `{$key}` : null)\n\n\tget $pathary\n\t\t$up ? $up.$pathary.concat(String($key)) : []\n\n\t# how long since created - in milliseconds\n\tget $age\n\t\t_cre ? (OP.now - _cre) * 1000 : Infinity\n\n\tget $shape\n\t\t$type.$shape\n\n\tget $fields\n\t\t$type.$shape.$shared\n\n\t# The raw data that is actually persisted for this object\n\tget $cloud\n\t\tOP.$cloud[id]\n\n\tset $cloud value\n\t\t# Should never be overwritten if it existed already tbh\n\t\tlet prev = OP.$cloud[id]\n\t\t# if prev\n\t\t# \tthrow \"Cannot override $$persisted data for {id}\"\n\t\tOP.$cloud[id] = value\n\n\tget $$rich\n\t\tconsole.warn `$$rich deprecated - use $rich`\n\t\t$rich\n\n\t# closest item that exists in a table by itself\n\tget $root\n\t\t$up ? $up.$root : self\n\n\t@lazy get $rich\n\t\t{}\n\n\t@lazy get $localdata\n\t\t$web$ ? imba.locals(id) : {}\n\n\t@lazy get $sessiondata\n\t\t$web$ ? imba.session(id) : {}\n\n\t@lazy get $povs\n\t\t{}\n\n\tget $povs?\n\t\thasOwnProperty('$povs')\n\n\tget $mutations\n\t\t$muts\n\n\t@lazy get $links\n\t\tnew Set\n\n\t@lazy get $children\n\t\tnew OPChildrenIndex(self)\n\n\tget children\n\t\t$children\n\n\t@lazy get $parents\n\t\tnew Index(self)\n\n\t# models where this model has one or more explicit roles\n\t@lazy get $affiliations\n\t\tnew Index(self)\n\n\tdef $mutated mut\n\t\tthrow new Error('$mutated should not be called!')\n\n\tdef $changed mut\n\t\tyes\n\n\tdef emit name, ...params do imba.emit(self,name,params)\n\tdef on name,cb do imba.listen(self,name,cb)\n\tdef once name,cb do imba.once(self,name,cb)\n\tdef un name,cb do imba.unlisten(self,name,cb)\n\n\tdef [Symbol.hasInstance] item\n\t\tself[Symbol.match] ? self[Symbol.match](item) : no\n\n\tdef #call__ target,args\n\t\tif !target\n\t\t\tif args.length == 2 and #sort\n\t\t\t\t# could also test that both args are of OP type\n\t\t\t\treturn #sort(args[0],args[1])\n\n\t\t\t# matching the signature of .filter\n\t\t\tif args.length == 3 and self[Symbol.match] and typeof args[1] == 'number'\n\t\t\t\treturn self[Symbol.match](args[0])\n\n\tdef $serialize o = {}\n\t\treturn dehydrate-for(OP.agent)\n\n\tdef toDataTransfer\n\t\t{\n\t\t\t[`op-id-{id}`]: ''\n\t\t\t'op-id': id\n\t\t\t'text/uri-list': global.location.origin + (url or '')\n\t\t}\n\n\tdef toJSON\n\t\t$serialize!\n\n\tstatic def serialize item, o\n\n\t\tif item.constructor.serialize != self.serialize\n\t\t\treturn item.constructor.serialize(item,o)\n\n\t\tif $node$\n\t\treturn item.dehydrate-for(OP.agent)\n\n\t\tif o isa OP.Client or o isa OP.Server\n\t\t\titem.$serialize()\n\t\telse\n\t\t\titem.id\n\n\tstatic def deserialize item,ctx\n\t\tif item._\n\t\t\t# clients should patch objects directly upon deserializing?\n\t\t\t# This could be risky if receiving data from untrusted sources\n\t\t\treturn $web$ ? OP.$patch(item) : item\n\t\treturn self.get(item)\n\n\t###\n\n\t$diff(only: [ [string,...], [string,...] ] )\n\t###\n\tdef $diff o\\(string|string[]|string[][]) = {}\n\t\tif $plain != $cloud\n\t\t\tif $cloud\n\t\t\t\tlet diffs = differ($cloud,$plain)\n\t\t\t\t# Need to fix this - implement on the diffs themselves\n\t\t\t\t# Each filter is an array of strings\n\t\t\t\tif let only = o.only\n\t\t\t\t\tonly = [only] unless only isa Array\n\t\t\t\t\t\n\t\t\t\t\tdiffs = diffs.filter do(diff)\n\t\t\t\t\t\tfor path in only\n\t\t\t\t\t\t\tif typeof path == 'string'\n\t\t\t\t\t\t\t\treturn yes if diff.path[0] == path\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn yes if path.every(do(v,i) v == diff.path[i])\n\t\t\t\t\t\treturn no\n\t\t\t\t\t\t\t\n\t\t\t\treturn diffs\n\t\t\telse\n\t\t\t\treturn $plain\n\t\treturn\n\n\t# Tests if item quacks like this type\n\tstatic def test item\n\t\titem isa self\n\n\tstatic def bit__ bit\\number, data\n\t\t# only allow if model key type is bit?\n\n\t\t# should _not_ be supported for all types right?\n\t\tlet nr = 1 << bit\n\n\t\tlet id = self.id + '8' + nr.toString(32) # (1 << nr)\n\n\t\tif data\n\t\t\tdata.id = id\n\t\t\tdata._cre = data._mod = 1\n\t\t\tOP.$cloud[id] = data\n\n\t\treturn self[nr] ||= self.get(id)\n\n\tstatic def bits__ val = 0\n\t\t# should cache?\n\t\tlet vals = []\n\t\tlet b = 0\n\t\tlet num\n\t\twhile (num = 2 ** b) <= val\n\t\t\tvals.push(bit(b)) if val & num\n\t\t\tb++\n\t\treturn vals\n\n\t###\n\tDeclare and get static models with know oids\n\t###\n\tstatic def enum__ id, data\n\t\tlet item = self.get(self.id + '9' + id)\n\t\tif data\n\t\t\tenums[id] ||= item\n\t\t\t# TODO use $patch instead, but also apply the properties that are not in shape?\n\t\t\tdata._cre = data._mod = 1\n\t\t\t# only the items that are not fields, right?\n\t\t\tfor own k,v of data\n\t\t\t\tlet f = item.$shape[k]\n\t\t\t\tunless f\n\t\t\t\t\titem[k] = v\n\t\t\t# Object.assign(item,data)\n\t\t\titem.$patch(data)\n\t\treturn item\n\n\t###\n\t@template T\n\t@overload\n\t@param {T} this\n\t@return {InstanceType<T>}\n\t###\n\tstatic def get2 id, ctx = OP.context\n\t\tget__(id,ctx)\n\n\t# should never get a full object?\n\tstatic def get__ id, ctx = OP.context\n\n\t\tlet item = null\n\t\tlet idtype = typeof id\n\n\t\tif idtype == 'number'\n\t\t\treturn self.get(self.id + '0' + id.toString(32),ctx)\n\n\t\treturn unless id\n\n\t\tif idtype == 'string'\n\n\t\t\titem = OP.$rich[id]\n\t\t\treturn item if item\n\n\t\t\tlet key = OPKey.decode(id,OPObjectRegistry)\n\n\t\t\tif !key\n\t\t\t\tlet enumid = self.id + '9' + id\n\n\t\t\t\tid = enumid\n\t\t\t\tkey = OPKey.decode(id,OPObjectRegistry)\n\n\t\t\tlet raw = OP.$cloud[id]\n\n\t\t\t# this is a subpath!\n\t\t\tif key.path\n\t\t\t\titem = OP.get(key.id,ctx)\n\n\t\t\t\tfor segment in key.path\n\t\t\t\t\tlet sub = item.$sub(segment)\n\t\t\t\t\tif sub\n\t\t\t\t\t\titem = sub\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null\n\n\t\t\tif item\n\t\t\t\treturn item\n\n\t\t\tif key.type\n\t\t\t\t# if there are slots - transform the data as well?\n\t\t\t\tif key.data\n\t\t\t\t\tif raw\n\t\t\t\t\t\tObject.assign(raw,key.data)\n\t\t\t\t\telse\n\t\t\t\t\t\traw = key.data\n\n\t\t\t\tif !key.type..construct\n\t\t\t\t\tconsole.warn 'cannot generate key!',raw,key,id\n\t\t\t\t\treturn null\n\n\t\t\t\treturn key.type.construct(raw or {id: id},ctx)\n\n\t\t# should not get here anymore?\n\n\t\tif id isa self\n\t\t\treturn id\n\n\t\tif id == null\n\t\t\treturn null\n\n\t\tconsole.warn \"should not get here in Model.get?\",id\n\t\treturn\n\n\tstatic get any__\n\t\tself.enum('any')\n\n\tstatic get unknown__\n\t\tself.enum('unknown')\n\n\t###\n\tGenerate a unique id for model\n\t###\n\tstatic def generateId data = {}\n\t\treturn key.generate(self.prototype,data)\n\n\tstatic def new__ data = {},ctx = null\n\t\tlet raw = {}\n\t\tlet pov = null\n\n\t\tfor own k,v of data\n\t\t\tcontinue if v == undefined\n\t\t\tif let f = $shape[k]\n\t\t\t\tv = f.$sanitize(v) if f.$sanitize\n\t\t\t\tif f.pov\n\t\t\t\t\t(pov ||= {})[k] = v\n\t\t\t\t\tcontinue\n\n\t\t\traw[k] = v\n\n\t\traw._ ??= 0\n\t\traw._rev ??= 0\n\t\t# raw._cre ??= now!\n\t\t# raw._rev ??= 1\n\n\t\t# build the id here already?\n\t\tSTACK.push(raw)\n\t\tlet item = construct(raw,ctx,raw)\n\t\tSTACK.pop(raw)\n\t\treturn item\n\n\tstatic def build__ data = {},ctx = null\n\n\t\tlet raw = {}\n\t\tlet pov = null\n\n\t\tfor own k,v of data\n\t\t\tcontinue if v == undefined\n\t\t\tif let f = $shape[k]\n\t\t\t\tv = f.$sanitize(v) if f.$sanitize\n\t\t\t\tif f.pov\n\t\t\t\t\t(pov ||= {})[k] = v\n\t\t\t\t\tcontinue\n\n\t\t\traw[k] = v\n\n\t\t# raw._ = OPFLAGS.WEB\n\t\traw._cre ??= now!\n\t\traw._rev ??= 1\n\n\t\t# build the id here already?\n\t\tSTACK.push(raw)\n\t\tlet item = construct(raw,ctx,raw)\n\t\tif pov\n\t\t\tif OP.agent\n\t\t\t\tfor own k,v of pov\n\t\t\t\t\titem[k] = v\n\n\t\t\t# set the pov properties?\n\t\t\t# let target = item.$pov(OP.pov)\n\n\t\tSTACK.pop(raw)\n\t\treturn item\n\n\t###\n\tImmediately try to persist the object. Awaiting the value\n\twill wait for saving to be finished instead of regular resolving\n\t###\n\tstatic def create__ data = {},ctx = null\n\t\tlet item = build(data,ctx)\n\t\titem.save!\n\t\t# Create will always return the item itself even if the\n\t\t# initial save doesnt work.\n\t\treturn item\n\n\tstatic def from__ ...params\n\t\tlet field = key\n\t\tlet id = field.generate(prototype,params)\n\t\treturn OP.$rich[id] or self.get(id)\n\n# To work around typing issues\nfor own key,desc of Object.getOwnPropertyDescriptors(OPObject)\n\tif key.slice(-2) == '__'\n\t\tObject.defineProperty(OPObject,key.slice(0,-2),desc)\n\nmsgpack.register(0,OPObject)\n\n# Object.defineProperties(OPObject,Mixin)\n\n# Hack to set the .then method on items without typescript\n# noticing it - because we don't want typescript to believe\n# that models are thenable. We dynamically remove the .then\n# property when models are resolved, so that you can do\n# `await model` to ensure that a model is resolved.\n# Can use global state for partial / whole here?\n# (OPObject.prototype\\any).then = do(ok,err)\n#\tPromise.resolve(this.sys.resolve!).then(ok,err)\nObject.defineProperty(OPObject.prototype\\any,'then',{\n\tget: do this.resolved? ? null : this.thenable\n})\n\n# export class SystemType < OPObject\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
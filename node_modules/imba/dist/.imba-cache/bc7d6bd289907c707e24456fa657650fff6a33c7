{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};\nconst $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $watchers$ = Symbol.for('#watchers');\n\n/*body*/\n// TODO Functions like this should be inlineable and not depend on the runtime\nimport {emit,listen} from './utils';\n\nexport function accessor(value,target,key,name,slot,context){\n\t\n\tif (value && (value.$accessor instanceof Function)) {\n\t\t\n\t\tvalue = value.$accessor(target,key,name,slot,context);\n\t} else {\n\t\t\n\t\t// cache this by default?\n\t\t// must implement custom .accessor method to bypass\n\t\tcontext[slot] = value;\n\t};\n\t\n\t// if accessor has no init method - forward to accessor.set\n\tif (value && !(value.$init)) {\n\t\t\n\t\tvalue.$init = value.$set || function() { return true; };\n\t};\n\treturn value;\n};\n\nexport function descriptor(context,value,args = []){\n\t\n\tif (value.prototype) { return new value(...args) };\n\treturn value.apply(context,args);\n};\n\nexport class Accessor {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $1;\n\t\t($1 = $$.local) !== undefined && (this.local = $1);\n\t\t($1 = $$.session) !== undefined && (this.session = $1);\n\t\t($1 = $$.weak) !== undefined && (this.weak = $1);\n\t\t\n\t}\n\tconstructor($$ = null){\n\t\tthis[$__init__$]($$);\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $2;\n\t\tthis.local = ($$ && ($2 = $$.local) !== undefined) ? ($2) : false;\n\t\tthis.session = ($$ && ($2 = $$.session) !== undefined) ? ($2) : false;\n\t\tthis.weak = ($$ && ($2 = $$.weak) !== undefined) ? ($2) : false;\n\t\t\n\t}\n\t\n\t\n\t// Store in localStorage - if target has unique `id`\n\t\n\t\n\t// Store in sessionStorage - if target has unique `id`\n\t\n\t\n\t// Store in separate weakmap\n\t\n\t\n\twatch(cb){\n\t\t\n\t\treturn (this[$watchers$] ||= []).push(cb);\n\t}\n\t\n\t$get(target,key){\n\t\t\n\t\treturn target[key];\n\t}\n\t\n\t$set(value,target,key,name){\n\t\t\n\t\tif (this[$watchers$]) {\n\t\t\t\n\t\t\tlet prev = this.$get(target,key,name);\n\t\t\tif (prev != value) {\n\t\t\t\t\n\t\t\t\ttarget[key] = value;\n\t\t\t\tfor (let i = 0, $3 = iter$__(this[$watchers$]), $4 = $3.length; i < $4; i++) {\n\t\t\t\t\tlet watcher = $3[i];\n\t\t\t\t\tlet res = watcher.call(target,value,prev,this);\n\t\t\t\t};\n\t\t\t};\n\t\t} else {\n\t\t\t\n\t\t\ttarget[key] = value;\n\t\t};\n\t\treturn;\n\t}\n\t\n\t// by default we are caching the @prop descriptor\n\t// so that it is only created once for all instances of a class\n\t$accessor(target,key,name,slot,context){\n\t\t\n\t\t// finalize it now - or stay slow?\n\t\treturn context[slot] = this;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Accessor');}\n};\n\nexport function Î±prop(){\n\t\n\treturn new Accessor;\n};\n","dependencies":[],"map":{"version":3,"file":"accessors.js","sourceRoot":"","sources":["/Users/sindre/repos/imba/packages/imba/src/imba/accessors.imba"],"sourcesContent":["# TODO Functions like this should be inlineable and not depend on the runtime\nimport {emit,listen} from './utils'\n\nexport def accessor value, target, key, name, slot, context\n\tif value and value.$accessor isa Function\n\t\tvalue = value.$accessor(target, key, name, slot, context)\n\telse\n\t\t# cache this by default?\n\t\t# must implement custom .accessor method to bypass\n\t\tcontext[slot] = value\n\n\t# if accessor has no init method - forward to accessor.set\n\tif value and !value.$init\n\t\tvalue.$init = value.$set or do yes\n\treturn value\n\nexport def descriptor context, value, args = []\n\treturn new value(...args) if value.prototype\n\treturn value.apply(context,args)\n\nexport class Accessor\n\n\t# Store in localStorage - if target has unique `id`\n\tlocal = no\n\n\t# Store in sessionStorage - if target has unique `id`\n\tsession = no\n\n\t# Store in separate weakmap\n\tweak = no\n\n\tdef watch cb\n\t\t(#watchers ||= []).push(cb)\n\n\tdef $get target, key\n\t\ttarget[key]\n\n\tdef $set value, target, key, name\n\t\tif #watchers\n\t\t\tlet prev = self.$get(target,key,name)\n\t\t\tif prev != value\n\t\t\t\ttarget[key] = value\n\t\t\t\tfor watcher,i in #watchers\n\t\t\t\t\tlet res = watcher.call(target,value,prev,self)\n\t\telse\n\t\t\ttarget[key] = value\n\t\treturn\n\n\t# by default we are caching the @prop descriptor\n\t# so that it is only created once for all instances of a class\n\tdef $accessor target, key, name, slot, context\n\t\t# finalize it now - or stay slow?\n\t\tcontext[slot] = self\n\nexport def @prop\n\treturn new Accessor"],"names":[],"mappings":";;;;;;;;AACA,MAAM,EAAE,IAAI,CAAC,MAAM,OAAO,SAAS;;AAEnC,MAAM,CAAC,QAAG,CAAC,QAAQ,CAAC,KAAK,CAAE,MAAM,CAAE,GAAG,CAAE,IAAI,CAAE,IAAI,CAAE,OAAO,CAAA;;CAC1D,EAAE,EAAC,KAAK,CAAC,EAAG,CAAC,CAAA,KAAK,CAAC,SAAS,YAAK,QAAQ,CAAA,EAAA;;EACxC,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,MAAM,CAAE,GAAG,CAAE,IAAI,CAAE,IAAI,CAAE,OAAO,CAAC;EAAA,MACtD;;;;EAGH,OAAO,CAAA,IAAK,CAAC,GAAG,KAAK;EAAA;;;CAGtB,EAAE,EAAC,KAAK,CAAC,EAAG,CAAC,EAAC,KAAK,CAAC,KAAK,CAAA,EAAA;;EACxB,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,QAAE,KAAC,OAAA,IAAG;EAAA;CACnC,MAAM,CAAC,KAAK;CAAA;;AAEb,MAAM,CAAC,QAAG,CAAC,UAAU,CAAC,OAAO,CAAE,KAAK,CAAE,IAAI,GAAG,EAAE,CAAA;;CACpB,EAAE,EAAC,KAAK,CAAC,SAAS,EAA5C,EAAA,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI,IAAI,CAAC;CACzB,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;CAAA;;AAEjC,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAA;qCApBrB;;WAuBC,KAAK,CAAA,wBAAL,KAAK;WAGL,OAAO,CAAA,wBAAP,OAAO;WAGP,IAAI,CAAA,wBAAJ,IAAI;;EA7BL;uBAAA;;EAAA;kDAAA;;OAuBC,KAAK,mBAAL,KAAK,CAAA,qBAAA,IAAG,KAAE;OAGV,OAAO,mBAAP,OAAO,CAAA,qBAAA,IAAG,KAAE;OAGZ,IAAI,mBAAJ,IAAI,CAAA,qBAAA,IAAG,KAAE;;EA7BV;;;;;;;;;;;;CA+BK,KAAK,CAAC,EAAE,CAAA;;0BACD,KAAK,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC;EAAA;;CAExB,IAAI,CAAC,MAAM,CAAE,GAAG,CAAA;;EACnB,OAAA,MAAM,CAAA,GAAI,CAAC;EAAA;;CAER,IAAI,CAAC,KAAK,CAAE,MAAM,CAAE,GAAG,CAAE,IAAI,CAAA;;EAChC,EAAE,kBAAU,EAAA;;OACP,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC;GACrC,EAAE,EAAC,IAAI,CAAC,EAAE,CAAC,KAAK,EAAA;;IACf,MAAM,CAAA,GAAI,CAAC,GAAG,KAAK;IACnB,GAAG,0CAAuB,gCAAA;SAAtB,OAAO;SACN,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;KAAA;IAAA;GAAA,MAC7C;;GACH,MAAM,CAAA,GAAI,CAAC,GAAG,KAAK;GAAA;EACpB,MAAM;EAAA;;;;CAIH,SAAS,CAAC,MAAM,CAAE,GAAG,CAAE,IAAI,CAAE,IAAI,CAAE,OAAO,CAAA;;;EAE7C,OAAA,OAAO,CAAA,IAAK,CAAC,GAAG,IAAI;EAAA;;;AAAA,CAAA;;AAEtB,MAAM,CAAC,QAAG,CAAC,KAAK,EAAA;;CACf,MAAM,CAAC,GAAG,CAAC,QAAQ;CAAA;AAAA;"}},"css":{"code":""},"warnings":[],"errors":[]}
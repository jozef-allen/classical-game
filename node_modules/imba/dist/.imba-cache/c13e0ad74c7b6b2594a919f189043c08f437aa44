{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };\nconst $extendType$ = Symbol.for('#extendType'), $modifierState$ = Symbol.for('#modifierState'), $sharedModifierState$ = Symbol.for('#sharedModifierState'), $onceHandlerEnd$ = Symbol.for('#onceHandlerEnd'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $extendDescriptors$ = Symbol.for('#extendDescriptors'), $context$ = Symbol.for('#context'), $self$ = Symbol.for('#self'), $target$ = Symbol.for('#target'), $stopPropagation$ = Symbol.for('#stopPropagation'), $defaultPrevented$ = Symbol.for('#defaultPrevented'), $teleport$ = Symbol.for('#teleport');\n\n/*body*/\n// imba$imbaPath=global\nimport {Event,Element,KeyboardEvent,MouseEvent,CustomEvent} from '../dom/core';\nimport {listen,once,emit,unlisten,parseTime} from '../utils';\nimport {scheduler} from '../scheduler';\n\nimport {use_events_keyboard} from './keyboard';\nuse_events_keyboard();\n\nimport {use_events_mouse} from './mouse';\nuse_events_mouse();\n\nclass ΩCustomEvent {\n\t\n\t\n\t[$extendType$](kls){\n\t\tvar desc, $1;\n\t\t\n\t\tlet ext = kls[$extendDescriptors$] ||= true && (\n\t\t\t\n\t\t\tdesc = Object.getOwnPropertyDescriptors(kls.prototype),\n\t\t\t((($1 = desc.constructor),delete desc.constructor, $1)),\n\t\t\tdesc\n\t\t);\n\t\treturn Object.defineProperties(this,ext);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'CustomEvent');}\n};\nextend$__(CustomEvent.prototype,ΩCustomEvent.prototype);\n;\n\nclass ΩEvent {\n\t\n\t\n\tget [$modifierState$](){\n\t\t\n\t\treturn this[$context$][this[$context$].step] ||= {};\n\t}\n\t\n\tget [$sharedModifierState$](){\n\t\t\n\t\treturn this[$context$].handler[this[$context$].step] ||= {};\n\t}\n\t\n\t[$onceHandlerEnd$](cb){\n\t\t\n\t\treturn once(this[$context$],'end',cb);\n\t}\n\t\n\tαsel(selector){\n\t\t\n\t\treturn !(!(this.target.matches(String(selector))));\n\t}\n\t\n\tαclosest(selector){\n\t\t\n\t\treturn !(!(this.target.closest(String(selector))));\n\t}\n\t\n\tαlog(...params){\n\t\t\n\t\tconsole.info(...params);\n\t\treturn true;\n\t}\n\t\n\tαtrusted(){\n\t\t\n\t\treturn !(!(this.isTrusted));\n\t}\n\t\n\tαif(expr){\n\t\t\n\t\treturn !(!(expr));\n\t}\n\t\n\tαwait(time = 250){\n\t\t\n\t\treturn new Promise(function(_0) { return setTimeout(_0,parseTime(time)); });\n\t}\n\t\n\tαself(){\n\t\t\n\t\treturn this.target == this[$context$].element;\n\t}\n\t\n\tαcooldown(time = 250){\n\t\t\n\t\tlet o = this[$sharedModifierState$];\n\t\t\n\t\tif (o.active) {\n\t\t\t\n\t\t\treturn false;\n\t\t};\n\t\t\n\t\to.active = true;\n\t\to.target = this[$context$].element;\n\t\to.target.flags.incr('cooldown');\n\t\t\n\t\tthis[$onceHandlerEnd$](function() {\n\t\t\t\n\t\t\treturn setTimeout(function() {\n\t\t\t\t\n\t\t\t\to.target.flags.decr('cooldown');\n\t\t\t\treturn o.active = false;\n\t\t\t},parseTime(time));\n\t\t});\n\t\t\n\t\treturn true;\n\t}\n\t\n\tαthrottle(time = 250){\n\t\t\n\t\tlet o = this[$sharedModifierState$];\n\t\t\n\t\tif (o.active) {\n\t\t\t\n\t\t\tif (o.next) { o.next(false) };\n\t\t\t\n\t\t\treturn new Promise(function(r) {\n\t\t\t\t\n\t\t\t\treturn o.next = function(val) {\n\t\t\t\t\t\n\t\t\t\t\to.next = null;\n\t\t\t\t\treturn r(val);\n\t\t\t\t};\n\t\t\t});\n\t\t};\n\t\t\n\t\to.active = true;\n\t\to.el ||= this[$context$].element;\n\t\to.el.flags.incr('throttled');\n\t\t\n\t\tonce(this[$context$],'end',function() {\n\t\t\t\n\t\t\tlet delay = parseTime(time);\n\t\t\t\n\t\t\treturn o.interval = setInterval(function() {\n\t\t\t\t\n\t\t\t\tif (o.next) {\n\t\t\t\t\t\n\t\t\t\t\to.next(true);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tclearInterval(o.interval);\n\t\t\t\t\to.el.flags.decr('throttled');\n\t\t\t\t\to.active = false;\n\t\t\t\t};\n\t\t\t\treturn;\n\t\t\t},delay);\n\t\t});\n\t\t\n\t\treturn true;\n\t}\n\t\n\tαdebounce(time = 250){\n\t\t\n\t\tlet o = this[$sharedModifierState$];\n\t\tlet e = this;\n\t\to.queue ||= [];\n\t\to.queue.push(o.last = e);\n\t\treturn new Promise(function(resolve) {\n\t\t\t\n\t\t\treturn setTimeout(function() {\n\t\t\t\t\n\t\t\t\tif (o.last == e) {\n\t\t\t\t\t\n\t\t\t\t\t// if this event is still the last\n\t\t\t\t\t// add the debounced queue to the event\n\t\t\t\t\t// and let the chain continue\n\t\t\t\t\te.debounced = o.queue;\n\t\t\t\t\to.last = null;\n\t\t\t\t\to.queue = [];\n\t\t\t\t\treturn resolve(true);\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\treturn resolve(false);\n\t\t\t\t};\n\t\t\t},parseTime(time));\n\t\t});\n\t}\n\t\n\t// will add a css className to the element (or selector)\n\t// and keep it for the duration of the event handling,\n\t// or at least 250ms\n\tαflag(name,sel){\n\t\t\n\t\tconst {element: element,step: step,state: state,id: id,current: current} = this[$context$];\n\t\t\n\t\tlet el = (sel instanceof Element) ? sel : ((sel ? element.closest(sel) : element));\n\t\t\n\t\tif (!(el)) { return true };\n\t\t\n\t\tthis[$context$].commit = true;\n\t\t\n\t\tstate[step] = id;\n\t\tel.flags.incr(name);\n\t\t\n\t\tlet ts = Date.now();\n\t\t\n\t\tonce(current,'end',function() {\n\t\t\t\n\t\t\tlet elapsed = Date.now() - ts;\n\t\t\tlet delay = Math.max(250 - elapsed,0);\n\t\t\treturn setTimeout(function() { return el.flags.decr(name); },delay);\n\t\t});\n\t\t\n\t\treturn true;\n\t}\n\t\n\tαbusy(sel){\n\t\t\n\t\t// TODO REMOVE\n\t\t// Add via\n\t\treturn this['αflag']('busy',sel);\n\t}\n\t\n\tαoutside(){\n\t\t\n\t\t// TODO Support selector here?\n\t\tconst {handler: handler} = this[$context$];\n\t\tif (handler && handler[$self$]) {\n\t\t\t\n\t\t\treturn !(handler[$self$].parentNode.contains(this.target));\n\t\t};\n\t}\n\t\n\tasync αpost(url,o = {}){\n\t\t\n\t\treturn await globalThis.fetch(url,{method: 'POST',...o});\n\t}\n\t\n\tasync αfetch(url,o = {}){\n\t\t\n\t\treturn await globalThis.fetch(url,o);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Event');}\n};\nextend$__(Event.prototype,ΩEvent.prototype);\n;\n\nexport const events = {};\n\nexport function use_events(){\n\t\n\tglobalThis.imba.uses_events = true;\n\treturn true;\n};\n\n// could cache similar event handlers with the same parts\nexport class EventHandler {\n\t\n\tconstructor(params,closure){\n\t\t\n\t\tthis.params = params;\n\t\tthis.closure = closure;\n\t}\n\t\n\tgetHandlerForMethod(el,name){\n\t\t\n\t\tif (!(el)) { return null };\n\t\treturn el[name] ? el : this.getHandlerForMethod(el.parentNode,name);\n\t}\n\t\n\tabortCurrentHandlers(){\n\t\t\n\t\tif (this.currentEvents) {\n\t\t\t\n\t\t\tfor (let ev of iter$__(this.currentEvents)){\n\t\t\t\t\n\t\t\t\tev.aborted = true;\n\t\t\t\tev?.resolver?.(true);\n\t\t\t};\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t// okay to auto-import these?\n\temit(name,...params){\n\t\treturn emit(this,name,params);\n\t}\n\ton(name,...params){\n\t\treturn listen(this,name,...params);\n\t}\n\tonce(name,...params){\n\t\treturn once(this,name,...params);\n\t}\n\tun(name,...params){\n\t\treturn unlisten(this,name,...params);\n\t}\n\t\n\tget passiveΦ(){\n\t\t\n\t\treturn this.params.passive;\n\t}\n\t\n\tget captureΦ(){\n\t\t\n\t\treturn this.params.capture;\n\t}\n\t\n\tget silentΦ(){\n\t\t\n\t\treturn this.params.silent;\n\t}\n\t\n\tget globalΦ(){\n\t\t\n\t\treturn this.params.global;\n\t}\n\t\n\tasync handleEvent(event){\n\t\t\n\t\tlet element = this[$target$] || event.currentTarget;\n\t\tlet mods = this.params;\n\t\t// let i = 0\n\t\t// let awaited = no\n\t\tlet error = null;\n\t\tlet silence = mods.silence || mods.silent;\n\t\t\n\t\tthis.count ||= 0;\n\t\tthis.state ||= {};\n\t\t\n\t\tlet state = {\n\t\t\telement: element,\n\t\t\tevent: event,\n\t\t\tmodifiers: mods,\n\t\t\thandler: this,\n\t\t\tid: ++this.count,\n\t\t\tstep: -1,\n\t\t\tstate: this.state,\n\t\t\tcommit: null,\n\t\t\tcurrent: null,\n\t\t\taborted: false\n\t\t};\n\t\t\n\t\tstate.current = state;\n\t\t\n\t\tif (event.handle$mod) {\n\t\t\t\n\t\t\tif (event.handle$mod.apply(state,mods.options || []) == false) {\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t};\n\t\t};\n\t\t\n\t\tlet guard = Event[this.type + '$handle'] || Event[event.type + '$handle'] || event.handle$mod || this.guard;\n\t\t\n\t\tif (guard && guard.apply(state,mods.options || []) == false) {\n\t\t\t\n\t\t\treturn;\n\t\t};\n\t\t\n\t\t// let object = state.proxy or event\n\t\t\n\t\tthis.currentEvents ||= new Set;\n\t\tthis.currentEvents.add(state);\n\t\t\n\t\tfor (let $2 = 0, $3 = Object.keys(mods), $8 = $3.length, handler, val; $2 < $8; $2++){\n\t\t\thandler = $3[$2];val = mods[handler];\n\t\t\tif (state.aborted) { break; };\n\t\t\t\n\t\t\tstate.step++;\n\t\t\t\n\t\t\tif (handler[0] == '_') {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t};\n\t\t\t\n\t\t\tif (handler.indexOf('~') > 0) {\n\t\t\t\t\n\t\t\t\thandler = handler.split('~')[0];\n\t\t\t};\n\t\t\t\n\t\t\tlet modargs = null;\n\t\t\tlet args = [event,state];\n\t\t\tlet res = undefined;\n\t\t\tlet context = null;\n\t\t\tlet m;\n\t\t\tlet negated = false;\n\t\t\tlet isstring = typeof handler == 'string';\n\t\t\t\n\t\t\tif (handler[0] == '$' && handler[1] == '_' && (val[0] instanceof Function)) {\n\t\t\t\t\n\t\t\t\t// handlers should commit by default\n\t\t\t\thandler = val[0];\n\t\t\t\tif (!(handler.passive)) { state.commit = true };// \n\t\t\t\targs = [event,state].concat(val.slice(1));\n\t\t\t\tcontext = element;\n\t\t\t} else if (val instanceof Array) {\n\t\t\t\t\n\t\t\t\targs = val.slice();\n\t\t\t\tmodargs = args;\n\t\t\t\t\n\t\t\t\tfor (let i = 0, $4 = iter$__(args), $7 = $4.length; i < $7; i++) {\n\t\t\t\t\tlet par = $4[i];\n\t\t\t\t\t\n\t\t\t\t\t// what about fully nested arrays and objects?\n\t\t\t\t\t// ought to redirect this\n\t\t\t\t\tif (typeof par == 'string' && par[0] == '~' && par[1] == '$') {\n\t\t\t\t\t\t\n\t\t\t\t\t\tlet name = par.slice(2);\n\t\t\t\t\t\tlet chain = name.split('.');\n\t\t\t\t\t\tlet value = state[chain.shift()] || event;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (let i = 0, $5 = iter$__(chain), $6 = $5.length; i < $6; i++) {\n\t\t\t\t\t\t\tlet part = $5[i];\n\t\t\t\t\t\t\tvalue = value ? value[part] : undefined;\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\targs[i] = value;\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (typeof handler == 'string' && (m = handler.match(/^(emit|flag|mod|moved|pin|fit|refit|map|remap|css)-(.+)$/))) {\n\t\t\t\t\n\t\t\t\tif (!(modargs)) { modargs = args = [] };\n\t\t\t\targs.unshift(m[2]);\n\t\t\t\thandler = m[1];\n\t\t\t};\n\t\t\t\n\t\t\tif (handler == 'trap') {\n\t\t\t\t\n\t\t\t\tevent[$stopPropagation$] = true;\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\tevent[$defaultPrevented$] = true;\n\t\t\t\tevent.preventDefault();\n\t\t\t} else if (handler == 'stop') {\n\t\t\t\t\n\t\t\t\tevent[$stopPropagation$] = true;\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t} else if (handler == 'prevent') {\n\t\t\t\t\n\t\t\t\tevent[$defaultPrevented$] = true;\n\t\t\t\tevent.preventDefault();\n\t\t\t} else if (handler == 'commit') {\n\t\t\t\t\n\t\t\t\tstate.commit = true;\n\t\t\t} else if (handler == 'once') {\n\t\t\t\t\n\t\t\t\t// clean up bound data as well\n\t\t\t\telement.removeEventListener(event.type,this);\n\t\t\t} else if (handler == 'options' || handler == 'silence' || handler == 'silent') {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t} else if (handler == 'emit') {\n\t\t\t\t\n\t\t\t\tlet name = args[0];\n\t\t\t\tlet detail = args[1];// is custom event if not?\n\t\t\t\tlet e = new CustomEvent(name,{bubbles: true,detail: detail});// : new Event(name)\n\t\t\t\te.originalEvent = event;\n\t\t\t\tlet source = this[$teleport$] || element;\n\t\t\t\tlet customRes = source.dispatchEvent(e);\n\t\t\t\t// TODO Add reference to this event to the current handler context?\n\t\t\t} else if (typeof handler == 'string') {\n\t\t\t\t\n\t\t\t\tif (handler[0] == '!') {\n\t\t\t\t\t\n\t\t\t\t\tnegated = true;\n\t\t\t\t\thandler = handler.slice(1);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tlet path = (\"α\" + handler);\n\t\t\t\t\n\t\t\t\tlet fn = event[path];\n\t\t\t\tfn ||= (this.type && Event[this.type + '$' + handler + '$mod']);\n\t\t\t\tfn ||= event[handler + '$mod'] || Event[event.type + '$' + handler] || Event[handler + '$mod'];\n\t\t\t\t\n\t\t\t\tif (fn instanceof Function) {\n\t\t\t\t\t\n\t\t\t\t\thandler = fn;\n\t\t\t\t\tcontext = state;\n\t\t\t\t\targs = modargs || [];\n\t\t\t\t\t\n\t\t\t\t\tif (event[path]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tcontext = event;\n\t\t\t\t\t\tevent[$context$] = state;\n\t\t\t\t\t};\n\t\t\t\t} else if (handler[0] == '_') {\n\t\t\t\t\t\n\t\t\t\t\thandler = handler.slice(1);\n\t\t\t\t\tcontext = this.closure;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// TODO deprecate this functionality and warn about it?\n\t\t\t\t\tcontext = this.getHandlerForMethod(element,handler);\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tif (handler instanceof Function) {\n\t\t\t\t\t\n\t\t\t\t\tres = handler.apply(context || element,args);\n\t\t\t\t} else if (context) {\n\t\t\t\t\t\n\t\t\t\t\tres = context[handler].apply(context,args);\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif (res && (res.then instanceof Function) && res != scheduler.$promise) {\n\t\t\t\t\t\n\t\t\t\t\tif (state.commit && !(silence)) { scheduler.commit() };\n\t\t\t\t\tres = await res;\n\t\t\t\t};\n\t\t\t} catch (e) {\n\t\t\t\t\n\t\t\t\terror = e;\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\t\n\t\t\tif (negated && res === true) {\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\tif (!(negated) && res === false) {\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t};\n\t\t\t\n\t\t\tstate.value = res;\n\t\t};\n\t\t\n\t\temit(state,'end',state);\n\t\t\n\t\tif (state.commit && !(silence)) { scheduler.commit() };\n\t\t\n\t\tthis.currentEvents.delete(state);\n\t\tif (this.currentEvents.size == 0) {\n\t\t\t\n\t\t\tthis.emit('idle');\n\t\t};\n\t\t// what if the result is a promise\n\t\t\n\t\tif (error != undefined) {\n\t\t\t\n\t\t\tif (this.type != 'error') {\n\t\t\t\t\n\t\t\t\tlet detail = (error instanceof Error) ? error.message : error;\n\t\t\t\tlet custom = new CustomEvent('error',{detail: detail,bubbles: true,cancelable: true});\n\t\t\t\t// @ts-ignore\n\t\t\t\tcustom.error = error;\n\t\t\t\t// @ts-ignore\n\t\t\t\tcustom.originalEvent = event;\n\t\t\t\tlet res = element.dispatchEvent(custom);\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (custom.defaultPrevented) { return };\n\t\t\t};\n\t\t\t\n\t\t\tthrow error;\n\t\t};\n\t\t\n\t\treturn state;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'EventHandler');}\n};\n\n// Add methods to Element\nclass ΩElement {\n\t\n\t\n\ton$(type,mods,scope){\n\t\t\n\t\tlet check = 'on$' + type;\n\t\tlet handler;\n\t\t\n\t\thandler = new EventHandler(mods,scope);\n\t\t\n\t\tlet capture = mods.capture || false;\n\t\tlet passive = mods.passive;\n\t\t\n\t\tlet o = capture;\n\t\t\n\t\tif (passive) {\n\t\t\t\n\t\t\to = {passive: passive,capture: capture};\n\t\t};\n\t\t\n\t\t// check if a custom handler exists for this type?\n\t\tif (this[check] instanceof Function) {\n\t\t\t\n\t\t\thandler = this[check](mods,scope,handler,o);\n\t\t} else {\n\t\t\t\n\t\t\tthis.addEventListener(type,handler,o);\n\t\t};\n\t\treturn handler;\n\t}\n\t\n\ton$error(mods,context,handler,o){\n\t\t\n\t\tif (mods.options?.length) {\n\t\t\t\n\t\t\thandler.guard = function(...types) {\n\t\t\t\t\n\t\t\t\tlet err = this.event.error;\n\t\t\t\tlet match = types.find(function(_0) { return err instanceof _0; });\n\t\t\t\treturn !(!(match));\n\t\t\t};\n\t\t};\n\t\t\n\t\tthis.addEventListener('error',handler,o);\n\t\treturn handler;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Element');}\n};\nextend$__(Element.prototype,ΩElement.prototype);\n;\n","dependencies":[],"map":{"version":3,"file":"core.js","sourceRoot":"","sources":["/Users/sindre/repos/imba/packages/imba/src/imba/events/core.imba"],"sourcesContent":["# imba$imbaPath=global\nimport {Event,Element,KeyboardEvent,MouseEvent,CustomEvent} from '../dom/core'\nimport {listen,once,emit,unlisten,parseTime} from '../utils'\nimport {scheduler} from '../scheduler'\n\nimport {use_events_keyboard} from './keyboard'\nuse_events_keyboard!\n\nimport {use_events_mouse} from './mouse'\nuse_events_mouse!\n\nextend class CustomEvent\n\n\tdef #extendType kls\n\t\tlet ext = kls.#extendDescriptors ||= if true\n\t\t\tlet desc = Object.getOwnPropertyDescriptors(kls.prototype)\n\t\t\tdelete desc.constructor\n\t\t\tdesc\n\t\tObject.defineProperties(self,ext)\n\nextend class Event\n\n\tget #modifierState\n\t\t#context[#context.step] ||= {}\n\n\tget #sharedModifierState\n\t\t#context.handler[#context.step] ||= {}\n\n\tdef #onceHandlerEnd cb\n\t\tonce(#context,'end',cb)\n\n\tdef @sel selector\n\t\treturn !!target.matches(String(selector))\n\n\tdef @closest selector\n\t\treturn !!target.closest(String(selector))\n\n\tdef @log ...params\n\t\tconsole.info(...params)\n\t\treturn true\n\n\tdef @trusted\n\t\treturn !!isTrusted\n\n\tdef @if expr\n\t\treturn !!expr\n\n\tdef @wait time = 250\n\t\tnew Promise(do setTimeout($1,parseTime(time)))\n\n\tdef @self\n\t\treturn target == #context.element\n\n\tdef @cooldown time = 250\n\t\tlet o = #sharedModifierState\n\n\t\tif o.active\n\t\t\treturn no\n\n\t\to.active = yes\n\t\to.target = #context.element\n\t\to.target.flags.incr('cooldown')\n\n\t\t#onceHandlerEnd do\n\t\t\tsetTimeout(&,parseTime(time)) do\n\t\t\t\to.target.flags.decr('cooldown')\n\t\t\t\to.active = no\n\n\t\treturn yes\n\n\tdef @throttle time = 250\n\t\tlet o = #sharedModifierState\n\n\t\tif o.active\n\t\t\to.next(no) if o.next\n\n\t\t\treturn new Promise do(r)\n\t\t\t\to.next = do(val)\n\t\t\t\t\to.next = null\n\t\t\t\t\tr(val)\n\n\t\to.active = yes\n\t\to.el ||= #context.element\n\t\to.el.flags.incr('throttled')\n\n\t\tonce(#context,'end') do\n\t\t\tlet delay = parseTime(time)\n\n\t\t\to.interval = setInterval(&,delay) do\n\t\t\t\tif o.next\n\t\t\t\t\to.next(yes)\n\t\t\t\telse\n\t\t\t\t\tclearInterval(o.interval)\n\t\t\t\t\to.el.flags.decr('throttled')\n\t\t\t\t\to.active = no\n\t\t\t\treturn\n\n\t\treturn yes\n\n\tdef @debounce time = 250\n\t\tlet o = #sharedModifierState\n\t\tlet e = self\n\t\to.queue ||= []\n\t\to.queue.push(o.last = e)\n\t\tnew Promise do(resolve)\n\t\t\tsetTimeout(&,parseTime(time)) do\n\t\t\t\tif o.last == e\n\t\t\t\t\t# if this event is still the last\n\t\t\t\t\t# add the debounced queue to the event\n\t\t\t\t\t# and let the chain continue\n\t\t\t\t\te.debounced = o.queue\n\t\t\t\t\to.last = null\n\t\t\t\t\to.queue = []\n\t\t\t\t\tresolve(true)\n\t\t\t\telse\n\t\t\t\t\tresolve(false)\n\n\t# will add a css className to the element (or selector)\n\t# and keep it for the duration of the event handling,\n\t# or at least 250ms\n\tdef @flag name, sel\n\t\tconst {element,step,state,id,current} = #context\n\n\t\tlet el = sel isa Element ? sel : (sel ? element.closest(sel) : element)\n\n\t\treturn true unless el\n\n\t\t#context.commit = yes\n\n\t\tstate[step] = id\n\t\tel.flags.incr(name)\n\n\t\tlet ts = Date.now!\n\n\t\tonce(current,'end') do\n\t\t\tlet elapsed = Date.now! - ts\n\t\t\tlet delay = Math.max(250 - elapsed,0)\n\t\t\tsetTimeout(&,delay) do el.flags.decr(name)\n\n\t\treturn true\n\n\tdef @busy sel\n\t\t# TODO REMOVE\n\t\t# Add via\n\t\tself['αflag']('busy',sel)\n\n\tdef @outside\n\t\t# TODO Support selector here?\n\t\tconst {handler} = #context\n\t\tif handler and handler.#self\n\t\t\treturn !handler.#self.parentNode.contains(target)\n\n\tdef @post url, o = {}\n\t\tawait global.fetch url, { method:'POST', ...o }\n\n\tdef @fetch url, o = {}\n\t\tawait global.fetch url, o\n\nexport const events = {}\n\nexport def use_events\n\tglobal.imba.uses_events = yes\n\tyes\n\n# could cache similar event handlers with the same parts\nexport class EventHandler\n\tdef constructor params,closure\n\t\tself.params = params\n\t\tself.closure = closure\n\n\tdef getHandlerForMethod el, name\n\t\treturn null unless el\n\t\tel[name] ? el : self.getHandlerForMethod(el.parentNode,name)\n\n\tdef abortCurrentHandlers\n\t\tif currentEvents\n\t\t\t\tfor ev of currentEvents\n\t\t\t\t\tev.aborted = yes\n\t\t\t\t\tev..resolver(yes)\n\t\tself\n\n\t# okay to auto-import these?\n\tdef emit name, ...params do emit(self,name,params)\n\tdef on name, ...params do listen(self,name,...params)\n\tdef once name, ...params do once(self,name,...params)\n\tdef un name, ...params do unlisten(self,name,...params)\n\n\tget passive?\n\t\tparams.passive\n\n\tget capture?\n\t\tparams.capture\n\n\tget silent?\n\t\tparams.silent\n\n\tget global?\n\t\tparams.global\n\n\tdef handleEvent event\n\t\tlet element = #target or event.currentTarget\n\t\tlet mods = self.params\n\t\t# let i = 0\n\t\t# let awaited = no\n\t\tlet error = null\n\t\tlet silence = mods.silence or mods.silent\n\n\t\tself.count ||= 0\n\t\tself.state ||= {}\n\n\t\tlet state = {\n\t\t\telement: element\n\t\t\tevent: event\n\t\t\tmodifiers: mods\n\t\t\thandler: this\n\t\t\tid: ++self.count\n\t\t\tstep: -1\n\t\t\tstate: self.state\n\t\t\tcommit: null\n\t\t\tcurrent: null\n\t\t\taborted: no\n\t\t}\n\n\t\tstate.current = state\n\n\t\tif event.handle$mod\n\t\t\tif event.handle$mod.apply(state,mods.options or []) == false\n\t\t\t\treturn\n\n\t\tlet guard = Event[self.type + '$handle'] or Event[event.type + '$handle'] or event.handle$mod or self.guard\n\n\t\tif guard and guard.apply(state,mods.options or []) == false\n\t\t\treturn\n\n\t\t# let object = state.proxy or event\n\n\t\tself.currentEvents ||= new Set\n\t\tself.currentEvents.add(state)\n\n\t\tfor own handler,val of mods\n\t\t\tbreak if state.aborted\n\n\t\t\tstate.step++\n\n\t\t\tif handler[0] == '_'\n\t\t\t\tcontinue\n\n\t\t\tif handler.indexOf('~') > 0\n\t\t\t\thandler = handler.split('~')[0]\n\n\t\t\tlet modargs = null\n\t\t\tlet args = [event,state]\n\t\t\tlet res = undefined\n\t\t\tlet context = null\n\t\t\tlet m\n\t\t\tlet negated = no\n\t\t\tlet isstring = typeof handler == 'string'\n\n\t\t\tif handler[0] == '$' and handler[1] == '_' and val[0] isa Function\n\t\t\t\t# handlers should commit by default\n\t\t\t\thandler = val[0]\n\t\t\t\tstate.commit = yes unless handler.passive #\n\t\t\t\targs = [event,state].concat(val.slice(1))\n\t\t\t\tcontext = element\n\n\t\t\t# parse the arguments\n\t\t\telif val isa Array\n\t\t\t\targs = val.slice()\n\t\t\t\tmodargs = args\n\n\t\t\t\tfor par,i in args\n\t\t\t\t\t# what about fully nested arrays and objects?\n\t\t\t\t\t# ought to redirect this\n\t\t\t\t\tif typeof par == 'string' && par[0] == '~' and par[1] == '$'\n\t\t\t\t\t\tlet name = par.slice(2)\n\t\t\t\t\t\tlet chain = name.split('.')\n\t\t\t\t\t\tlet value = state[chain.shift()] or event\n\n\t\t\t\t\t\tfor part,i in chain\n\t\t\t\t\t\t\tvalue = value ? value[part] : undefined\n\n\t\t\t\t\t\targs[i] = value\n\n\t\t\tif typeof handler == 'string' and m = handler.match(/^(emit|flag|mod|moved|pin|fit|refit|map|remap|css)-(.+)$/)\n\t\t\t\tmodargs = args = [] unless modargs\n\t\t\t\targs.unshift(m[2])\n\t\t\t\thandler = m[1]\n\n\t\t\tif handler == 'trap'\n\t\t\t\tevent.#stopPropagation = yes\n\t\t\t\tevent.stopImmediatePropagation()\n\t\t\t\tevent.#defaultPrevented = yes\n\t\t\t\tevent.preventDefault()\n\n\t\t\telif handler == 'stop'\n\t\t\t\tevent.#stopPropagation = yes\n\t\t\t\tevent.stopImmediatePropagation()\n\t\t\telif handler == 'prevent'\n\t\t\t\tevent.#defaultPrevented = yes\n\t\t\t\tevent.preventDefault()\n\t\t\telif handler == 'commit'\n\t\t\t\tstate.commit = yes\n\n\t\t\telif handler == 'once'\n\t\t\t\t# clean up bound data as well\n\t\t\t\telement.removeEventListener(event.type,self)\n\t\t\telif handler == 'options' or handler == 'silence' or handler == 'silent'\n\t\t\t\tcontinue\n\n\t\t\telif handler == 'emit'\n\t\t\t\tlet name = args[0]\n\t\t\t\tlet detail = args[1] # is custom event if not?\n\t\t\t\tlet e = new CustomEvent(name, bubbles: true, detail: detail) # : new Event(name)\n\t\t\t\te.originalEvent = event\n\t\t\t\tlet source = #teleport or element\n\t\t\t\tlet customRes = source.dispatchEvent(e)\n\t\t\t\t# TODO Add reference to this event to the current handler context?\n\n\t\t\telif typeof handler == 'string'\n\t\t\t\tif handler[0] == '!'\n\t\t\t\t\tnegated = yes\n\t\t\t\t\thandler = handler.slice(1)\n\n\t\t\t\tlet path = \"α{handler}\"\n\n\t\t\t\tlet fn = event[path]\n\t\t\t\tfn ||= (self.type and Event[self.type + '$' + handler + '$mod'])\n\t\t\t\tfn ||= event[handler + '$mod'] or Event[event.type + '$' + handler] or Event[handler + '$mod']\n\n\t\t\t\tif fn isa Function\n\t\t\t\t\thandler = fn\n\t\t\t\t\tcontext = state\n\t\t\t\t\targs = modargs or []\n\n\t\t\t\t\tif event[path]\n\t\t\t\t\t\tcontext = event\n\t\t\t\t\t\tevent.#context = state\n\n\t\t\t\t# should default to first look at closure - no?\n\t\t\t\telif handler[0] == '_'\n\t\t\t\t\thandler = handler.slice(1)\n\t\t\t\t\tcontext = self.closure\n\t\t\t\telse\n\t\t\t\t\t# TODO deprecate this functionality and warn about it?\n\t\t\t\t\tcontext = self.getHandlerForMethod(element,handler)\n\n\t\t\ttry\n\t\t\t\tif handler isa Function\n\t\t\t\t\tres = handler.apply(context or element,args)\n\t\t\t\telif context\n\t\t\t\t\tres = context[handler].apply(context,args)\n\n\t\t\t\tif res and res.then isa Function and res != scheduler.$promise\n\t\t\t\t\tscheduler.commit! if state.commit and !silence\n\t\t\t\t\tres = await res\n\t\t\tcatch e\n\t\t\t\terror = e\n\t\t\t\tbreak\n\n\t\t\tif negated and res === true\n\t\t\t\tbreak\n\t\t\tif !negated and res === false\n\t\t\t\tbreak\n\n\t\t\tstate.value = res\n\n\t\temit(state,'end',state)\n\n\t\tscheduler.commit! if state.commit and !silence\n\n\t\tself.currentEvents.delete(state)\n\t\tif self.currentEvents.size == 0\n\t\t\tself.emit('idle')\n\t\t# what if the result is a promise\n\n\t\tif error != undefined\n\t\t\tif self.type != 'error'\n\t\t\t\tlet detail = error isa Error ? error.message : error\n\t\t\t\tlet custom = new CustomEvent('error',{detail: detail, bubbles: true, cancelable: true})\n\t\t\t\t# @ts-ignore\n\t\t\t\tcustom.error = error\n\t\t\t\t# @ts-ignore\n\t\t\t\tcustom.originalEvent = event\n\t\t\t\tlet res = element.dispatchEvent(custom)\n\t\t\t\t# @ts-ignore\n\t\t\t\treturn if custom.defaultPrevented\n\n\t\t\tthrow error\n\n\t\treturn state\n\n# Add methods to Element\nextend class Element\n\n\tdef on$ type, mods, scope\n\t\tlet check = 'on$' + type\n\t\tlet handler\n\n\t\thandler = new EventHandler(mods,scope)\n\n\t\tlet capture = mods.capture or no\n\t\tlet passive = mods.passive\n\n\t\tlet o = capture\n\n\t\tif passive\n\t\t\to = {passive: passive, capture: capture}\n\n\t\t# check if a custom handler exists for this type?\n\t\tif self[check] isa Function\n\t\t\thandler = self[check](mods,scope,handler,o)\n\t\telse\n\t\t\tself.addEventListener(type,handler,o)\n\t\treturn handler\n\n\tdef on$error mods,context,handler,o\n\t\tif mods.options..length\n\t\t\thandler.guard = do(...types)\n\t\t\t\tlet err = this.event.error\n\t\t\t\tlet match = types.find do err isa $1\n\t\t\t\treturn !!match\n\n\t\tself.addEventListener('error',handler,o)\n\t\treturn handler\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
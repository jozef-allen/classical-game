{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction decorate$__(decorators,target,key,desc){\n\tvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\tif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\telse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\treturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};\nimport {αlazy as imba_αlazy, use_hooks as imba_use_hooks, hooks as imba_hooks} from 'imba';\n(imba_use_hooks());\nconst $setForType$ = Symbol.for('#setForType'), $setsForType$ = Symbol.for('#setsForType'), $__hooks__$ = Symbol.for('#__hooks__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $node$ = Symbol.for('#node');\nvar $1 = Symbol();\n\n/*body*/\n\nimport {STACK} from '../stack';\nimport {Message,R,W,D,RW} from '../protocol';\nimport {Iterable,Index} from './iterable';\nimport {Component} from '../component';\nimport * as msgpack from '../msgpack';\nimport {compare,random} from '../utils';\n\nlet OP = null;\n\n// let AdapterInstance\n// workaround to hide this from Typescript tooling\n// All this should go in adapter\nconst opname = String.fromCharCode(79,80);\n\nObject.defineProperty(globalThis,opname,{\n\tget: function() {\n\t\t\n\t\treturn OP ||= new (OPAdapter.Main || OPAdapter);\n\t},\n\t\n\tset: function(value) {\n\t\t\n\t\tif (OP && OP != value) {\n\t\t\t\n\t\t\tconsole.warn('overriding adapter!',OP,value);\n\t\t};\n\t\t\n\t\treturn OP = value;\n\t}\n});\nexport class OPAdapter extends Component {\n\t\n\t\n\tstatic inherited(subclass){\n\t\t\n\t\treturn OPAdapter.Main = subclass;\n\t}\n\t\n\t[$setForType$](type){\n\t\t\n\t\t// Use index instead of iterable?\n\t\treturn this.$$sets[type.name] ||= new Index(this,type,true);\n\t}\n\t\n\t[$setsForType$](type){\n\t\t\n\t\tlet root = type.root;\n\t\tlet res = [];\n\t\twhile (type){\n\t\t\t\n\t\t\tres.push(this[$setForType$](type));\n\t\t\tif (type == root) { break; };\n\t\t\tlet par = type.parent;\n\t\t\ttype = par;\n\t\t\tif (par?.abstract) {\n\t\t\t\t\n\t\t\t\ttype = par.parent;\n\t\t\t};\n\t\t};\n\t\t\n\t\treturn res;\n\t}\n\t\n\tregister(item){\n\t\t\n\t\tlet sets = this[$setsForType$](item.$type);\n\t\tfor (let $2 = 0, $3 = iter$__(sets), $4 = $3.length; $2 < $4; $2++) {\n\t\t\tlet set = $3[$2];\n\t\t\tset.push(item);\n\t\t};\n\t\t// models.push(item)\n\t\treturn this;\n\t}\n\t\n\tderegister(item){\n\t\t\n\t\tlet sets = this[$setsForType$](item.$type);\n\t\tfor (let $5 = 0, $6 = iter$__(sets), $7 = $6.length; $5 < $7; $5++) {\n\t\t\tlet set = $6[$5];\n\t\t\tset.delete(item);\n\t\t};\n\t\treturn this;\n\t}\n\t\n\tall(query = OPObject){\n\t\t\n\t\t// models only\n\t\tif (query?.root == OPObject) {\n\t\t\t\n\t\t\tlet set = this[$setForType$](query);\n\t\t\treturn set;\n\t\t};\n\t}\n\t\n\tclone(item){\n\t\t\n\t\treturn globalThis.structuredClone(item);\n\t}\n\t\n\tget $$plain(){\n\t\t\n\t\tconsole.warn(`$$plain deprecated - use $cloud`);\n\t\treturn this.$cloud;\n\t}\n\t\n\tget $$rich(){\n\t\t\n\t\tconsole.warn(`$$rich deprecated - use $rich`);\n\t\treturn this.$rich;\n\t}\n\t\n\tconstructor(){\n\t\tvar self;\n\t\t\n\t\tsuper(...arguments);self = this;\n\t\t\n\t\t/**@type {{ [key: string]: TOPData }}*/ this.$cloud = {};\n\t\t/**@type {{ [key: string]: OPObject }}*/ this.$rich = {};\n\t\t/**@type {{ [key: string]: Index }}*/ this.$$sets = {};\n\t\t\n\t\t// The map\n\t\tOP = this;\n\t\tthis.compare = compare;\n\t\tthis.t0 = Date.now();\n\t\tthis.id = 0;\n\t\tthis.debug = false;\n\t\tthis.symbol = Symbol();\n\t\tthis.options = {};\n\t\tthis.rolemap = {};\n\t\tthis.node = null;\n\t\tthis.server = null;\n\t\tthis.client = null;\n\t\tthis.sentΞmessages = new Map;\n\t\t// Array of all sent messages - only used for testing now\n\t\tthis.$sent = [];\n\t\t\n\t\tthis.resolvable(async function() {\n\t\t\t\n\t\t\treturn await self.finalize();\n\t\t});\n\t\tthis;\n\t\tthis[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\tset node(val){\n\t\t\n\t\tif ((this[$node$] != val) ? ((this[$node$] = val,true)) : false) {\n\t\t\t\n\t\t\t// remove old controller?\n\t\t\tif (val) { Object.defineProperty(val,'$handler',{value: this,writable: true}) };\n\t\t};\n\t}\n\t\n\tget mapping(){\n\t\t\n\t\treturn OPObjectRegistry;\n\t}\n\t\n\tget node(){\n\t\t\n\t\treturn this[$node$];\n\t}\n\t\n\tfinalize(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tsetup(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tget tables(){\n\t\t\n\t\treturn OPObject.types.filter(function(_0) { return _0.table == _0 && !(_0.key.virtual); });\n\t}\n\t\n\tfilter(...o){\n\t\t\n\t\treturn OPObject.filter(...o);\n\t}\n\t\n\tfind(...o){\n\t\t\n\t\treturn OPObject.find(...o);\n\t}\n\t\n\tget random(){\n\t\t\n\t\treturn random;\n\t}\n\t\n\tget stack(){\n\t\t\n\t\treturn STACK;\n\t}\n\t\n\tget Object(){\n\t\t\n\t\treturn OPObject;\n\t}\n\t\n\tput(model){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tfetch(...items){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpack(item){\n\t\t\n\t\treturn msgpack.pack(item);\n\t}\n\t\n\tunpack(item){\n\t\t\n\t\treturn msgpack.unpack(item);\n\t}\n\t\n\tvalueOf(){\n\t\t\n\t\treturn this.id;\n\t}\n\t\n\tget msgpack(){\n\t\t\n\t\treturn msgpack;\n\t}\n\t\n\t// not used?\n\ttypeof(id){\n\t\t\n\t\tlet parsed = OPKey.decode(id,this.mapping);\n\t\treturn parsed.type;\n\t}\n\t\n\tgetType(id){\n\t\t\n\t\treturn OPObject.getType(id);\n\t}\n\t\n\t/**\n\t@param {Message} msg\n\t*/\n\tasync $handle(msg,from,to){\n\t\t\n\t\t// what to do if it is a serialization?\n\t\t\n\t\tif (!((msg instanceof Message))) {\n\t\t\t\n\t\t\treturn;\n\t\t};\n\t\t\n\t\tlet target;\n\t\tlet handler;\n\t\tlet desc;\n\t\t\n\t\tif (msg.responseΦ) {\n\t\t\t\n\t\t\tlet req = this.sentΞmessages.get(-msg.ref);\n\t\t\tlet val = msg.value;\n\t\t\t\n\t\t\tif (req) {\n\t\t\t\t\n\t\t\t\t(val instanceof Error) ? req.$reject(val) : req.$resolve(val);\n\t\t\t};\n\t\t\treturn;\n\t\t};\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\ttarget = msg.target || this.node;\n\t\t\thandler = target?.$handler;\n\t\t\tdesc = target?.$shape?.[msg.action];\n\t\t\t\n\t\t\tif (handler == this) {\n\t\t\t\t\n\t\t\t\t// need to include the source and destination here for sure\n\t\t\t\tlet returning = await this.$call(desc,target,msg.params,from);\n\t\t\t\t// p `called msg {msg.$src}`\n\t\t\t\tif (returning != undefined) {\n\t\t\t\t\t\n\t\t\t\t\treturn returning;\n\t\t\t\t};\n\t\t\t} else if (handler) {\n\t\t\t\t\n\t\t\t\thandler.$handle(msg,from,to);\n\t\t\t};\n\t\t\treturn undefined;\n\t\t} catch (e) {\n\t\t\t\n\t\t\tconsole.log(`error in $handle`,e);\n\t\t\tthrow e;\n\t\t};\n\t}\n\t\n\tasync $call(desc,target,params,caller = null){\n\t\t\n\t\tlet fn = desc.callback;\n\t\tlet res = await fn.apply(target,params);\n\t\treturn res;\n\t}\n\t\n\t$parse(value,src){\n\t\t\n\t\t\n\t\tif (value instanceof ArrayBuffer) {\n\t\t\t\n\t\t\tvalue = new Uint8Array(value);\n\t\t};\n\t\t\n\t\tif (value instanceof Uint8Array) {\n\t\t\t\n\t\t\treturn msgpack.unpackSafe(value);\n\t\t};\n\t\treturn value;\n\t}\n\t\n\t$pack(value,context){\n\t\t\n\t\tif (value.$raw) {\n\t\t\t\n\t\t\treturn value.$raw;\n\t\t};\n\t\t\n\t\treturn msgpack.pack(value,context);\n\t}\n\t\n\tget(data){\n\t\t\n\t\treturn OPObject.get(data);\n\t}\n\t\n\tget context(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tget pov(){\n\t\t\n\t\tthrow \"Adapter pov not implemented\";\n\t\treturn this.context.pov;\n\t}\n\t\n\tget user(){\n\t\t\n\t\tthrow \"Adapter user not implemented\";\n\t\treturn this.pov?.user;\n\t}\n\t\n\tget agent(){\n\t\t\n\t\tthrow \"Adapter agent not implemented\";\n\t\treturn this.pov?.user || this.pov;\n\t}\n\t\n\trpc(cb){\n\t\t\n\t\treturn STACK;\n\t}\n\t\n\tasync trace(cb){\n\t\t\n\t\tlet prev = STACK.debug;\n\t\tSTACK.debug = true;\n\t\tlet res = cb();\n\t\tif (res?.then) {\n\t\t\t\n\t\t\tawait res;\n\t\t};\n\t\tSTACK.debug = prev;\n\t\treturn res;\n\t}\n\t\n\t$patch(data,source,ctx = this.context){\n\t\t\n\t\tlet id = data.id;\n\t\tlet raw = this.$cloud[id];\n\t\tlet found = this.$rich[id];\n\t\t// depends on source of patch?\n\t\t\n\t\tif (found) {\n\t\t\t\n\t\t\treturn found.$patch(data);\n\t\t} else {\n\t\t\t\n\t\t\t// this is for awakening without calling $patch\n\t\t\tthis.$cloud[id] ||= data;\n\t\t\t// update the raw data\n\t\t\tif (raw && raw != data) {\n\t\t\t\t\n\t\t\t\tObject.assign(raw,data);\n\t\t\t};\n\t\t\tlet item = OPObject.get(id,ctx);\n\t\t\treturn item;\n\t\t};\n\t}\n\t\n\trole(bit,params,check){\n\t\t\n\t\tlet nr = 1 << bit;\n\t\tlet existing = this.rolemap[nr];\n\t\tif (existing) {\n\t\t\t\n\t\t\treturn existing;\n\t\t};\n\t\t\n\t\t// params.tester = check if check\n\t\tlet kls = this.Role;// ??= mapping.role\n\t\tlet role = kls.bit(bit,params);\n\t\t\n\t\tkls[nr] = role;\n\t\t\n\t\tif (check) {\n\t\t\t\n\t\t\trole.check = check;\n\t\t\t// if we have to call a function for every user<->item combination\n\t\t\t// add this to a special list - for optimizations.\n\t\t\tif (check.length > 1) {\n\t\t\t\t\n\t\t\t\tthis.conditionalΞroles ||= new Index;\n\t\t\t\tthis.conditionalΞroles.add(role);\n\t\t\t};\n\t\t};\n\t\t\n\t\tthis.roles.incr(role);\n\t\treturn role;\n\t}\n\t\n\tget GUEST(){\n\t\t\n\t\treturn this.role(0,{name: 'GUEST'});\n\t}\n\t\n\tget MEMBER(){\n\t\t\n\t\treturn this.role(1,{name: 'MEMBER'});\n\t}\n\t\n\tget OWNER(){\n\t\t\n\t\treturn this.role(2,{name: 'OWNER'});\n\t}\n\t\n\tget MODERATOR(){\n\t\t\n\t\treturn this.role(3,{name: 'MODERATOR'});\n\t}\n\t\n\tget CREATOR(){\n\t\t\n\t\treturn this.role(4,{name: 'CREATOR'});\n\t}\n\t\n\tget ANYONE(){\n\t\t\n\t\treturn this.User.any;\n\t}\n\t\n\tget NOONE(){\n\t\t\n\t\treturn this.role(28,{name: 'NOONE'});\n\t}\n\t\n\tget SRV(){\n\t\t\n\t\treturn this.role(29,{name: 'SRV'});\n\t}\n\t\n\tget ADMIN(){\n\t\t\n\t\treturn this.role(30,{name: 'ADMIN'});\n\t}\n\t\n\tencodeURIComponent(data){\n\t\tvar self = this;\n\t\t\n\t\tif (data instanceof Iterable) {\n\t\t\t\n\t\t\treturn data.map(function(_0) { return self.encodeURIComponent(_0); }).join('~');\n\t\t} else if (data instanceof OPObject) {\n\t\t\t\n\t\t\treturn data.id;\n\t\t} else {\n\t\t\t\n\t\t\treturn '';\n\t\t};\n\t}\n\t// Should rather be controlled by the field?\n\tdecodeURIComponent(data){\n\t\tvar self = this;\n\t\t\n\t\tif (data.indexOf('~') >= 0) {\n\t\t\t\n\t\t\treturn data.split('~').map(function(_0) { return self.decodeURIComponent(_0); });\n\t\t} else {\n\t\t\t\n\t\t\t// if there is a key--\n\t\t\treturn OPObject.get(data);\n\t\t};\n\t}\n\t\n\tget roles(){\n\t\t\n\t\treturn new Index;\n\t}\n\t\n\tasync trace(cb){\n\t\t\n\t\tlet prev = STACK.debug;\n\t\tSTACK.debug = true;\n\t\tlet res = cb();\n\t\tif (res?.then) {\n\t\t\t\n\t\t\tawait res;\n\t\t};\n\t\tSTACK.debug = prev;\n\t\treturn res;\n\t}\n\t\n\tget READ(){\n\t\treturn R;\n\t}\n\tget WRITE(){\n\t\treturn W;\n\t}\n\tget DELETE(){\n\t\treturn D;\n\t}\n\tget CREATE(){\n\t\treturn W;\n\t}\n\t\n\t// Create rich object from raw data\n\tcreate(data){\n\t\t\n\t\tlet typ = data.id && this.getType(data.id);\n\t\tif (!(typ)) {\n\t\t\t\n\t\t\tthrow `cannot create object without valid id`;\n\t\t};\n\t\treturn typ.create(data);\n\t\t// await item\n\t\t// return item\n\t\t// return typ.create(data)\n\t}\n\t\n\ttest(role,against,exact = true){\n\t\t\n\t\tlet typ = typeof against;\n\t\tif (typ == 'number') {\n\t\t\t\n\t\t\tlet m = (role & against);\n\t\t\treturn exact ? ((m == against)) : ((m > 0));\n\t\t};\n\t\treturn false;\n\t}\n\t\n\t// calculate the rights for a certain model/field/embedded object\n\t// for a user. Flexible - can take many different arguments\n\t// async?\n\t// TODO rename to rwx?\n\trights(data,key,agent = this.agent){\n\t\t\n\t\tif (!(data)) { return null };\n\t\t\n\t\tlet bits = 0;\n\t\t// building out as we go - first getting example to work\n\t\tif (data instanceof Iterable) {\n\t\t\t\n\t\t\t// use $up and $key instead?\n\t\t\treturn this.rights(data.owner,data.field,agent);\n\t\t};\n\t\t\n\t\tif (data instanceof OPPov) {\n\t\t\t\n\t\t\tif (agent == data.$key) { return RW };\n\t\t};\n\t\t\n\t\t// This is not checking the parents\n\t\tif (data == agent) {\n\t\t\t\n\t\t\treturn RW;\n\t\t};\n\t\t\n\t\t// bound field?\n\t\tif (data instanceof OPField) {\n\t\t\t\n\t\t\tif (data.$target) {\n\t\t\t\t\n\t\t\t\tkey = data;\n\t\t\t\tdata = key.$target;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tconsole.warn(`cannot get rights to unbound field`);\n\t\t\t};\n\t\t};\n\t\t\n\t\tlet shape = data?.$shape;\n\t\t// this is a model\n\t\tif (shape) {\n\t\t\t\n\t\t\tlet field = key || 'id';\n\t\t\tif (typeof field == 'string') {\n\t\t\t\t\n\t\t\t\tfield = shape[field];\n\t\t\t};\n\t\t\t\n\t\t\t// should not expect user but rather client?\n\t\t\tlet roles = data?.rolesΞfor?.(agent) || 0;\n\t\t\tlet base = !(field.pov) && shape.id || {W: null,R: null};\n\t\t\t\n\t\t\tif (field) {\n\t\t\t\t\n\t\t\t\tlet fr = ((field.R ?? base.R));\n\t\t\t\tlet fw = ((field.W ?? base.W));\n\t\t\t\t\n\t\t\t\tif (fr === fw && fw === null) { return RW };\n\t\t\t\t\n\t\t\t\tlet r = (fr instanceof Function) ? fr.call(data) : ((fr == 0 || fr & roles));\n\t\t\t\tlet w = (fw instanceof Function) ? fw.call(data) : ((fw == 0 || fw & roles));\n\t\t\t\t// let r = R & roles\n\t\t\t\t// let w = W & roles\n\t\t\t\t\n\t\t\t\tif (field.R && !(r)) { return 0 };\n\t\t\t\t\n\t\t\t\tif (w) { bits |= RW };\n\t\t\t\tif (r) { bits |= R };\n\t\t\t};\n\t\t\t\n\t\t\treturn bits;\n\t\t};\n\t\t\n\t\t// if the data is not an OP model type - always treat it as writable\n\t\treturn RW;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;this.prototype[$__hooks__$] = imba_hooks;\n\t\tdefineName$__(this,'OPAdapter');decorate$__([imba_αlazy.bind([])],this.prototype,'GUEST',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'MEMBER',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'OWNER',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'MODERATOR',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'CREATOR',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'ANYONE',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'NOONE',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'SRV',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'ADMIN',null);\n\t\tdecorate$__([imba_αlazy.bind([])],this.prototype,'roles',null);\n\t\tinheritClass$__(this);}\n}; globalThis.OPAdapter = OPAdapter;\n","dependencies":[],"map":{"version":3,"file":"adapter.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/core/adapter.imba"],"sourcesContent":["\nimport { STACK } from '../stack'\nimport { Message, R, W, D, RW } from '../protocol'\nimport { Iterable, Index } from './iterable'\nimport { Component } from '../component'\nimport * as msgpack from '../msgpack'\nimport { compare, random } from '../utils'\n\nlet OP = null\n\n# let AdapterInstance\n# workaround to hide this from Typescript tooling\n# All this should go in adapter\nconst opname = String.fromCharCode(79,80)\n\nObject.defineProperty(global,opname,{\n\tget: do\n\t\tOP ||= new (OPAdapter.Main or OPAdapter)\n\n\tset: do(value)\n\t\tif OP and OP != value\n\t\t\tconsole.warn('overriding adapter!',OP,value)\n\n\t\tOP = value\n})\nexport global class OPAdapter < Component\n\n\tdeclare User\\(typeof OPUser)\n\tdeclare Client\\(typeof OPClient)\n\tdeclare Server\\(typeof OPServer)\n\tdeclare Worker\\(typeof OPWorker)\n\tdeclare Job\\(typeof OPJob)\n\tdeclare Role\\(typeof OPRole)\n\tdeclare Session\\(typeof OPSession)\n\tdeclare Image\\(typeof OPImage)\n\tdeclare Blob\\(typeof OPBlob)\n\tdeclare conditional-roles\\OPRole[]\n\n\tstatic def inherited subclass\n\t\tOPAdapter.Main = subclass\n\n\tdef #setForType type\n\t\t# Use index instead of iterable?\n\t\t$$sets[type.name] ||= new Index(self,type,yes)\n\n\tdef #setsForType type\n\t\tlet root = type.root\n\t\tlet res = []\n\t\twhile type\n\t\t\tres.push(#setForType(type))\n\t\t\tbreak if type == root\n\t\t\tlet par = type.parent\n\t\t\ttype = par\n\t\t\tif par..abstract\n\t\t\t\ttype = par.parent\n\n\t\treturn res\n\n\tdef register item\n\t\tlet sets = #setsForType(item.$type)\n\t\tfor set in sets\n\t\t\tset.push(item)\n\t\t# models.push(item)\n\t\tself\n\n\tdef deregister item\n\t\tlet sets = #setsForType(item.$type)\n\t\tfor set in sets\n\t\t\tset.delete(item)\n\t\tself\n\n\tdef all query = OPObject\n\t\t# models only\n\t\tif query..root == OPObject\n\t\t\tlet set = #setForType(query)\n\t\t\treturn set\n\n\tdef clone item\n\t\tglobal.structuredClone(item)\n\n\tget $$plain\n\t\tconsole.warn `$$plain deprecated - use $cloud`\n\t\t$cloud\n\n\tget $$rich\n\t\tconsole.warn `$$rich deprecated - use $rich`\n\t\t$rich\n\n\tdef constructor\n\t\tsuper\n\n\t\t$cloud\\{ [key: string]: TOPData } = {}\n\t\t$rich\\{ [key: string]: OPObject } = {}\n\t\t$$sets\\{ [key: string]: Index } = {}\n\n\t\t# The map\n\t\tOP = self\n\t\tcompare = compare\n\t\tt0 = Date.now!\n\t\tid = 0\n\t\tdebug = no\n\t\tsymbol = Symbol!\n\t\toptions = {}\n\t\trolemap = {}\n\t\tnode = null\n\t\tserver = null\n\t\tclient = null\n\t\tsent-messages = new Map\n\t\t# Array of all sent messages - only used for testing now\n\t\t$sent = []\n\n\t\tresolvable do\n\t\t\tawait finalize!\n\t\tself\n\n\tset node val\n\t\tif #node =? val\n\t\t\t# remove old controller?\n\t\t\tObject.defineProperty(val,'$handler',value: self, writable: yes) if val\n\n\tget mapping\n\t\tOPObjectRegistry\n\n\tget node\n\t\t#node\n\n\tdef finalize\n\t\tyes\n\n\tdef setup\n\t\tyes\n\n\tget tables\n\t\tOPObject.types.filter do $1.table == $1 and !$1.key.virtual\n\n\tdef filter ...o\n\t\tOPObject.filter(...o)\n\n\tdef find ...o\n\t\tOPObject.find(...o)\n\n\tget random\n\t\trandom\n\n\tget stack\n\t\tSTACK\n\n\tget Object\n\t\tOPObject\n\n\tdef put model\n\t\tyes\n\n\tdef fetch ...items\n\t\tyes\n\n\tdef pack item\n\t\tmsgpack.pack(item)\n\n\tdef unpack item\n\t\tmsgpack.unpack(item)\n\n\tdef valueOf\n\t\tid\n\n\tget msgpack\n\t\tmsgpack\n\n\t# not used?\n\tdef typeof id\n\t\tlet parsed = OPKey.decode(id,mapping)\n\t\tparsed.type\n\n\tdef getType id\n\t\tOPObject.getType(id)\n\n\tdef $handle msg\\Message, from, to\n\t\t# what to do if it is a serialization?\n\n\t\tunless msg isa Message\n\t\t\treturn\n\n\t\tlet target\n\t\tlet handler\n\t\tlet desc\n\n\t\tif msg.response?\n\t\t\tlet req = sent-messages.get(-msg.ref)\n\t\t\tlet val = msg.value\n\n\t\t\tif req\n\t\t\t\tval isa Error ? req.$reject(val) : req.$resolve(val)\n\t\t\treturn\n\n\t\ttry\n\t\t\ttarget = msg.target or node\n\t\t\thandler = target..$handler\n\t\t\tdesc = target..$shape..[msg.action]\n\n\t\t\tif handler == self\n\t\t\t\t# need to include the source and destination here for sure\n\t\t\t\tlet returning = await $call(desc,target,msg.params,from)\n\t\t\t\t# p `called msg {msg.$src}`\n\t\t\t\tif returning != undefined\n\t\t\t\t\treturn returning\n\n\t\t\telif handler\n\t\t\t\thandler.$handle(msg,from,to)\n\t\t\treturn undefined\n\t\tcatch e\n\t\t\tconsole.log `error in $handle`,e\n\t\t\tthrow e\n\n\tdef $call desc, target, params, caller = null\n\t\tlet fn = desc.callback\n\t\tlet res = await fn.apply(target,params)\n\t\treturn res\n\n\tdef $parse value,src\n\n\t\tif value isa ArrayBuffer\n\t\t\tvalue = new Uint8Array(value)\n\n\t\tif value isa Uint8Array\n\t\t\treturn msgpack.unpackSafe(value)\n\t\treturn value\n\n\tdef $pack value,context\n\t\tif value.$raw\n\t\t\treturn value.$raw\n\n\t\treturn msgpack.pack(value,context)\n\n\tdef get data\n\t\tOPObject.get(data)\n\n\tget context\n\t\tself\n\n\tget pov\n\t\tthrow \"Adapter pov not implemented\"\n\t\tcontext.pov\n\n\tget user\n\t\tthrow \"Adapter user not implemented\"\n\t\tpov..user\n\n\tget agent\n\t\tthrow \"Adapter agent not implemented\"\n\t\tpov..user or pov\n\n\tdef rpc cb\n\t\tSTACK\n\n\tdef trace cb\n\t\tlet prev = STACK.debug\n\t\tSTACK.debug = yes\n\t\tlet res = cb()\n\t\tif res..then\n\t\t\tawait res\n\t\tSTACK.debug = prev\n\t\treturn res\n\n\tdef $patch data, source, ctx = self.context\n\t\tlet id = data.id\n\t\tlet raw = $cloud[id]\n\t\tlet found = $rich[id]\n\t\t# depends on source of patch?\n\n\t\tif found\n\t\t\tfound.$patch(data)\n\t\telse\n\t\t\t# this is for awakening without calling $patch\n\t\t\t$cloud[id] ||= data\n\t\t\t# update the raw data\n\t\t\tif raw and raw != data\n\t\t\t\tObject.assign(raw,data)\n\t\t\tlet item = OPObject.get(id,ctx)\n\t\t\treturn item\n\n\tdef role bit,params,check\n\t\tlet nr = 1 << bit\n\t\tlet existing = rolemap[nr]\n\t\tif existing\n\t\t\treturn existing\n\n\t\t# params.tester = check if check\n\t\tlet kls = self.Role # ??= mapping.role\n\t\tlet role = kls.bit(bit,params)\n\n\t\tkls[nr] = role\n\n\t\tif check\n\t\t\trole.check = check\n\t\t\t# if we have to call a function for every user<->item combination\n\t\t\t# add this to a special list - for optimizations.\n\t\t\tif check.length > 1\n\t\t\t\tconditional-roles ||= new Index\n\t\t\t\tconditional-roles.add(role)\n\n\t\troles.incr(role)\n\t\treturn role\n\n\t@lazy get GUEST\n\t\trole(0,{name:'GUEST'})\n\n\t@lazy get MEMBER\n\t\trole(1,{name:'MEMBER'})\n\n\t@lazy get OWNER\n\t\trole(2,{name:'OWNER'})\n\n\t@lazy get MODERATOR\n\t\trole(3,{name:'MODERATOR'})\n\n\t@lazy get CREATOR\n\t\trole(4,{name:'CREATOR'})\n\n\t@lazy get ANYONE\n\t\tself.User.any\n\n\t@lazy get NOONE\n\t\trole(28,{name:'NOONE'})\n\n\t@lazy get SRV\n\t\trole(29,{name:'SRV'})\n\n\t@lazy get ADMIN\n\t\trole(30,{name:'ADMIN'})\n\n\tdef encodeURIComponent data\n\t\tif data isa Iterable\n\t\t\tdata.map(do self.encodeURIComponent($1)).join('~')\n\t\telif data isa OPObject\n\t\t\tdata.id\n\t\telse\n\t\t\t''\n\t# Should rather be controlled by the field?\n\tdef decodeURIComponent data\n\t\tif data.indexOf('~') >= 0\n\t\t\treturn data.split('~').map do self.decodeURIComponent($1)\n\t\telse\n\t\t\t# if there is a key--\n\t\t\tOPObject.get(data)\n\n\t@lazy get roles\n\t\tnew Index\n\n\tdef trace cb\n\t\tlet prev = STACK.debug\n\t\tSTACK.debug = yes\n\t\tlet res = cb()\n\t\tif res..then\n\t\t\tawait res\n\t\tSTACK.debug = prev\n\t\treturn res\n\n\tget READ do R\n\tget WRITE do W\n\tget DELETE do D\n\tget CREATE do W\n\n\t# Create rich object from raw data\n\tdef create data\n\t\tlet typ = data.id and getType(data.id)\n\t\tunless typ\n\t\t\tthrow `cannot create object without valid id`\n\t\ttyp.create(data)\n\t\t# await item\n\t\t# return item\n\t\t# return typ.create(data)\n\n\tdef test role, against, exact = yes\n\t\tlet typ = typeof against\n\t\tif typ == 'number'\n\t\t\tlet m = (role & against)\n\t\t\treturn exact ? (m == against) : (m > 0)\n\t\treturn no\n\n\t# calculate the rights for a certain model/field/embedded object\n\t# for a user. Flexible - can take many different arguments\n\t# async?\n\t# TODO rename to rwx?\n\tdef rights data,key,agent = self.agent\n\t\treturn null unless data\n\n\t\tlet bits = 0\n\t\t# building out as we go - first getting example to work\n\t\tif data isa Iterable\n\t\t\t# use $up and $key instead?\n\t\t\treturn rights(data.owner,data.field,agent)\n\n\t\tif data isa OPPov\n\t\t\treturn RW if agent == data.$key\n\n\t\t# This is not checking the parents\n\t\tif data == agent\n\t\t\treturn RW\n\n\t\t# bound field?\n\t\tif data isa OPField\n\t\t\tif data.$target\n\t\t\t\tkey = data\n\t\t\t\tdata = key.$target\n\t\t\telse\n\t\t\t\tconsole.warn `cannot get rights to unbound field`\n\n\t\tlet shape = data..$shape\n\t\t# this is a model\n\t\tif shape\n\t\t\tlet field = key or 'id'\n\t\t\tif typeof field == 'string'\n\t\t\t\tfield = shape[field]\n\n\t\t\t# should not expect user but rather client?\n\t\t\tlet roles = data..roles-for(agent) or 0\n\t\t\tlet base = !field.pov and shape.id or {W:null,R:null}\n\n\t\t\tif field\n\t\t\t\tlet fr = (field.R ?? base.R)\n\t\t\t\tlet fw = (field.W ?? base.W)\n\n\t\t\t\treturn RW if fr === fw === null\n\n\t\t\t\tlet r = fr isa Function ? fr.call(data) : (fr == 0 or fr & roles)\n\t\t\t\tlet w = fw isa Function ? fw.call(data) : (fw == 0 or fw & roles)\n\t\t\t\t# let r = R & roles\n\t\t\t\t# let w = W & roles\n\n\t\t\t\treturn 0 if field.R && !r\n\n\t\t\t\tbits |= RW if w\n\t\t\t\tbits |= R if r\n\n\t\t\treturn bits\n\n\t\t# if the data is not an OP model type - always treat it as writable\n\t\treturn RW\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
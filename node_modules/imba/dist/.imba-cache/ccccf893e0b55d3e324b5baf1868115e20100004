{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};\nconst $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $$reactive$ = Symbol.for('##reactive'), $$referenced$ = Symbol.for('##referenced'), $$dereferenced$ = Symbol.for('##dereferenced'), $map$ = Symbol.for('#map'), $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $child$ = Symbol.for('#child'), $reactions$ = Symbol.for('#reactions'), $promise$ = Symbol.for('#promise');\n\n/*body*/\nimport {hooks} from './hooks';\nimport {once,emit,listen} from './utils';\nimport {scheduler,commit} from './scheduler';\n\nconst F = {\n\tTOUCHING: 1 << 1,\n\tSTALE: 1 << 2,\n\tOBJECT: 1 << 3,\n\tRUNNING: 1 << 4,\n\tINVALIDATING: 1 << 5,\n\tPOSSIBLY_STALE: 1 << 6,\n\tAUTORUN: 1 << 7\n};\n\nlet TRACKING = 0;\nlet ACTIVATED = false;\nlet V = 0;\nlet RUN_ID = 0;\nlet NEXT_REF_ID = 1;\n\nconst MAPS = {\n\tMETA: new Map,\n\tVALUE: new Map,\n\tREF: new Map\n};\nconst OWNREF = Symbol.for(\"~\");\nconst METAREF = Symbol.for(\"~~\");\n\nconst SymbolForSymbol = function(sym,map) {\n\t\n\tif (!(map.has(sym))) { map.set(sym,Symbol()) };\n\treturn map.get(sym);\n};\n\nconst VALUESYM = function(name) {\n\t\n\treturn (typeof name == 'symbol') ? SymbolForSymbol(name,MAPS.VALUE) : Symbol.for(name);\n};\n\nconst METASYM = function(name) {\n\t\n\treturn (typeof name == 'symbol') ? SymbolForSymbol(name,MAPS.META) : Symbol.for((\"#\" + name + \"__\"));\n};\n\nconst REFSYM = function(name) {\n\t\n\treturn (typeof name == 'symbol') ? SymbolForSymbol(name,MAPS.REF) : Symbol.for((\"~\" + name));\n};\n\nexport const OBSERVED = function(item,res) {\n\t\n\tif (TRACKING) { CTX.add(item[OWNREF]) };\n\treturn res;\n};\n\nconst CHANGED = function(item,res) {\n\t\n\titem[OWNREF].invalidated(0);\n\treturn res;\n};\n\nconst REFERENCED = function(item,ref,extensions) {\n\t\n\tlet beacon = item[OWNREF];\n\tif (!(beacon)) {\n\t\t\n\t\tbeacon = item[OWNREF] = new Ref(F.OBJECT);\n\t\tObject.defineProperties(item,extensions);\n\t};\n\tif (ref) { beacon.addSubscriber(ref) };\n\treturn item;\n};\n\nconst DEREFERENCED = function(item,ref) {\n\t\n\tlet beacon = item[OWNREF];\n\tif (beacon) {\n\t\t\n\t\tbeacon.removeSubscriber(ref);\n\t};\n\treturn item;\n};\n\nclass ArrayPatcher {\n\t\n\tconstructor(array){\n\t\t\n\t\tthis.changes = new Map;\n\t\tthis.cleanup();\n\t\tif (array) { this.reset(array) };\n\t}\n\t\n\treset(array = []){\n\t\t\n\t\tthis.array = array;\n\t\treturn this.initialLength = array.length;\n\t}\n\t\n\tcleanup(){\n\t\t\n\t\tthis.idx = 0;\n\t\tthis.array = null;\n\t\tthis.changes.clear();\n\t\treturn this.dirty = false;\n\t}\n\t\n\tpush(item){\n\t\t\n\t\tif (this.initialLength == 0) {\n\t\t\t\n\t\t\tif (this.array.indexOf(item) < 0) {\n\t\t\t\t\n\t\t\t\tthis.changes.set(item,1);\n\t\t\t\tthis.array.push(item);\n\t\t\t\tthis.idx++;\n\t\t\t};\n\t\t\treturn;\n\t\t};\n\t\t\n\t\tlet toReplace = this.array[this.idx];\n\t\t\n\t\t// this only works if things are supposed to go in an array once\n\t\tif (toReplace === item) {\n\t\t\t\n\t\t\treturn ++this.idx;\n\t\t} else {\n\t\t\t\n\t\t\tlet prevIndex = this.array.indexOf(item);\n\t\t\tlet changed = this.changes.get(item);\n\t\t\t\n\t\t\tif (prevIndex === -1) {\n\t\t\t\t\n\t\t\t\tthis.array.splice(this.idx,0,item);\n\t\t\t\tthis.changes.set(item,1);\n\t\t\t\tthis.idx++;\n\t\t\t} else if (prevIndex === this.idx + 1) {\n\t\t\t\t\n\t\t\t\t// if the last one is simply removed\n\t\t\t\tif (toReplace) {\n\t\t\t\t\t\n\t\t\t\t\tthis.changes.set(toReplace,-1);\n\t\t\t\t};\n\t\t\t\tthis.array.splice(this.idx,1);\n\t\t\t\t++this.idx;\n\t\t\t} else if (prevIndex < this.idx) {\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif (prevIndex > this.idx) {\n\t\t\t\t\t\n\t\t\t\t\tthis.array.splice(prevIndex,1);\n\t\t\t\t};\n\t\t\t\tthis.array.splice(this.idx,0,item);\n\t\t\t};\n\t\t\t\n\t\t\tif (changed == -1) {\n\t\t\t\t\n\t\t\t\treturn this.changes.delete(item);\n\t\t\t};\n\t\t};\n\t}\n\t\n\tend(){\n\t\t\n\t\tif (this.array.length >= this.idx) {\n\t\t\t\n\t\t\twhile (this.array.length > this.idx){\n\t\t\t\t\n\t\t\t\tthis.changes.set(this.array.pop(),-1);\n\t\t\t};\n\t\t};\n\t\treturn this.array;\n\t}\n\t\n\tpatch(){\n\t\t\n\t\treturn this.end();\n\t}\n\tstatic {\n\t\tdefineName$__(this,'ArrayPatcher');}\n};\n\nfunction getExtensions(obj){\n\tvar $1, $2;\n\t\n\tlet descriptors = Object.getOwnPropertyDescriptors(obj.prototype);\n\t((($1 = descriptors.name),delete descriptors.name, $1));\n\t((($2 = descriptors.constructor),delete descriptors.constructor, $2));\n\treturn descriptors;\n};\n\nfunction activateHooks(){\n\t\n\tif (!((ACTIVATED != true) ? ((ACTIVATED = true,true)) : false)) { return };\n\t\n\treturn hooks.on('inited',function(instance) {\n\t\t\n\t\tlet meta = instance[METAREF];\n\t\tif (meta) {\n\t\t\t\n\t\t\tlet istag = instance instanceof globalThis.Node;\n\t\t\tlet obj = instance[OWNREF] ||= {};\n\t\t\tfor (let $3 = 0, $4 = Object.keys(meta), $5 = $4.length, k, v; $3 < $5; $3++){\n\t\t\t\tk = $4[$3];v = meta[k];\n\t\t\t\tlet reaction = obj[k] = new Reaction(instance[k],instance,v);\n\t\t\t\tif (!(istag)) { reaction.call() };\n\t\t\t};\n\t\t\t\n\t\t\tif (istag) {\n\t\t\t\t\n\t\t\t\tlisten(instance,'mount',function() {\n\t\t\t\t\tvar $6;\n\t\t\t\t\t\n\t\t\t\t\t$6 = [];\n\t\t\t\t\tfor (let $7 = 0, $8 = iter$__(Object.values(obj)), $9 = $8.length; $7 < $9; $7++) {\n\t\t\t\t\t\tlet item = $8[$7];\n\t\t\t\t\t\t$6.push((item instanceof Reaction) && item.activate());\n\t\t\t\t\t};\n\t\t\t\t\treturn $6;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tlisten(instance,'unmount',function() {\n\t\t\t\t\tvar $10;\n\t\t\t\t\t\n\t\t\t\t\t$10 = [];\n\t\t\t\t\tfor (let $11 = 0, $12 = iter$__(Object.values(obj)), $13 = $12.length; $11 < $13; $11++) {\n\t\t\t\t\t\tlet item = $12[$11];\n\t\t\t\t\t\t$10.push((item instanceof Reaction) && item.deactivate());\n\t\t\t\t\t};\n\t\t\t\t\treturn $10;\n\t\t\t\t});\n\t\t\t};\n\t\t};\n\t\treturn;\n\t});\n};\n\nfunction getSchema(target,typ = METAREF){\n\t\n\tif (!(target.hasOwnProperty(typ))) {\n\t\t\n\t\ttarget[typ] = Object.assign({},target[typ] || {});\n\t};\n\treturn target[typ];\n};\n\nclass Context {\n\t\n\tconstructor(up,depth = 0){\n\t\t\n\t\tthis.depth = depth;\n\t\tthis.parent = up;\n\t\tthis.target = null;\n\t\tthis.patcher = new ArrayPatcher;\n\t}\n\t\n\tget activeΦ(){\n\t\t\n\t\treturn CTX == this;\n\t}\n\t\n\tget rootΦ(){\n\t\t\n\t\treturn this == ROOT;\n\t}\n\t\n\tget snapshot(){\n\t\t\n\t\tlet all = [];\n\t\tlet item = this[$child$];\n\t\twhile (item && item.target){\n\t\t\t\n\t\t\tall.push({\n\t\t\t\tdepth: item.depth,\n\t\t\t\ttarget: item.target,\n\t\t\t\tbeacon: item.beacon\n\t\t\t});\n\t\t\titem = item[$child$];\n\t\t};\n\t\treturn all;\n\t}\n\t\n\treset(item){\n\t\t\n\t\tthis.tracking = true;\n\t\tthis.target = item;\n\t\tthis.beacon = item.beacon;\n\t\tthis.patcher.reset(item.observing ||= []);// nah to the action\n\t\treturn this;\n\t}\n\t\n\tadd(beacon){\n\t\t\n\t\tif (this.tracking && beacon) { return this.patcher.push(beacon) };\n\t}\n\t\n\treact(reaction){\n\t\t\n\t\treturn ROOT.reactions.add(reaction);\n\t}\n\t\n\tpush(item){\n\t\t\n\t\treturn CTX = this.child.reset(item);\n\t}\n\t\n\tpop(){\n\t\t\n\t\tlet res = null;\n\t\tif (this.beacon) {\n\t\t\t\n\t\t\tres = this.patcher.end();\n\t\t\tlet diff = this.patcher.changes;\n\t\t\tlet changes = diff.size;\n\t\t\t\n\t\t\tif (changes) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor (let [item,op] of iter$__(diff)){\n\t\t\t\t\t\n\t\t\t\t\tif (op === 1) {\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.addSubscriber(this.beacon);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.removeSubscriber(this.beacon);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\t\n\t\t// should also clear patcher etc due to memory leaks?\n\t\tthis.patcher.cleanup();\n\t\tthis.target = this.beacon = null;\n\t\tCTX = this.parent;\n\t\tif (CTX == ROOT) {\n\t\t\t\n\t\t\tROOT.flush();\n\t\t};\n\t\treturn res;\n\t}\n\t\n\tget child(){\n\t\t\n\t\treturn this[$child$] ||= new Context(this,this.depth + 1);\n\t}\n\t\n\tget reactions(){\n\t\t\n\t\treturn this[$reactions$] ||= new Set;\n\t}\n\t\n\tflush(){\n\t\t\n\t\tif (!this[$reactions$]) { return };\n\t\tlet items = this[$reactions$];\n\t\tthis[$reactions$] = null;\n\t\tfor (let reaction of iter$__(items)){\n\t\t\t\n\t\t\treaction.call();\n\t\t};\n\t\treturn;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Context');}\n};\n\nclass Root extends Context {\n\t\n\t\n\tadd(){\n\t\t\n\t\treturn true;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Root');inheritClass$__(this);}\n};\n\nlet CTX = new Root(null,0);\nlet ROOT = CTX;\n\nlet REACT = function() {\n\t\n\treturn CTX.tracking = false;\n};\n\nlet GET = function(target,key,vsym,meta,bsym) {\n\t\n\tlet val = target[vsym];\n\tlet beacon = target[bsym];\n\t\n\tif (!(beacon)) {\n\t\t\n\t\tbeacon = target[bsym] = new Ref(0,meta,val,key);\n\t};\n\t\n\tCTX.add(beacon,target);\n\treturn val;\n};\n\nlet SET = function(target,key,vsym,value,meta,bsym) {\n\t\n\tlet prev = target[vsym];\n\t\n\tif (value != prev) {\n\t\t\n\t\ttarget[vsym] = value;\n\t\tlet beacon = target[bsym];\n\t\tif (beacon) { beacon.changed(0,value,prev) };\n\t};\n\t\n\treturn;\n};\n\nclass Ref {\n\t\n\t\n\tconstructor(kind,type,val,name){\n\t\t\n\t\tthis.id = NEXT_REF_ID++;\n\t\tthis.observer = null;\n\t\tthis.observers = null;\n\t\t// name = name\n\t\t\n\t\tif (val && val[$$referenced$]) { val[$$referenced$](this) };\n\t\treturn this;\n\t}\n\t\n\tchanged(level,newValue,oldValue){\n\t\t\n\t\tRUN_ID++;\n\t\t// mixing responsibilities with deep observers?\n\t\tif (oldValue && oldValue[$$dereferenced$]) { oldValue[$$dereferenced$](this,newValue) };\n\t\tif (newValue && newValue[$$referenced$]) { newValue[$$referenced$](this,oldValue) };\n\t\t\n\t\t// change is only called here?\n\t\tif (this.observer) { this.observer.invalidated(level + 1,this,newValue,oldValue) };\n\t\t\n\t\tif (this.observers) {\n\t\t\t\n\t\t\tfor (let $14 = 0, $15 = iter$__(this.observers), $16 = $15.length; $14 < $16; $14++) {\n\t\t\t\tlet observer = $15[$14];\n\t\t\t\tobserver.invalidated(level + 1,this,newValue,oldValue);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (CTX == ROOT) {\n\t\t\t\n\t\t\tCTX.flush();\n\t\t};\n\t\treturn;\n\t}\n\t\n\tinvalidated(level,source){\n\t\t\n\t\tif (this.observer) { this.observer.invalidated(level + 1,this) };\n\t\t\n\t\tif (this.observers) {\n\t\t\t\n\t\t\tfor (let $17 = 0, $18 = iter$__(this.observers), $19 = $18.length; $17 < $19; $17++) {\n\t\t\t\tlet observer = $18[$17];\n\t\t\t\tobserver.invalidated(level + 1,this);\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (level == 0 && CTX == ROOT) {\n\t\t\t\n\t\t\tCTX.flush();\n\t\t};\n\t\treturn true;\n\t}\n\t\n\taddSubscriber(item){\n\t\t\n\t\tif (!(this.observer)) {\n\t\t\t\n\t\t\tthis.observer = item;\n\t\t} else {\n\t\t\t\n\t\t\tthis.observers ||= [];\n\t\t\tthis.observers.push(item);\n\t\t};\n\t\treturn;\n\t}\n\t\n\tremoveSubscriber(item){\n\t\t\n\t\tif (this.observer == item) {\n\t\t\t\n\t\t\treturn this.observer = null;\n\t\t};\n\t\t\n\t\tlet obs = this.observers;\n\t\tlet idx = obs.indexOf(item);\n\t\tif (idx >= 0) {\n\t\t\t\n\t\t\tobs.splice(idx,1);\n\t\t};\n\t\treturn;\n\t}\n\t\n\treportChanged(){\n\t\t\n\t\treturn this.changed(0);\n\t}\n\t\n\treportObserved(){\n\t\t\n\t\treturn CTX.add(this);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Ref');}\n};\n\nexport function createAtom(name){\n\t\n\treturn new Ref(null,null,null,name);\n};\n\n/*\nArray\n*/\n\nexport class ObservableArray extends Array {\n\t\n\t\n\tpush(){\n\t\treturn CHANGED(this,super.push(...arguments));\n\t}\n\tpop(){\n\t\treturn CHANGED(this,super.pop(...arguments));\n\t}\n\tunshift(){\n\t\treturn CHANGED(this,super.unshift(...arguments));\n\t}\n\tshift(){\n\t\treturn CHANGED(this,super.shift(...arguments));\n\t}\n\tsplice(){\n\t\treturn CHANGED(this,super.splice(...arguments));\n\t}\n\tat(){\n\t\treturn OBSERVED(this,super.at(...arguments));\n\t}\n\tmap(){\n\t\treturn OBSERVED(this,super.map(...arguments));\n\t}\n\tflatMap(){\n\t\treturn OBSERVED(this,super.flatMap(...arguments));\n\t}\n\tflat(){\n\t\treturn OBSERVED(this,super.flat(...arguments));\n\t}\n\tfilter(){\n\t\treturn OBSERVED(this,super.filter(...arguments));\n\t}\n\tfind(){\n\t\treturn OBSERVED(this,super.find(...arguments));\n\t}\n\tslice(){\n\t\treturn OBSERVED(this,super.slice(...arguments));\n\t}\n\tsort(){\n\t\treturn OBSERVED(this,super.sort(...arguments));\n\t}\n\t\n\tget len(){\n\t\treturn OBSERVED(this,this.length);\n\t}\n\t\n\tset len(value){\n\t\t\n\t\tthis.length = value;\n\t\tCHANGED(this);\n\t}\n\t\n\ttoIterable(){\n\t\t\n\t\tif (TRACKING) { CTX.add(this[OWNREF]) };\n\t\treturn this;\n\t}\n\t\n\t[Symbol.iterator](){\n\t\t\n\t\treturn OBSERVED(this,super[Symbol.iterator](...arguments));\n\t}\n\tstatic {\n\t\tdefineName$__(this,'ObservableArray');inheritClass$__(this);}\n};\n\nconst ArrayExtensions = getExtensions(ObservableArray);\n\nclass ΩArray {\n\t\n\t\n\tget len(){\n\t\t\n\t\treturn this.length;\n\t}\n\t\n\tset len(value){\n\t\t\n\t\tthis.length = value;\n\t}\n\t\n\tget [$$reactive$](){\n\t\treturn REFERENCED(this,null,ArrayExtensions);\n\t}\n\t[$$referenced$](ref){\n\t\treturn REFERENCED(this,ref,ArrayExtensions);\n\t}\n\t[$$dereferenced$](ref){\n\t\treturn DEREFERENCED(this,ref);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Array');}\n};\nextend$__(Array.prototype,ΩArray.prototype);\n;\n\n/*\nSet\n*/\n\nclass ObservableSet extends Set {\n\t\n\thas(){\n\t\treturn OBSERVED(this,super.has(...arguments));\n\t}\n\tkeys(){\n\t\treturn OBSERVED(this,super.keys(...arguments));\n\t}\n\tvalues(){\n\t\treturn OBSERVED(this,super.values(...arguments));\n\t}\n\tentries(){\n\t\treturn OBSERVED(this,super.entries(...arguments));\n\t}\n\t\n\tadd(){\n\t\treturn CHANGED(this,super.add(...arguments));\n\t}\n\tclear(){\n\t\treturn CHANGED(this,super.clear(...arguments));\n\t}\n\tdelete(){\n\t\treturn CHANGED(this,super.delete(...arguments));\n\t}\n\tstatic {\n\t\tdefineName$__(this,'ObservableSet');inheritClass$__(this);}\n};\n\nconst SetExtensions = getExtensions(ObservableSet);\n\nclass ΩSet {\n\t\n\tget [$$reactive$](){\n\t\treturn REFERENCED(this,null,SetExtensions);\n\t}\n\t[$$referenced$](ref){\n\t\treturn REFERENCED(this,ref,SetExtensions);\n\t}\n\t[$$dereferenced$](ref){\n\t\treturn DEREFERENCED(this,ref);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Set');}\n};\nextend$__(Set.prototype,ΩSet.prototype);\n;\n\n/*\nMap\n*/\n\nclass ObservableMap extends Map {\n\t\n\tget(){\n\t\treturn OBSERVED(this,super.get(...arguments));\n\t}\n\thas(){\n\t\treturn OBSERVED(this,super.has(...arguments));\n\t}\n\tkeys(){\n\t\treturn OBSERVED(this,super.keys(...arguments));\n\t}\n\tvalues(){\n\t\treturn OBSERVED(this,super.values(...arguments));\n\t}\n\tentries(){\n\t\treturn OBSERVED(this,super.entries(...arguments));\n\t}\n\t\n\tset(){\n\t\treturn CHANGED(this,super.set(...arguments));\n\t}\n\tclear(){\n\t\treturn CHANGED(this,super.clear(...arguments));\n\t}\n\tdelete(){\n\t\treturn CHANGED(this,super.delete(...arguments));\n\t}\n\tstatic {\n\t\tdefineName$__(this,'ObservableMap');inheritClass$__(this);}\n};\n\nconst MapExtensions = getExtensions(ObservableMap);\n\nclass ΩMap {\n\t\n\tget [$$reactive$](){\n\t\treturn REFERENCED(this,null,MapExtensions);\n\t}\n\t[$$referenced$](ref){\n\t\treturn REFERENCED(this,ref,MapExtensions);\n\t}\n\t[$$dereferenced$](ref){\n\t\treturn DEREFERENCED(this,ref);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Map');}\n};\nextend$__(Map.prototype,ΩMap.prototype);\n;\n\nclass PropertyType {\n\t\n\tconstructor(name,options = {}){\n\t\tvar self = this;\n\t\t\n\t\tthis.name = name;\n\t\tthis.options = options;\n\t\tconst vkey = this.key = VALUESYM(name);\n\t\tconst bkey = REFSYM(name);\n\t\t\n\t\tlet descriptor = this.descriptor = {\n\t\t\tenumerable: (options.enumerable ?? true),\n\t\t\tconfigurable: false,\n\t\t\tget: function() { return TRACKING ? GET(this,name,vkey,self,bkey) : this[vkey]; },\n\t\t\tset: function(value) {\n\t\t\t\t\n\t\t\t\treturn (TRACKING || !(!(this[bkey]))) ? SET(this,name,vkey,value,self,bkey) : ((this[vkey] = value));\n\t\t\t}\n\t\t};\n\t\t\n\t\tlet lazy = this.lazyDescriptor = {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true,\n\t\t\tget: function() {\n\t\t\t\t\n\t\t\t\tif (TRACKING) {\n\t\t\t\t\t\n\t\t\t\t\tObject.defineProperty(this,name,descriptor);\n\t\t\t\t\treturn this[name];\n\t\t\t\t};\n\t\t\t\t// not if this is the prototype\n\t\t\t\treturn this[vkey];\n\t\t\t},\n\t\t\t\n\t\t\tset: function(value) {\n\t\t\t\t\n\t\t\t\tthis[vkey] = value;\n\t\t\t\tthis[bkey] = null;\n\t\t\t\treturn Object.defineProperty(this,name,descriptor);\n\t\t\t\t// this[bkey] = (value and value.##referenced) ? new Ref(0,self,value) : null\n\t\t\t}\n\t\t};\n\t}\n\tstatic {\n\t\tdefineName$__(this,'PropertyType');}\n};\n\nclass RefIndex {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $20;\n\t\t($20 = $$[$map$]) !== undefined && (this[$map$] = $20);\n\t\t\n\t}\n\tconstructor($$ = null){\n\t\tthis[$__init__$]($$);\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $21;\n\t\tthis[$map$] = ($$ && ($21 = $$[$map$]) !== undefined) ? ($21) : (new Map);\n\t\t\n\t}\n\tfor(value){\n\t\t\n\t\tlet res = this[$map$].get(value);\n\t\tif (!(res)) { this[$map$].set(value,res = []) };\n\t\treturn res;\n\t}\n\t\n\tget(value){\n\t\t\n\t\tlet res = this.for(value);\n\t\tlet beacon = res[OWNREF];\n\t\tif (!(beacon)) { res[$$reactive$] };\n\t\tif (TRACKING) { OBSERVED(res) };\n\t\treturn res;\n\t}\n\t\n\tadd(key,member){\n\t\t\n\t\treturn this.for(key).push(member);\n\t}\n\t\n\tdelete(key,member){\n\t\t\n\t\tlet arr = this.for(key);\n\t\tlet idx = arr.indexOf(member);\n\t\tarr.splice(idx,1);\n\t\treturn;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'RefIndex');}\n};\n\nclass RefType {\n\t\n\t\n\tconstructor(name,vkey){\n\t\tvar self = this;\n\t\t\n\t\tthis.name = name;\n\t\tthis.key = vkey;\n\t\tthis.index = new RefIndex;\n\t\t\n\t\tconst bkey = REFSYM(name);\n\t\t\n\t\tlet descriptor = this.descriptor = {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: function() { return TRACKING ? GET(this,name,vkey,self,bkey) : this[vkey]; },\n\t\t\tset: function(value) {\n\t\t\t\t\n\t\t\t\tlet prev = this[vkey];\n\t\t\t\t(TRACKING || !(!(this[bkey]))) ? SET(this,name,vkey,value,self,bkey) : ((this[vkey] = value));\n\t\t\t\tif (prev != value) {\n\t\t\t\t\t\n\t\t\t\t\tif (prev) { self.index.delete(prev,this) };\n\t\t\t\t\tif (value) { return self.index.add(value,this) };\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\t\n\t\tlet lazy = this.lazyDescriptor = {\n\t\t\tset: function(value) {\n\t\t\t\t\n\t\t\t\tthis[vkey] = value;\n\t\t\t\tif (value) { self.index.add(value,this) };\n\t\t\t\tObject.defineProperty(this,name,descriptor);\n\t\t\t\treturn this[bkey] = null;\n\t\t\t\t// (value and value.##referenced) ? new Ref(0,self,value) : null\n\t\t\t}\n\t\t};\n\t}\n\t\n\twhere(value){\n\t\t\n\t\treturn this.index.get(value);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'RefType');}\n};\n\n// why not inherit from beacon?\nclass Memo {\n\t\n\tconstructor(target,func,vkey){\n\t\t\n\t\tthis.observing = null;\n\t\tthis.observers = null;\n\t\tthis.flags = 68;\n\t\tthis.target = target;\n\t\tthis.func = func;\n\t\tthis.vkey = vkey;\n\t\tthis.version = 0;\n\t\t// global.ops.push(self)\n\t}\n\t\n\tget beacon(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\taddSubscriber(item){\n\t\t\n\t\tif (!(this.observer)) {\n\t\t\t\n\t\t\tthis.observer = item;\n\t\t} else {\n\t\t\t\n\t\t\tthis.observers ||= [];\n\t\t\tthis.observers.push(item);\n\t\t};\n\t\treturn;\n\t}\n\t\n\tremoveSubscriber(item){\n\t\t\n\t\tif (this.observer == item) {\n\t\t\t\n\t\t\treturn this.observer = null;\n\t\t};\n\t\t\n\t\tlet obs = this.observers;\n\t\tlet idx = obs.indexOf(this);\n\t\tif (idx >= 0) {\n\t\t\t\n\t\t\tobs.splice(idx,1);\n\t\t};\n\t\treturn;\n\t}\n\t\n\tinvalidated(stack,source){\n\t\t\n\t\tthis.flags |= F.STALE | F.POSSIBLY_STALE;\n\t\tif (this.observer) { this.observer.invalidated(stack,this) };\n\t\t\n\t\tif (!(this.observers)) { return };\n\t\tfor (let $22 = 0, $23 = iter$__(this.observers), $24 = $23.length; $22 < $24; $22++) {\n\t\t\tlet observer = $23[$22];\n\t\t\t\n\t\t\t// these are never - they are always computeds\n\t\t\tobserver.invalidated(stack,this);\n\t\t};\n\t\treturn this;\n\t}\n\t\n\tvalue(){\n\t\t\n\t\tif (TRACKING) { CTX.add(this) };\n\t\t\n\t\tif ((this.flags & F.POSSIBLY_STALE)==0) {\n\t\t\t\n\t\t\treturn this.target[this.vkey];\n\t\t};\n\t\t\n\t\tTRACKING++;\n\t\tthis.flags |= F.RUNNING;\n\t\tCTX.push(this);\n\t\tlet res = this.func.call(this.target);\n\t\tCTX.pop(this);\n\t\tlet prev = this.target[this.vkey];\n\t\tthis.target[this.vkey] = res;\n\t\tthis.flags &= ~(F.STALE | F.POSSIBLY_STALE | F.RUNNING);\n\t\tif (res !== prev) {\n\t\t\t\n\t\t\tthis.version++;\n\t\t};\n\t\tTRACKING--;\n\t\treturn res;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Memo');}\n};\n\nclass ComputedType {\n\t\n\tconstructor(name,func){\n\t\t\n\t\tthis.name = name;\n\t\tconst bkey = REFSYM(name);\n\t\tconst vkey = VALUESYM(name);\n\t\t\n\t\t// could use weakmap for a bit nicer structure I guess.\n\t\tconst descriptor = this.descriptor = {\n\t\t\tenumerable: false,\n\t\t\tconfigurable: false,\n\t\t\tget: function() { return this[bkey].value(); }\n\t\t};\n\t\t\n\t\tconst lazy = this.lazyDescriptor = {\n\t\t\tenumerable: false,\n\t\t\tget: function() {\n\t\t\t\t\n\t\t\t\tlet wrapper = this[bkey] = new Memo(this,func,vkey);\n\t\t\t\tObject.defineProperty(this,name,descriptor);\n\t\t\t\treturn wrapper.value();\n\t\t\t}\n\t\t};\n\t}\n\tstatic {\n\t\tdefineName$__(this,'ComputedType');}\n};\n\nclass Reaction {\n\t\n\t\n\tget beacon(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tconstructor(cb,context,options = {}){\n\t\t\n\t\tthis.cb = cb;\n\t\tthis.context = context;\n\t\tthis.options = options;\n\t\tthis.flags = 0;\n\t\tthis.id = NEXT_REF_ID++;\n\t\tthis.cachedComputedVersions = new WeakMap;\n\t\tthis.checkComputedValues = new Set;\n\t\tthis.observing = [];\n\t\tthis.timeout = null;\n\t}\n\t\n\tget runningΦ(){\n\t\t\n\t\treturn this.flags & F.RUNNING;\n\t}\n\t\n\tinvalidated(stack,source){\n\t\t\n\t\tif (source instanceof Memo) {\n\t\t\t\n\t\t\tthis.flags |= F.POSSIBLY_STALE;\n\t\t\tthis.checkComputedValues.add(source);\n\t\t} else {\n\t\t\t\n\t\t\tthis.flags |= F.STALE;\n\t\t};\n\t\t\n\t\treturn CTX.react(this);\n\t}\n\t\n\tactivate(){\n\t\t\n\t\tthis.observing = [];\n\t\tthis.cachedComputedVersions = new WeakMap;\n\t\tthis.checkComputedValues = new Set;\n\t\tthis.call();\n\t\treturn this;\n\t}\n\t\n\tdeactivate(){\n\t\t\n\t\tif (this.timeout) { clearTimeout(this.timeout) };\n\t\tif (this.observing) {\n\t\t\t\n\t\t\tfor (let $25 = 0, $26 = iter$__(this.observing), $27 = $26.length; $25 < $27; $25++) {\n\t\t\t\tlet item = $26[$25];\n\t\t\t\titem.removeSubscriber(this);\n\t\t\t};\n\t\t};\n\t\tthis.observing = this.checkComputedValues = this.cachedComputedVersions = null;\n\t\treturn this;\n\t}\n\t\n\tcall(){\n\t\tvar self = this;\n\t\t\n\t\tif (TRACKING) {\n\t\t\t\n\t\t\t// only do this to detect infinite loops somehow?\n\t\t\tconsole.warn('should not call reaction inside an autorunning context?',ROOT.snapshot);\n\t\t\t// this shouldnt _always_ be the case though?\n\t\t\t// return\n\t\t};\n\t\t\n\t\tif (this.flags & F.POSSIBLY_STALE && (this.flags & F.STALE)==0) {\n\t\t\t\n\t\t\tlet stale = false;\n\t\t\tfor (let value of iter$__(this.checkComputedValues)){\n\t\t\t\t\n\t\t\t\tlet v0 = this.cachedComputedVersions.get(value);\n\t\t\t\tvalue.value();\n\t\t\t\tlet v1 = value.version;\n\t\t\t\tif (v0 != v1) {\n\t\t\t\t\t\n\t\t\t\t\tstale = true;break;\n\t\t\t\t};\n\t\t\t};\n\t\t\t\n\t\t\tif (!(stale)) {\n\t\t\t\t\n\t\t\t\tthis.flags &= ~F.POSSIBLY_STALE;\n\t\t\t\tthis.checkComputedValues.clear();\n\t\t\t\treturn;\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (this.options.delay) {\n\t\t\t\n\t\t\tclearTimeout(this.timeout);\n\t\t\tlet num = this.options.delay;\n\t\t\tif (typeof num != 'number') { num = 1000 };\n\t\t\tthis.timeout = setTimeout(function() { return self.run(); },num);\n\t\t\treturn;\n\t\t};\n\t\treturn this.run();\n\t}\n\t\n\trun(){\n\t\t\n\t\tTRACKING++;\n\t\tthis.flags |= F.RUNNING;\n\t\tlet ctx = CTX.push(this);\n\t\t// let stop\n\t\tlet res = this.cb.call(this.context,REACT);\n\t\tlet beacons = CTX.pop(this);\n\t\t\n\t\tthis.observing = beacons;\n\t\t\n\t\tthis.checkComputedValues.clear();\n\t\tfor (let $28 = 0, $29 = iter$__(beacons), $30 = $29.length; $28 < $30; $28++) {\n\t\t\tlet item = $29[$28];\n\t\t\tif (!((item instanceof Memo))) { continue; };\n\t\t\tthis.cachedComputedVersions.set(item,item.version);\n\t\t};\n\t\t\n\t\tthis.flags &= ~(F.RUNNING | F.STALE | F.POSSIBLY_STALE);\n\t\tTRACKING--;\n\t\t\n\t\tif (false && !(this.options.silent)) { commit() };\n\t\treturn res;\n\t}\n\t\n\tdispose(){\n\t\t\n\t\tthis.deactivate();\n\t\tthis.cb = this.context = this.options = null;\n\t\treturn this;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Reaction');}\n};\n\nclass Awaits extends Reaction {\n\t\n\tresolve(val){\n\t\t\n\t\tthis.deactivate();\n\t\treturn this.resolved = val;\n\t}\n\t\n\tthen(...params){\n\t\tvar self = this;\n\t\t\n\t\t\n\t\tif (this.resolved !== undefined) {\n\t\t\t\n\t\t\treturn Promise.resolve(this.resolved).then(...params);\n\t\t} else {\n\t\t\t\n\t\t\tthis[$promise$] ||= new Promise(function(_resolve) {\n\t\t\t\t\n\t\t\t\treturn self.resolve = function(val) {\n\t\t\t\t\t\n\t\t\t\t\tself.deactivate();\n\t\t\t\t\tself.resolved = val;\n\t\t\t\t\treturn _resolve(val);\n\t\t\t\t};\n\t\t\t});\n\t\t\treturn this[$promise$].then(...params);\n\t\t};\n\t}\n\t\n\trun(){\n\t\t\n\t\tTRACKING++;\n\t\tthis.flags |= F.RUNNING;\n\t\tlet ctx = CTX.push(this);\n\t\t// let stop\n\t\tlet res = this.cb.call(this.context);\n\t\tlet beacons = CTX.pop(this);\n\t\t\n\t\tthis.observing = beacons;\n\t\t\n\t\tthis.checkComputedValues.clear();\n\t\tfor (let $31 = 0, $32 = iter$__(beacons), $33 = $32.length; $31 < $33; $31++) {\n\t\t\tlet item = $32[$31];\n\t\t\tif (!((item instanceof Memo))) { continue; };\n\t\t\tthis.cachedComputedVersions.set(item,item.version);\n\t\t};\n\t\t\n\t\tthis.flags &= ~(F.RUNNING | F.STALE | F.POSSIBLY_STALE);\n\t\tTRACKING--;\n\t\t\n\t\tif (res != false && res != undefined && res != null) {\n\t\t\t\n\t\t\tthis.resolve(res);\n\t\t\tif (false && !(this.options.silent)) { commit() };\n\t\t};\n\t\treturn res;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Awaits');inheritClass$__(this);}\n};\n\nclass Action {\n\t\n\t\n\tconstructor(cb,context){\n\t\t\n\t\tthis.context = context;\n\t\tthis.cb = cb;\n\t}\n\t\n\trun(ctx = this.context,args = []){\n\t\t\n\t\tCTX.push(this);\n\t\ttry {\n\t\t\t\n\t\t\tlet res = this.cb.apply(ctx,args);\n\t\t\tCTX.pop(this);\n\t\t\treturn res;\n\t\t} catch (e) {\n\t\t\t\n\t\t\tCTX.pop(this);\n\t\t\tthrow e;\n\t\t};\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Action');}\n};\n\nexport function autorun(cb,options = {}){\n\t\n\tlet reaction = new Reaction(cb,globalThis,options);\n\treaction.call();\n\treturn reaction;\n};\n\nexport function awaits(cb,options = {}){\n\t\n\tlet reaction = new Awaits(cb,globalThis,options);\n\treaction.call();\n\treturn reaction;\n};\n\nexport function observable(object){\n\t\n\treturn object[$$reactive$];\n};\n\nexport function run(cb){\n\t\n\tlet action = new Action(cb,globalThis);\n\treturn action.run();\n};\n\nexport function reportChanged(item){\n\t\n\tif (item && item[OWNREF]) {\n\t\t\n\t\titem[OWNREF].invalidated(0);\n\t};\n\treturn item;\n};\n\nexport function reportInvalidated(item){\n\t\n\tif (item && item[OWNREF]) {\n\t\t\n\t\titem[OWNREF].invalidated(0);\n\t};\n\treturn item;\n};\n\nexport function reportObserved(item){\n\t\n\tif (item && item[OWNREF]) {\n\t\t\n\t\titem[OWNREF].reportObserved();\n\t};\n\treturn item;\n};\n\nexport function createRef(params = F.OBJECT){\n\t\n\treturn new Ref(F.OBJECT);\n};\n\nexport function αcomputed(target,name,desc){\n\t\n\tlet sym = METASYM(name);\n\tlet field = target[sym] = new ComputedType(name,desc.get);\n\treturn field.lazyDescriptor;\n};\n\nexport function αobservable(target,key,desc){\n\t\n\tlet sym = METASYM(key);\n\tlet vsym = VALUESYM(key);\n\tlet opts = this[0] || {};\n\tlet field = target[sym] = new PropertyType(key,opts);\n\t\n\tif (desc) {\n\t\t\n\t\tObject.defineProperty(target,vsym,Object.assign({},desc));\n\t\treturn field.lazyDescriptor;\n\t};\n\t\n\tObject.defineProperty(target,key,field.lazyDescriptor);\n\treturn null;\n};\n\nexport function αref(target,name,desc){\n\t\n\tlet sym = METASYM(name);\n\ttarget.constructor[name];\n\tlet field = target[sym] = new RefType(name,VALUESYM(name));\n\treturn field.lazyDescriptor;\n};\n\nexport function αautorun(target,key,desc){\n\t\n\tlet schema = getSchema(target);\n\tlet options = this[0] || {};\n\toptions.flags = F.AUTORUN;\n\tactivateHooks();\n\tschema[key] = options;\n\treturn desc;\n};\n\nexport function αaction(target,key,desc){\n\t\n\tif (desc.value) {\n\t\t\n\t\tlet action = new Action(desc.value,null);\n\t\tdesc.value = function() { return action.run(this,arguments); };\n\t};\n\treturn desc;\n};\n","dependencies":[],"map":{"version":3,"file":"reactivity.js","sourceRoot":"","sources":["/Users/sindre/repos/imba/packages/imba/src/imba/reactivity.imba"],"sourcesContent":["import {hooks} from './hooks'\nimport {once,emit,listen} from './utils'\nimport {scheduler,commit} from './scheduler'\n\nconst F = {\n\tTOUCHING: 1 << 1\n\tSTALE: 1 << 2\n\tOBJECT: 1 << 3\n\tRUNNING: 1 << 4\n\tINVALIDATING: 1 << 5\n\tPOSSIBLY_STALE: 1 << 6\n\tAUTORUN: 1 << 7\n}\n\nlet TRACKING = 0\nlet ACTIVATED = no\nlet V = 0\nlet RUN_ID = 0\nlet NEXT_REF_ID = 1\n\nconst MAPS = {\n\tMETA: new Map\n\tVALUE: new Map\n\tREF: new Map\n}\nconst OWNREF = Symbol.for(\"~\")\nconst METAREF = Symbol.for(\"~~\")\n\nconst SymbolForSymbol = do(sym,map)\n\tmap.set(sym,Symbol!) unless map.has(sym)\n\treturn map.get(sym)\n\nconst VALUESYM = do(name)\n\ttypeof name == 'symbol' ? SymbolForSymbol(name,MAPS.VALUE) : Symbol.for(name)\n\nconst METASYM = do(name)\n\ttypeof name == 'symbol' ? SymbolForSymbol(name,MAPS.META) : Symbol.for(\"#{name}__\")\n\nconst REFSYM = do(name)\n\ttypeof name == 'symbol' ? SymbolForSymbol(name,MAPS.REF) : Symbol.for(\"~{name}\")\n\nexport const OBSERVED = do(item,res)\n\tCTX.add(item[OWNREF]) if TRACKING\n\treturn res\n\nconst CHANGED = do(item,res)\n\titem[OWNREF].invalidated(0)\n\treturn res\n\nconst REFERENCED = do(item,ref,extensions)\n\tlet beacon = item[OWNREF]\n\tunless beacon\n\t\tbeacon = item[OWNREF] = new Ref(F.OBJECT)\n\t\tObject.defineProperties(item,extensions)\n\tbeacon.addSubscriber(ref) if ref\n\treturn item\n\nconst DEREFERENCED = do(item,ref)\n\tlet beacon = item[OWNREF]\n\tif beacon\n\t\tbeacon.removeSubscriber(ref)\n\treturn item\n\nclass ArrayPatcher\n\tdef constructor array\n\t\tchanges = new Map\n\t\tcleanup!\n\t\treset(array) if array\n\n\tdef reset array = []\n\t\tarray = array\n\t\tinitialLength = array.length\n\n\tdef cleanup\n\t\tidx = 0\n\t\tarray = null\n\t\tchanges.clear!\n\t\tdirty = no\n\n\tdef push item\n\t\tif initialLength == 0\n\t\t\tunless array.indexOf(item) >= 0\n\t\t\t\tchanges.set(item,1)\n\t\t\t\tarray.push(item)\n\t\t\t\tidx++\n\t\t\treturn\n\n\t\tlet toReplace = array[idx]\n\n\t\t# this only works if things are supposed to go in an array once\n\t\tif toReplace === item\n\t\t\t++idx\n\t\telse\n\t\t\tlet prevIndex = array.indexOf(item)\n\t\t\tlet changed = changes.get(item)\n\n\t\t\tif prevIndex === -1\n\t\t\t\tarray.splice(idx,0,item)\n\t\t\t\tchanges.set(item,1)\n\t\t\t\tidx++\n\n\t\t\telif prevIndex === idx + 1\n\t\t\t\t# if the last one is simply removed\n\t\t\t\tif toReplace\n\t\t\t\t\tchanges.set(toReplace,-1)\n\t\t\t\tarray.splice(idx,1)\n\t\t\t\t++idx\n\t\t\telif prevIndex < idx\n\t\t\t\treturn\n\t\t\telse\n\t\t\t\tif prevIndex > idx\n\t\t\t\t\tarray.splice(prevIndex,1)\n\t\t\t\tarray.splice(idx,0,item)\n\n\t\t\tif changed == -1\n\t\t\t\tchanges.delete(item)\n\n\tdef end\n\t\tif array.length >= idx\n\t\t\twhile array.length > idx\n\t\t\t\tchanges.set(array.pop!,-1)\n\t\treturn array\n\n\tdef patch\n\t\tend!\n\ndef getExtensions obj\n\tlet descriptors = Object.getOwnPropertyDescriptors(obj.prototype)\n\tdelete descriptors.name\n\tdelete descriptors.constructor\n\treturn descriptors\n\ndef activateHooks\n\treturn unless ACTIVATED =? yes\n\n\thooks.on('inited') do(instance)\n\t\tlet meta = instance[METAREF]\n\t\tif meta\n\t\t\tlet istag = instance isa global.Node\n\t\t\tlet obj = instance[OWNREF] ||= {}\n\t\t\tfor own k,v of meta\n\t\t\t\tlet reaction = obj[k] = new Reaction(instance[k],instance,v)\n\t\t\t\treaction.call! unless istag\n\n\t\t\tif istag\n\t\t\t\tlisten(instance,'mount') do\n\t\t\t\t\tfor item in Object.values(obj)\n\t\t\t\t\t\titem.activate! if item isa Reaction\n\n\t\t\t\tlisten(instance,'unmount') do\n\t\t\t\t\tfor item in Object.values(obj)\n\t\t\t\t\t\titem.deactivate! if item isa Reaction\n\t\treturn\n\ndef getSchema target, typ = METAREF\n\tif !target.hasOwnProperty(typ)\n\t\ttarget[typ] = Object.assign({},target[typ] or {})\n\treturn target[typ]\n\nclass Context\n\tdef constructor up, depth = 0\n\t\tdepth = depth\n\t\tparent = up\n\t\ttarget = null\n\t\tpatcher = new ArrayPatcher\n\n\tget active?\n\t\tCTX == self\n\n\tget root?\n\t\tself == ROOT\n\n\tget snapshot\n\t\tlet all = []\n\t\tlet item = #child\n\t\twhile item and item.target\n\t\t\tall.push({\n\t\t\t\tdepth: item.depth\n\t\t\t\ttarget: item.target\n\t\t\t\tbeacon: item.beacon\n\t\t\t})\n\t\t\titem = item.#child\n\t\treturn all\n\n\tdef reset item\n\t\ttracking = yes\n\t\ttarget = item\n\t\tbeacon = item.beacon\n\t\tpatcher.reset(item.observing ||= []) # nah to the action\n\t\treturn self\n\n\tdef add beacon\n\t\tpatcher.push(beacon) if tracking and beacon\n\n\tdef react reaction\n\t\tROOT.reactions.add(reaction)\n\n\tdef push item\n\t\tCTX = child.reset(item)\n\n\tdef pop\n\t\tlet res = null\n\t\tif beacon\n\t\t\tres = patcher.end!\n\t\t\tlet diff = patcher.changes\n\t\t\tlet changes = diff.size\n\n\t\t\tif changes\n\n\t\t\t\tfor [item,op] of diff\n\t\t\t\t\tif op === 1\n\t\t\t\t\t\titem.addSubscriber(beacon)\n\t\t\t\t\telse\n\t\t\t\t\t\titem.removeSubscriber(beacon)\n\n\t\t# should also clear patcher etc due to memory leaks?\n\t\tpatcher.cleanup!\n\t\ttarget = beacon = null\n\t\tCTX = parent\n\t\tif CTX == ROOT\n\t\t\tROOT.flush!\n\t\treturn res\n\n\tget child\n\t\t#child ||= new Context(self,depth + 1)\n\n\tget reactions\n\t\t#reactions ||= new Set\n\n\tdef flush\n\t\treturn unless #reactions\n\t\tlet items = #reactions\n\t\t#reactions = null\n\t\tfor reaction of items\n\t\t\treaction.call!\n\t\treturn\n\nclass Root < Context\n\n\tdef add\n\t\tyes\n\nlet CTX = new Root(null,0)\nlet ROOT = CTX\n\nlet REACT = do\n\tCTX.tracking = no\n\nlet GET = do(target,key,vsym,meta,bsym)\n\tlet val = target[vsym]\n\tlet beacon = target[bsym]\n\n\tunless beacon\n\t\tbeacon = target[bsym] = new Ref(0,meta,val,key)\n\n\tCTX.add(beacon,target)\n\treturn val\n\nlet SET = do(target,key,vsym,value,meta,bsym)\n\tlet prev = target[vsym]\n\n\tif value != prev\n\t\ttarget[vsym] = value\n\t\tlet beacon = target[bsym]\n\t\tbeacon.changed(0,value,prev) if beacon\n\n\treturn\n\nclass Ref\n\n\tdef constructor kind, type, val, name\n\t\tid = NEXT_REF_ID++\n\t\tobserver = null\n\t\tobservers = null\n\t\t# name = name\n\n\t\tval.##referenced(self) if val and val.##referenced\n\t\treturn self\n\n\tdef changed level, newValue,oldValue\n\t\tRUN_ID++\n\t\t# mixing responsibilities with deep observers?\n\t\toldValue.##dereferenced(self,newValue) if oldValue and oldValue.##dereferenced\n\t\tnewValue.##referenced(self,oldValue) if newValue and newValue.##referenced\n\n\t\t# change is only called here?\n\t\tobserver.invalidated(level + 1,this,newValue,oldValue) if observer\n\n\t\tif observers\n\t\t\tfor observer in observers\n\t\t\t\tobserver.invalidated(level + 1,this,newValue,oldValue)\n\n\t\tif CTX == ROOT\n\t\t\tCTX.flush!\n\t\treturn\n\n\tdef invalidated level, source\n\t\tobserver.invalidated(level + 1,this) if observer\n\n\t\tif observers\n\t\t\tfor observer in observers\n\t\t\t\tobserver.invalidated(level + 1,this)\n\n\t\tif level == 0 and CTX == ROOT\n\t\t\tCTX.flush!\n\t\tyes\n\n\tdef addSubscriber item\n\t\tunless observer\n\t\t\tobserver = item\n\t\telse\n\t\t\tobservers ||= []\n\t\t\tobservers.push(item)\n\t\treturn\n\n\tdef removeSubscriber item\n\t\tif observer == item\n\t\t\treturn observer = null\n\n\t\tlet obs = observers\n\t\tlet idx = obs.indexOf(item)\n\t\tif idx >= 0\n\t\t\tobs.splice(idx,1)\n\t\treturn\n\n\tdef reportChanged\n\t\tchanged(0)\n\n\tdef reportObserved\n\t\tCTX.add(this)\n\nexport def createAtom name\n\tnew Ref(null,null,null,name)\n\n###\nArray\n###\nexport class ObservableArray < Array\n\n\tdef push do CHANGED(this,super)\n\tdef pop do CHANGED(this,super)\n\tdef unshift do CHANGED(this,super)\n\tdef shift do CHANGED(this,super)\n\tdef splice do CHANGED(this,super)\n\tdef at do OBSERVED(this,super)\n\tdef map do OBSERVED(this,super)\n\tdef flatMap do OBSERVED(this,super)\n\tdef flat do OBSERVED(this,super)\n\tdef filter do OBSERVED(this,super)\n\tdef find do OBSERVED(this,super)\n\tdef slice do OBSERVED(this,super)\n\tdef sort do OBSERVED(this,super)\n\n\tget len do OBSERVED(this,length)\n\n\tset len value\n\t\tlength = value\n\t\tCHANGED(this)\n\n\tdef toIterable\n\t\tCTX.add(self[OWNREF]) if TRACKING\n\t\treturn self\n\n\tdef [Symbol.iterator]\n\t\tOBSERVED(this,super)\n\nconst ArrayExtensions = getExtensions(ObservableArray)\n\nextend class Array\n\n\tget len\n\t\tlength\n\n\tset len value\n\t\tlength = value\n\n\tget ##reactive do REFERENCED(this,null,ArrayExtensions)\n\tdef ##referenced ref do REFERENCED(this,ref,ArrayExtensions)\n\tdef ##dereferenced ref do DEREFERENCED(this,ref)\n\n###\nSet\n###\nclass ObservableSet < Set\n\tdef has do OBSERVED(this,super)\n\tdef keys do OBSERVED(this,super)\n\tdef values do OBSERVED(this,super)\n\tdef entries do OBSERVED(this,super)\n\n\tdef add do CHANGED(this,super)\n\tdef clear do CHANGED(this,super)\n\tdef delete do CHANGED(this,super)\n\nconst SetExtensions = getExtensions(ObservableSet)\n\nextend class Set\n\tget ##reactive do REFERENCED(this,null,SetExtensions)\n\tdef ##referenced ref do REFERENCED(this,ref,SetExtensions)\n\tdef ##dereferenced ref do DEREFERENCED(this,ref)\n\n###\nMap\n###\nclass ObservableMap < Map\n\tdef get do OBSERVED(this,super)\n\tdef has do OBSERVED(this,super)\n\tdef keys do OBSERVED(this,super)\n\tdef values do OBSERVED(this,super)\n\tdef entries do OBSERVED(this,super)\n\n\tdef set do CHANGED(this,super)\n\tdef clear do CHANGED(this,super)\n\tdef delete do CHANGED(this,super)\n\nconst MapExtensions = getExtensions(ObservableMap)\n\nextend class Map\n\tget ##reactive do REFERENCED(this,null,MapExtensions)\n\tdef ##referenced ref do REFERENCED(this,ref,MapExtensions)\n\tdef ##dereferenced ref do DEREFERENCED(this,ref)\n\nclass PropertyType\n\tdef constructor name,options = {}\n\t\tself.name = name\n\t\tself.options = options\n\t\tconst vkey = self.key = VALUESYM(name)\n\t\tconst bkey = REFSYM(name)\n\n\t\tlet descriptor = self.descriptor = {\n\t\t\tenumerable: options.enumerable ?? yes\n\t\t\tconfigurable: no\n\t\t\tget: do TRACKING ? GET(this,name,vkey,self,bkey) : this[vkey]\n\t\t\tset: do(value)\n\t\t\t\t(TRACKING or !!this[bkey]) ? SET(this,name,vkey,value,self,bkey) : (this[vkey] = value)\n\t\t}\n\n\t\tlet lazy = self.lazyDescriptor = {\n\t\t\tenumerable: no\n\t\t\tconfigurable: yes\n\t\t\tget: do\n\t\t\t\tif TRACKING\n\t\t\t\t\tObject.defineProperty(this,name,descriptor)\n\t\t\t\t\treturn this[name]\n\t\t\t\t# not if this is the prototype\n\t\t\t\treturn this[vkey]\n\n\t\t\tset: do(value)\n\t\t\t\tthis[vkey] = value\n\t\t\t\tthis[bkey] = null\n\t\t\t\tObject.defineProperty(this,name,descriptor)\n\t\t\t\t# this[bkey] = (value and value.##referenced) ? new Ref(0,self,value) : null\n\t\t}\n\nclass RefIndex\n\t#map = new Map\n\n\tdef for value\n\t\tlet res = #map.get(value)\n\t\t#map.set(value,res=[]) unless res\n\t\tres\n\n\tdef get value\n\t\tlet res = self.for(value)\n\t\tlet beacon = res[OWNREF]\n\t\tres.##reactive unless beacon\n\t\tOBSERVED(res) if TRACKING\n\t\treturn res\n\n\tdef add key, member\n\t\tself.for(key).push(member)\n\n\tdef delete key, member\n\t\tlet arr = self.for(key)\n\t\tlet idx = arr.indexOf(member)\n\t\tarr.splice(idx,1)\n\t\treturn\n\nclass RefType\n\n\tdef constructor name,vkey\n\t\tself.name = name\n\t\tself.key = vkey\n\t\tself.index = new RefIndex\n\n\t\tconst bkey = REFSYM(name)\n\n\t\tlet descriptor = self.descriptor = {\n\t\t\tenumerable: yes\n\t\t\tconfigurable: no\n\t\t\tget: do TRACKING ? GET(this,name,vkey,self,bkey) : this[vkey]\n\t\t\tset: do(value)\n\t\t\t\tlet prev = this[vkey]\n\t\t\t\t(TRACKING or !!this[bkey]) ? SET(this,name,vkey,value,self,bkey) : (this[vkey] = value)\n\t\t\t\tif prev != value\n\t\t\t\t\tindex.delete(prev,this) if prev\n\t\t\t\t\tindex.add(value,this) if value\n\t\t}\n\n\t\tlet lazy = self.lazyDescriptor = {\n\t\t\tset: do(value)\n\t\t\t\tthis[vkey] = value\n\t\t\t\tindex.add(value,this) if value\n\t\t\t\tObject.defineProperty(this,name,descriptor)\n\t\t\t\tthis[bkey] = null\n\t\t\t\t# (value and value.##referenced) ? new Ref(0,self,value) : null\n\t\t}\n\n\tdef where value\n\t\tindex.get(value)\n\n# why not inherit from beacon?\nclass Memo\n\tdef constructor target,func,vkey\n\t\tself.observing = null\n\t\tself.observers = null\n\t\tself.flags = 68\n\t\tself.target = target\n\t\tself.func = func\n\t\tself.vkey = vkey\n\t\tself.version = 0\n\t\t# global.ops.push(self)\n\n\tget beacon\n\t\tself\n\n\tdef addSubscriber item\n\t\tunless observer\n\t\t\tobserver = item\n\t\telse\n\t\t\tobservers ||= []\n\t\t\tobservers.push(item)\n\t\treturn\n\n\tdef removeSubscriber item\n\t\tif observer == item\n\t\t\treturn observer = null\n\n\t\tlet obs = observers\n\t\tlet idx = obs.indexOf(self)\n\t\tif idx >= 0\n\t\t\tobs.splice(idx,1)\n\t\treturn\n\n\tdef invalidated stack, source\n\t\tflags |= F.STALE | F.POSSIBLY_STALE\n\t\tobserver.invalidated(stack,this) if observer\n\n\t\treturn unless observers\n\t\tfor observer in observers\n\t\t\t# these are never - they are always computeds\n\t\t\tobserver.invalidated(stack,this)\n\t\tself\n\n\tdef value\n\t\tCTX.add(self) if TRACKING\n\n\t\tif flags !& F.POSSIBLY_STALE\n\t\t\treturn target[vkey]\n\n\t\tTRACKING++\n\t\tflags |= F.RUNNING\n\t\tCTX.push(self)\n\t\tlet res = func.call(target)\n\t\tCTX.pop(self)\n\t\tlet prev = target[vkey]\n\t\ttarget[vkey] = res\n\t\tflags ~= (F.STALE | F.POSSIBLY_STALE | F.RUNNING)\n\t\tif res !== prev\n\t\t\tself.version++\n\t\tTRACKING--\n\t\treturn res\n\nclass ComputedType\n\tdef constructor name,func\n\t\tself.name = name\n\t\tconst bkey = REFSYM(name)\n\t\tconst vkey = VALUESYM(name)\n\n\t\t# could use weakmap for a bit nicer structure I guess.\n\t\tconst descriptor = self.descriptor = {\n\t\t\tenumerable: no\n\t\t\tconfigurable: no\n\t\t\tget: do this[bkey].value!\n\t\t}\n\n\t\tconst lazy = self.lazyDescriptor = {\n\t\t\tenumerable: no\n\t\t\tget: do\n\t\t\t\tlet wrapper = this[bkey] = new Memo(this,func,vkey)\n\t\t\t\tObject.defineProperty(this,name,descriptor)\n\t\t\t\twrapper.value!\n\t\t}\n\nclass Reaction\n\n\tget beacon\n\t\tself\n\n\tdef constructor cb, context, options = {}\n\t\tcb = cb\n\t\tcontext = context\n\t\toptions = options\n\t\tflags = 0\n\t\tid = NEXT_REF_ID++\n\t\tcachedComputedVersions = new WeakMap\n\t\tcheckComputedValues = new Set\n\t\tobserving = []\n\t\ttimeout = null\n\n\tget running?\n\t\tflags & F.RUNNING\n\n\tdef invalidated stack,source\n\t\tif source isa Memo\n\t\t\tflags |= F.POSSIBLY_STALE\n\t\t\tcheckComputedValues.add(source)\n\t\telse\n\t\t\tflags |= F.STALE\n\n\t\tCTX.react(self)\n\n\tdef activate\n\t\tobserving = []\n\t\tcachedComputedVersions = new WeakMap\n\t\tcheckComputedValues = new Set\n\t\tcall!\n\t\tself\n\n\tdef deactivate\n\t\tclearTimeout(timeout) if timeout\n\t\tif observing\n\t\t\tfor item in observing\n\t\t\t\titem.removeSubscriber(self)\n\t\tobserving = checkComputedValues = cachedComputedVersions = null\n\t\tself\n\n\tdef call\n\t\tif TRACKING\n\t\t\t# only do this to detect infinite loops somehow?\n\t\t\tconsole.warn 'should not call reaction inside an autorunning context?',ROOT.snapshot\n\t\t\t# this shouldnt _always_ be the case though?\n\t\t\t# return\n\n\t\tif flags & F.POSSIBLY_STALE and flags !& F.STALE\n\t\t\tlet stale = no\n\t\t\tfor value of checkComputedValues\n\t\t\t\tlet v0 = cachedComputedVersions.get(value)\n\t\t\t\tvalue.value!\n\t\t\t\tlet v1 = value.version\n\t\t\t\tif v0 != v1\n\t\t\t\t\tbreak stale = yes\n\n\t\t\tunless stale\n\t\t\t\tflags ~= F.POSSIBLY_STALE\n\t\t\t\tcheckComputedValues.clear!\n\t\t\t\treturn\n\n\t\tif options.delay\n\t\t\tclearTimeout(timeout)\n\t\t\tlet num = options.delay\n\t\t\tnum = 1000 if typeof num != 'number'\n\t\t\ttimeout = setTimeout(&,num) do run!\n\t\t\treturn\n\t\treturn run!\n\n\tdef run\n\t\tTRACKING++\n\t\tflags |= F.RUNNING\n\t\tlet ctx = CTX.push(self)\n\t\t# let stop\n\t\tlet res = cb.call(context,REACT)\n\t\tlet beacons = CTX.pop(self)\n\n\t\tself.observing = beacons\n\n\t\tcheckComputedValues.clear!\n\t\tfor item in beacons when item isa Memo\n\t\t\tcachedComputedVersions.set(item,item.version)\n\n\t\tflags ~= (F.RUNNING | F.STALE | F.POSSIBLY_STALE)\n\t\tTRACKING--\n\n\t\tcommit! if $web$ and !options.silent\n\t\treturn res\n\n\tdef dispose\n\t\tdeactivate!\n\t\tcb = context = options = null\n\t\tself\n\nclass Awaits < Reaction\n\tdef resolve val\n\t\tdeactivate!\n\t\tresolved = val\n\n\tdef then ...params\n\n\t\tif resolved !== undefined\n\t\t\treturn Promise.resolve(resolved).then(...params)\n\t\telse\n\t\t\t#promise ||= new Promise do(_resolve)\n\t\t\t\tself.resolve = do(val)\n\t\t\t\t\tdeactivate!\n\t\t\t\t\tresolved = val\n\t\t\t\t\t_resolve(val)\n\t\t\t#promise.then(...params)\n\n\tdef run\n\t\tTRACKING++\n\t\tflags |= F.RUNNING\n\t\tlet ctx = CTX.push(self)\n\t\t# let stop\n\t\tlet res = cb.call(context)\n\t\tlet beacons = CTX.pop(self)\n\n\t\tself.observing = beacons\n\n\t\tcheckComputedValues.clear!\n\t\tfor item in beacons when item isa Memo\n\t\t\tcachedComputedVersions.set(item,item.version)\n\n\t\tflags ~= (F.RUNNING | F.STALE | F.POSSIBLY_STALE)\n\t\tTRACKING--\n\n\t\tif res != false and res != undefined and res != null\n\t\t\tresolve(res)\n\t\t\tcommit! if $web$ and !options.silent\n\t\treturn res\n\nclass Action\n\n\tdef constructor cb, context\n\t\tcontext = context\n\t\tcb = cb\n\n\tdef run ctx = context, args = []\n\t\tCTX.push(self)\n\t\ttry\n\t\t\tlet res = cb.apply(ctx,args)\n\t\t\tCTX.pop(self)\n\t\t\treturn res\n\t\tcatch e\n\t\t\tCTX.pop(self)\n\t\t\tthrow e\n\nexport def autorun cb, options = {}\n\tlet reaction = new Reaction(cb,global,options)\n\treaction.call!\n\treturn reaction\n\nexport def awaits cb, options = {}\n\tlet reaction = new Awaits(cb,global,options)\n\treaction.call!\n\treturn reaction\n\nexport def observable object\n\tobject.##reactive\n\nexport def run cb\n\tlet action = new Action(cb,global)\n\treturn action.run!\n\nexport def reportChanged item\n\tif item and item[OWNREF]\n\t\titem[OWNREF].invalidated(0)\n\treturn item\n\nexport def reportInvalidated item\n\tif item and item[OWNREF]\n\t\titem[OWNREF].invalidated(0)\n\treturn item\n\nexport def reportObserved item\n\tif item and item[OWNREF]\n\t\titem[OWNREF].reportObserved()\n\treturn item\n\nexport def createRef params = F.OBJECT\n\treturn new Ref(F.OBJECT)\n\nexport def @computed target, name, desc\n\tlet sym = METASYM(name)\n\tlet field = target[sym] = new ComputedType(name,desc.get)\n\treturn field.lazyDescriptor\n\nexport def @observable target, key, desc\n\tlet sym = METASYM(key)\n\tlet vsym = VALUESYM(key)\n\tlet opts = this[0] or {}\n\tlet field = target[sym] = new PropertyType(key,opts)\n\n\tif desc\n\t\tObject.defineProperty(target,vsym,Object.assign({},desc))\n\t\treturn field.lazyDescriptor\n\n\tObject.defineProperty(target,key,field.lazyDescriptor)\n\treturn null\n\nexport def @ref target, name, desc\n\tlet sym = METASYM(name)\n\ttarget.constructor[name]\n\tlet field = target[sym] = new RefType(name,VALUESYM(name))\n\treturn field.lazyDescriptor\n\nexport def @autorun target, key, desc\n\tlet schema = getSchema(target)\n\tlet options = this[0] or {}\n\toptions.flags = F.AUTORUN\n\tactivateHooks!\n\tschema[key] = options\n\treturn desc\n\nexport def @action target, key, desc\n\tif desc.value\n\t\tlet action = new Action(desc.value,null)\n\t\tdesc.value = do action.run(this,arguments)\n\treturn desc\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
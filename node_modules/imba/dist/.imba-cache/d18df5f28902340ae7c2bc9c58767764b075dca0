{"js":{"code":"function defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};;\nfunction iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };\nconst $setup$ = Symbol.for('#setup'), $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $changed$ = Symbol.for('#changed');\nvar $1 = Symbol(), $2 = Symbol(), $3 = Symbol();\n\n/*body*/\nimport './any';\n\nimport {Iterable} from '../core/iterable';\nimport {isPlainObject} from '../utils';\nconst OWNREF = Symbol.for(\"~\");\n\n// @template [Type=any]\nexport class OPEmbedField extends OPField {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $4;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\t($4 = $$.pgtype) !== undefined && (this.pgtype = $4);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $5;\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tthis.pgtype = ($$ && ($5 = $$.pgtype) !== undefined) ? ($5) : 'jsonb';\n\t\t\n\t}\n\tget valuetype(){\n\t\t\n\t\treturn this.type;\n\t}\n\t\n\tget complexΦ(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tget embeddedΦ(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tdeserialize(value,target){\n\t\t\n\t\t// FIXME Does not make sense here?\n\t\tif (typeof value == 'string' && this.enum) {\n\t\t\t\n\t\t\tvalue = this.type.id + '9' + value;\n\t\t};\n\t\treturn this.type.get(value,target,this);\n\t}\n\t\n\tserialize(value,target){\n\t\t\n\t\t// FIXME makes no sense for embeds?\n\t\treturn value ? String(this.enum ? value.oid : value.id) : undefined;\n\t}\n\t\n\t$load(value,target){\n\t\t\n\t\tif (value !== undefined) {\n\t\t\t\n\t\t\tthis.$get(target).$patch(value);\n\t\t};\n\t\treturn;\n\t}\n\t\n\t/**\n\t@returns { InstanceType<Type> }\n\t*/\n\t$get(target){\n\t\t\n\t\treturn target.$rich[this.name] ??= this.$instantiate(target);\n\t\t// valuetype.embed(target,self,virtual ? Object.assign({},args[1]) : target.$plain[name])\n\t}\n\t\n\t$instantiate(target){\n\t\t\n\t\treturn this.valuetype.embed(target,this,this.virtual ? Object.assign({},this.args[1] || {}) : ((target.$plain[this.name] ||= {})));\n\t}\n\t\n\t$set(value,target){\n\t\t\n\t\treturn this.$load(value,target);\n\t}\n\t\n\t$wake(target,vals){\n\t\t\n\t\treturn true;\n\t}\n\t\n\t[$setup$](){\n\t\tvar self = this;\n\t\t\n\t\tsuper[$setup$](...arguments);\n\t\tif (!(this.valuetype.embed)) {\n\t\t\t\n\t\t\treturn this.$instantiate = function(target) {\n\t\t\t\t\n\t\t\t\tlet pars = Object.assign({},self.args[1] || {});\n\t\t\t\tObject.defineProperties(pars,{\n\t\t\t\t\t$up: {value: target,enumerable: false},\n\t\t\t\t\t$key: {value: self,enumerable: false}\n\t\t\t\t});\n\t\t\t\treturn new self.valuetype(pars);\n\t\t\t};\n\t\t};\n\t}\n\t\n\t// def $sanitize value, target\n\t// \tlet v\n\t// \t# for own k,v\n\t// \t# self\n\t\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'OPEmbedField');inheritClass$__(this);}\n}; globalThis.OPEmbedField = OPEmbedField;\n\n// @template [Type=any]\nexport class OPEmbedsField extends OPField {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $6;\n\t\tsuper[$__patch__$] && super[$__patch__$]($$,fields);\n\t\t($6 = $$.pgtype) !== undefined && (this.pgtype = $6);\n\t\t\n\t}\n\tconstructor(){\n\t\tsuper(...arguments);\n\t\tsuper[$__init__$] || this[$__init__$]();this[$__initor__$]===$2 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $7;\n\t\tdeep && super[$__init__$] && super[$__init__$](...arguments);\n\t\tthis.pgtype = ($$ && ($7 = $$.pgtype) !== undefined) ? ($7) : 'jsonb';\n\t\t\n\t}\n\tget embeddedΦ(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tget richΦ(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\tget valuetype(){\n\t\t\n\t\treturn this.args[0];\n\t}\n\t\n\t/**\n\t@returns { OPEmbeds<InstanceType<Type>> }\n\t*/\n\t$get(target){\n\t\t\n\t\treturn target.$rich[this.name] ||= new OPEmbeds(target,this,{});\n\t}\n\t\n\t$patch(plain,target){\n\t\t\n\t\treturn this.$get(target).$patch(plain);\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $2;defineName$__(this,'OPEmbedsField');inheritClass$__(this);}\n}; globalThis.OPEmbedsField = OPEmbedsField;\n\nclass ΩOPObject {\n\t\n\t// @template [T=any]\n\t/**\n\t@param {T} type\n\t@returns { OPEmbedField<T> }\n\t*/\n\tαembed(type,...rest){\n\t\t\n\t\tlet field = new OPEmbedField(type,...rest);\n\t\tif (!((type?.prototype instanceof OPObject))) { // depends on the type, no?\n\t\t\t\n\t\t\tfield.pgtype = '';\n\t\t\tfield.virtual = true;\n\t\t};\n\t\treturn field;\n\t}\n\t\n\t// @template [T=any]\n\t/**\n\t@param {T} type\n\t@returns { OPEmbedsField<T> }\n\t*/\n\tαembeds(type,...rest){\n\t\t\n\t\tlet field = new OPEmbedsField(type,...rest);\n\t\treturn field;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPObject');}\n};\nextend$__(OPObject.prototype,ΩOPObject.prototype);\n;\n\n// @template [Type=any]\n// @extends {Array<InstanceType<Type>>}\nexport class OPEmbeds extends Iterable {\n\t\n\t\n\tconstructor(up,field,options){\n\t\t\n\t\tsuper();\n\t\tthis.$embed(up,field);\n\t\tthis.$wake(this.$plain);\n\t\t// ($cloud ||= {}) # Does it make any sense?\n\t\tthis[$__initor__$]===$3 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\t\n\tthen(ok,err){\n\t\t\n\t\treturn Promise.all(this.slice(0)).then(ok,err);\n\t}\n\t\n\t// get $plain\n\t// \t$cloud\n\t\n\tget valuetype(){\n\t\t\n\t\treturn this.$field.valuetype;\n\t}\n\t\n\tget(id){\n\t\t\n\t\treturn this.$sub(id);\n\t}\n\t\n\tadd(item,o = {}){\n\t\tvar $8, $9;\n\t\t\n\t\t\n\t\tif (isPlainObject(item)) {\n\t\t\t\n\t\t\t// why not use much simpler ids for these?\n\t\t\titem = this.valuetype.new(item);\n\t\t};\n\t\t\n\t\tif (!(this.writableΦ)) {\n\t\t\t\n\t\t\tthrow new OPPermissionDeniedError(`Cannot add item to SortedSet`);\n\t\t};\n\t\t\n\t\tif (!((item instanceof this.valuetype))) {\n\t\t\t\n\t\t\tthrow new OPPermissionDeniedError(`Cannot add item of type`);\n\t\t};\n\t\t\n\t\t// if item is already embedded somewhere else - throw or clone\n\t\tif (item.$up && item.$up != this) {\n\t\t\t\n\t\t\tthrow new OPPermissionDeniedError(`Item belongs to another parent`);\n\t\t\t// TODO Should item be moved from old location or duplicated?\n\t\t\titem = this.valuetype.new(item.$plain);\n\t\t\t// throw new OPError(`Item already embedded elsewhere`)\n\t\t};\n\t\t\n\t\t// Very convoluted\n\t\tlet key = item.id;\n\t\t// item.$embed(self,item.id)\n\t\tthis[key] = item;\n\t\t\n\t\titem.$up = this;\n\t\titem.$key = key;\n\t\t((($8 = item.$plain.id),delete item.$plain.id, $8));\n\t\t((($9 = item.$plain._rev),delete item.$plain._rev, $9));\n\t\t\n\t\t// this is embedded - why set id explicitly at all?\n\t\t\n\t\titem.id = (\"\" + this.id + `.` + (item.id));\n\t\t\n\t\tthis.$willΞset(key,item.$plain);\n\t\t// what if this belongs to a pov or is local or something?\n\t\tthis.$plain[key] = item.$plain;\n\t\treturn item;\n\t}\n\t\n\t/**\n\t@returns { InstanceType<Type> }\n\t*/\n\tcreate(params = {}){\n\t\t\n\t\tlet item = this.valuetype.new(params);\n\t\t// should be added at once\n\t\tthis.add(item);\n\t\titem.save();\n\t\treturn item;\n\t}\n\t\n\t/**\n\t@returns { InstanceType<Type> }\n\t*/\n\tbuild(params = {}){\n\t\t\n\t\tlet item = this.valuetype.new(params);\n\t\t// should be added at once\n\t\treturn this.add(item);\n\t}\n\t\n\tget options(){\n\t\t\n\t\treturn this.field.options;\n\t}\n\t\n\t$sub(key){\n\t\t\n\t\tif (this[key]) { return this[key] };\n\t\tlet typ = OP.getType(key);\n\t\treturn this[key] = typ.embed(this,key,this.$plain[key] ||= {});\n\t}\n\t\n\t$deregister(child){\n\t\t\n\t\treturn super.delete(child);\n\t}\n\t\n\t$register(child){\n\t\t\n\t\treturn super.add(child);\n\t}\n\t\n\t// waking up with the exact data\n\t$wake(data){\n\t\t\n\t\t// some default sorting here?\n\t\tfor (let $10 = 0, $11 = Object.keys(data), $12 = $11.length, k, v; $10 < $12; $10++){\n\t\t\tk = $11[$10];v = data[k];\n\t\t\tlet typ = OP.getType(k);\n\t\t\tlet existing = this[k];\n\t\t\tlet origdata = this.$plain[k];\n\t\t\tlet item = existing || typ.embed(this,k,this.$plain[k] ||= v);\n\t\t\t// item is not synced by default - feels like a bug\n\t\t\t// if item already existed - should we patch it?\n\t\t\t// item.$sync()\n\t\t\t\n\t\t\tif (existing) {\n\t\t\t\t\n\t\t\t\texisting.$patch(v);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tthis[k] = item;\n\t\t\t};\n\t\t\t\n\t\t\titem.$sync();\n\t\t\t\n\t\t\t// if v._del > 0\n\t\t\t// super.add(item) unless v._del > 0\n\t\t};\n\t\treturn this;\n\t}\n\t\n\t$patch(data,d = 0,cloud = this.$cloud){\n\t\t\n\t\tif (data instanceof Array) {\n\t\t\t\n\t\t\tfor (let $13 = 0, $14 = iter$__(data), $15 = $14.length; $13 < $15; $13++) {\n\t\t\t\tlet diff = $14[$13];\n\t\t\t\tlet k = diff.path[d];\n\t\t\t\tlet deep = diff.path[d + 1];\n\t\t\t\tlet v = diff.value;\n\t\t\t\t\n\t\t\t\t// patch for the whole embeds array\n\t\t\t\tif (!(k) && diff.type == 'CREATE') {\n\t\t\t\t\t\n\t\t\t\t\t// very likely buggy\n\t\t\t\t\tthis.$wake(v);\n\t\t\t\t\t// should really replace the cloud?\n\t\t\t\t\tObject.assign(cloud,v);\n\t\t\t\t\tcontinue;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tlet item = this[k];\n\t\t\t\t\n\t\t\t\t// change refers to a deeper item\n\t\t\t\tif (deep) {\n\t\t\t\t\t\n\t\t\t\t\t// $sub(k) # enforces the item to exist?\n\t\t\t\t\t// TODO how do we register that this exists etc?\n\t\t\t\t\tthis.$sub(k).$patch([diff],d + 1,cloud[k] ||= {});\n\t\t\t\t\tcontinue;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tif (diff.type == 'CREATE') {\n\t\t\t\t\t\n\t\t\t\t\tif (item) {\n\t\t\t\t\t\t\n\t\t\t\t\t\titem.$patch(v,0);\n\t\t\t\t\t\t// why was this not added immediately?\n\t\t\t\t\t\tsuper.add(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// creating / registering new item now\n\t\t\t\t\t\tlet typ = OP.getType(k);\n\t\t\t\t\t\titem = this[k] = typ.embed(this,k,this.$plain[k] ||= v);\n\t\t\t\t\t\tsuper.add(item);\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tcloud[k] = v;\n\t\t\t\t} else if (diff.type == 'CHANGE') {\n\t\t\t\t\t\n\t\t\t\t\ttrue;\n\t\t\t\t\t// apply diffs\n\t\t\t\t\t// what about the cloud object?\n\t\t\t\t};\n\t\t\t};\n\t\t\treturn;\n\t\t};\n\t\t\n\t\t// potentially remove items?\n\t\t// if we got lazy data or something, should not the nested items rather take care of updating here?\n\t\tfor (let $16 = 0, $17 = Object.keys(data), $18 = $17.length, k, v; $16 < $18; $16++){\n\t\t\tk = $17[$16];v = data[k];\n\t\t\tlet item = this[k];\n\t\t\tif (item) {\n\t\t\t\t\n\t\t\t\titem.$patch(v);\n\t\t\t\t// need to ensure that it is added as well?\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// cloud prop for embeds might not exist?\n\t\t\t\t// $cloud ||= {}\n\t\t\t\tthis.$cloud[k] = v;\n\t\t\t\tthis[k] = this.$sub(k);\n\t\t\t\t// what if it is marked as deleted?\n\t\t\t\t// push()\n\t\t\t};\n\t\t};\n\t\t\n\t\t// Should we reorder if something has changed inside?\n\t\t// Return value of $patch could decide if the parent $patch should also update the underlying data?\n\t\treturn this;\n\t}\n\t\n\t[$changed$](){\n\t\t\n\t\tthis[OWNREF].invalidated(0);\n\t\treturn this.$up.$changed(this,this.$field);\n\t}\n\t\n\t// general a\n\t$consume(item){\n\t\t\n\t\treturn this.add(item);\n\t}\n\t\n\tbuild(o = {}){\n\t\t\n\t\tlet id = this.$field.type.key.generate();\n\t\tthis.log('build with id',id);\n\t\tlet item = this.$field.type;\n\t\treturn this.$field.type.embed(this,id,o);\n\t}\n\t\n\tpersist(){\n\t\t\n\t\treturn this[$changed$]();\n\t}\n\t\n\tserialize(depth = 0){\n\t\t\n\t\treturn this.scores || undefined;\n\t}\n\t\n\t$change(value){\n\t\t\n\t\tconsole.log('embeds $change',value);\n\t\treturn this.patch(value,true);\n\t}\n\t\n\t// Difference between patching and setting.\n\t// When we're setting we want to retain the changes\n\tpatch(data,track = false){\n\t\t\n\t\tif (data == null) { return };\n\t}\n\t\n\tget id(){\n\t\t\n\t\treturn (\"\" + (this.$up.id) + `.` + this.$key);\n\t}\n\t\n\ttoString(){\n\t\t\n\t\treturn this.id;\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $3;defineName$__(this,'OPEmbeds');inheritClass$__(this);}\n}; globalThis.OPEmbeds = OPEmbeds;\n\nOPValue.extend(OPEmbeds);\n","dependencies":[],"map":{"version":3,"file":"embed.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/fields/embed.imba"],"sourcesContent":["import './any'\n\nimport {Iterable} from '../core/iterable'\nimport {isPlainObject} from '../utils'\nconst OWNREF = Symbol.for(\"~\")\n\n# @template [Type=any]\nexport global class OPEmbedField < OPField\n\tpgtype = 'jsonb'\n\n\tget valuetype\n\t\ttype\n\n\tget complex?\n\t\tyes\n\n\tget embedded?\n\t\tyes\n\n\tdef deserialize value, target\n\t\t# FIXME Does not make sense here?\n\t\tif typeof value == 'string' and self.enum\n\t\t\tvalue = type.id + '9' + value\n\t\ttype.get(value,target,self)\n\n\tdef serialize value, target\n\t\t# FIXME makes no sense for embeds?\n\t\tvalue ? String(self.enum ? value.oid : value.id) : undefined\n\n\tdef $load value, target\n\t\tunless value === undefined\n\t\t\t$get(target).$patch(value)\n\t\treturn\n\n\tdef $get\\InstanceType<Type> target\n\t\ttarget.$rich[name] ??= $instantiate(target)\n\t\t# valuetype.embed(target,self,virtual ? Object.assign({},args[1]) : target.$plain[name])\n\n\tdef $instantiate target\n\t\tvaluetype.embed(target,self,virtual ? Object.assign({},args[1] or {}) : (target.$plain[name] ||= {}))\n\n\tdef $set value, target\n\t\t$load(value,target)\n\n\tdef $wake target, vals\n\t\tyes\n\n\tdef #setup\n\t\tsuper\n\t\tif !valuetype.embed\n\t\t\t$instantiate = do(target)\n\t\t\t\tlet pars = Object.assign({},args[1] or {})\n\t\t\t\tObject.defineProperties(pars,{\n\t\t\t\t\t$up: {value: target, enumerable: no}\n\t\t\t\t\t$key: {value: self, enumerable: no}\n\t\t\t\t})\n\t\t\t\tnew valuetype(pars)\n\n\t# def $sanitize value, target\n\t# \tlet v\n\t# \t# for own k,v\n\t# \t# self\n\n# @template [Type=any]\nexport global class OPEmbedsField < OPField\n\tpgtype = 'jsonb'\n\n\tget embedded?\n\t\tyes\n\n\tget rich?\n\t\tyes\n\n\tget valuetype\n\t\targs[0]\n\n\tdef $get\\OPEmbeds<InstanceType<Type>> target\n\t\ttarget.$rich[name] ||= new OPEmbeds(target,self,{})\n\n\tdef $patch plain, target\n\t\t$get(target).$patch(plain)\n\nextend class OPObject\n\t# @template [T=any]\n\tdef @embed\\OPEmbedField<T> type\\T, ...rest\n\t\tlet field = new OPEmbedField(type,...rest)\n\t\tunless type..prototype isa OPObject # depends on the type, no?\n\t\t\tfield.pgtype = ''\n\t\t\tfield.virtual = yes\n\t\treturn field\n\n\t# @template [T=any]\n\tdef @embeds\\OPEmbedsField<T> type\\T, ...rest\n\t\tlet field = new OPEmbedsField(type,...rest)\n\t\treturn field\n\n# @template [Type=any]\n# @extends {Array<InstanceType<Type>>}\nexport global class OPEmbeds < Iterable\n\n\tdef constructor up,field,options\n\t\tsuper()\n\t\t$embed(up,field)\n\t\t$wake($plain)\n\t\t# ($cloud ||= {}) # Does it make any sense?\n\n\tdef then ok,err\n\t\tPromise.all(slice(0)).then(ok,err)\n\n\t# get $plain\n\t# \t$cloud\n\n\tget valuetype\n\t\t$field.valuetype\n\n\tdef get id\n\t\t$sub(id)\n\n\tdef add item, o = {}\n\n\t\tif isPlainObject(item)\n\t\t\t# why not use much simpler ids for these?\n\t\t\titem = valuetype.new(item)\n\n\t\tif !writable?\n\t\t\tthrow new OPPermissionDeniedError(`Cannot add item to SortedSet`)\n\n\t\tunless item isa valuetype\n\t\t\tthrow new OPPermissionDeniedError(`Cannot add item of type`)\n\n\t\t# if item is already embedded somewhere else - throw or clone\n\t\tif item.$up and item.$up != self\n\t\t\tthrow new OPPermissionDeniedError(`Item belongs to another parent`)\n\t\t\t# TODO Should item be moved from old location or duplicated?\n\t\t\titem = valuetype.new(item.$plain)\n\t\t\t# throw new OPError(`Item already embedded elsewhere`)\n\n\t\t# Very convoluted\n\t\tlet key = item.id\n\t\t# item.$embed(self,item.id)\n\t\tself[key] = item\n\n\t\titem.$up = self\n\t\titem.$key = key\n\t\tdelete item.$plain.id\n\t\tdelete item.$plain._rev\n\n\t\t# this is embedded - why set id explicitly at all?\n\n\t\titem.id = `{id}.{item.id}`\n\n\t\t$will-set(key,item.$plain)\n\t\t# what if this belongs to a pov or is local or something?\n\t\t$plain[key] = item.$plain\n\t\treturn item\n\n\tdef create\\InstanceType<Type> params = {}\n\t\tlet item = valuetype.new(params)\n\t\t# should be added at once\n\t\tadd(item)\n\t\titem.save!\n\t\treturn item\n\n\tdef build\\InstanceType<Type> params = {}\n\t\tlet item = valuetype.new(params)\n\t\t# should be added at once\n\t\tadd(item)\n\n\tget options\n\t\tfield.options\n\n\tdef $sub key\n\t\treturn self[key] if self[key]\n\t\tlet typ = OP.getType(key)\n\t\tself[key] = typ.embed(self,key,$plain[key] ||= {})\n\n\tdef $deregister child\n\t\tsuper.delete(child)\n\n\tdef $register child\n\t\tsuper.add(child)\n\n\t# waking up with the exact data\n\tdef $wake data\n\t\t# some default sorting here?\n\t\tfor own k,v of data\n\t\t\tlet typ = OP.getType(k)\n\t\t\tlet existing = self[k]\n\t\t\tlet origdata = $plain[k]\n\t\t\tlet item = existing or typ.embed(self,k,$plain[k] ||= v)\n\t\t\t# item is not synced by default - feels like a bug\n\t\t\t# if item already existed - should we patch it?\n\t\t\t# item.$sync()\n\n\t\t\tif existing\n\t\t\t\texisting.$patch(v)\n\t\t\telse\n\t\t\t\tself[k] = item\n\n\t\t\titem.$sync()\n\n\t\t\t# if v._del > 0\n\t\t\t# super.add(item) unless v._del > 0\n\t\tself\n\n\tdef $patch data,d=0,cloud = $cloud\n\t\tif data isa Array\n\t\t\tfor diff in data\n\t\t\t\tlet k = diff.path[d]\n\t\t\t\tlet deep = diff.path[d + 1]\n\t\t\t\tlet v = diff.value\n\n\t\t\t\t# patch for the whole embeds array\n\t\t\t\tif !k and diff.type == 'CREATE'\n\t\t\t\t\t# very likely buggy\n\t\t\t\t\t$wake(v)\n\t\t\t\t\t# should really replace the cloud?\n\t\t\t\t\tObject.assign(cloud,v)\n\t\t\t\t\tcontinue\n\n\t\t\t\tlet item = self[k]\n\n\t\t\t\t# change refers to a deeper item\n\t\t\t\tif deep\n\t\t\t\t\t# $sub(k) # enforces the item to exist?\n\t\t\t\t\t# TODO how do we register that this exists etc?\n\t\t\t\t\t$sub(k).$patch([diff],d + 1,cloud[k] ||= {})\n\t\t\t\t\tcontinue\n\n\t\t\t\tif diff.type == 'CREATE'\n\t\t\t\t\tif item\n\t\t\t\t\t\titem.$patch(v,0)\n\t\t\t\t\t\t# why was this not added immediately?\n\t\t\t\t\t\tsuper.add(item)\n\t\t\t\t\telse\n\t\t\t\t\t\t# creating / registering new item now\n\t\t\t\t\t\tlet typ = OP.getType(k)\n\t\t\t\t\t\titem = self[k] = typ.embed(self,k,$plain[k] ||= v)\n\t\t\t\t\t\tsuper.add(item)\n\n\t\t\t\t\tcloud[k] = v\n\t\t\t\telif diff.type == 'CHANGE'\n\t\t\t\t\tyes\n\t\t\t\t\t# apply diffs\n\t\t\t\t\t# what about the cloud object?\n\t\t\treturn\n\n\t\t# potentially remove items?\n\t\t# if we got lazy data or something, should not the nested items rather take care of updating here?\n\t\tfor own k,v of data\n\t\t\tlet item = self[k]\n\t\t\tif item\n\t\t\t\titem.$patch(v)\n\t\t\t\t# need to ensure that it is added as well?\n\t\t\telse\n\t\t\t\t# cloud prop for embeds might not exist?\n\t\t\t\t# $cloud ||= {}\n\t\t\t\t$cloud[k] = v\n\t\t\t\tself[k] = $sub(k)\n\t\t\t\t# what if it is marked as deleted?\n\t\t\t\t# push()\n\n\t\t# Should we reorder if something has changed inside?\n\t\t# Return value of $patch could decide if the parent $patch should also update the underlying data?\n\t\tself\n\n\tdef #changed\n\t\tself[OWNREF].invalidated(0)\n\t\t$up.$changed(self,$field)\n\n\t# general a\n\tdef $consume item\n\t\tadd(item)\n\n\tdef build o = {}\n\t\tlet id = $field.type.key.generate!\n\t\tlog 'build with id',id\n\t\tlet item = $field.type\n\t\t$field.type.embed(self,id,o)\n\n\tdef persist\n\t\t#changed!\n\n\tdef serialize depth = 0\n\t\treturn scores or undefined\n\n\tdef $change value\n\t\tconsole.log 'embeds $change',value\n\t\tpatch(value,yes)\n\n\t# Difference between patching and setting.\n\t# When we're setting we want to retain the changes\n\tdef patch data, track = no\n\t\treturn if data == null\n\n\tget id\n\t\t`{$up.id}.{$key}`\n\n\tdef toString\n\t\tid\n\nOPValue.extend(OPEmbeds)"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
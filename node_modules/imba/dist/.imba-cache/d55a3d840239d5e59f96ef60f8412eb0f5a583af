{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};;\nfunction extend$__(target,ext){\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(ext);\n\tdelete descriptors.constructor;\n\tif(target.extend__ instanceof Function){\n\t\ttarget.extend__(descriptors,ext);\n\t} else {\n\t\t// @ts-ignore\n\t\tObject.defineProperties(target,descriptors);\n\t}\n\treturn target;\n};\nimport {αobservable as imba_αobservable} from 'imba';\nconst $setup$ = Symbol.for('#setup'), $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__'), $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $label$ = Symbol.for('#label');\n\n/*body*/\nimport {getDeepDescriptor,compareShallow} from '../utils';\nimport {STACK} from '../stack';\nimport {R,W,D} from '../protocol';\n\nexport {STACK};\n\n/*\nQ What should the standardised interface for patching data field values be?\nTODO Rename value.patch to value.$patch\n*/\n\n\nglobalThis.OPFieldRegistry = new class OPFields extends Array {\n\t\n\t\n\tchildrenΞof(type){\n\t\t\n\t\tlet hits = [];\n\t\t\n\t\tfor (let $1 = 0, $2 = iter$__(this), $3 = $2.length, typ; $1 < $3; $1++) {\n\t\t\tlet f = $2[$1];\n\t\t\tif (!(f.parent)) { continue; };\n\t\t\tif (typ = (f.reftype || f.valuetype)) {\n\t\t\t\t\n\t\t\t\tif (typ == type || (typ.prototype instanceof type)) {\n\t\t\t\t\t\n\t\t\t\t\thits.push(f);\n\t\t\t\t};\n\t\t\t};\n\t\t};\n\t\treturn hits;\n\t}\n\t\n\tget $parent(){\n\t\t\n\t\treturn this.filter(function(_0) { return _0.parent; });\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPFields');inheritClass$__(this);}\n};\n\nexport class OPField {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $4;\n\t\t($4 = $$.required) !== undefined && (this.required = $4);\n\t\t($4 = $$.pgtype) !== undefined && (this.pgtype = $4);\n\t\t($4 = $$.observable) !== undefined && (this.observable = $4);\n\t\t($4 = $$.default) !== undefined && (this.default = $4);\n\t\t($4 = $$.readonly) !== undefined && (this.readonly = $4);\n\t\t($4 = $$.hidden) !== undefined && (this.hidden = $4);\n\t\t($4 = $$.immutable) !== undefined && (this.immutable = $4);\n\t\t($4 = $$.generated) !== undefined && (this.generated = $4);\n\t\t($4 = $$.pov) !== undefined && (this.pov = $4);\n\t\t($4 = $$.local) !== undefined && (this.local = $4);\n\t\t($4 = $$.index) !== undefined && (this.index = $4);\n\t\t($4 = $$.virtual) !== undefined && (this.virtual = $4);\n\t\t($4 = $$.session) !== undefined && (this.session = $4);\n\t\t($4 = $$.lazy) !== undefined && (this.lazy = $4);\n\t\t($4 = $$.unique) !== undefined && (this.unique = $4);\n\t\t($4 = $$.autoload) !== undefined && (this.autoload = $4);\n\t\t($4 = $$.$tracked) !== undefined && (this.$tracked = $4);\n\t\t($4 = $$.actionable) !== undefined && (this.actionable = $4);\n\t\t($4 = $$.g) !== undefined && (this.g = $4);\n\t\t\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tvar $5;\n\t\tthis.required = ($$ && ($5 = $$.required) !== undefined) ? ($5) : false;\n\t\tthis.pgtype = ($$ && ($5 = $$.pgtype) !== undefined) ? ($5) : 'text';\n\t\tthis.observable = ($$ && ($5 = $$.observable) !== undefined) ? ($5) : false;\n\t\tthis.default = ($$ && ($5 = $$.default) !== undefined) ? ($5) : null;\n\t\tthis.readonly = ($$ && ($5 = $$.readonly) !== undefined) ? ($5) : false;\n\t\tthis.hidden = ($$ && ($5 = $$.hidden) !== undefined) ? ($5) : false;\n\t\tthis.immutable = ($$ && ($5 = $$.immutable) !== undefined) ? ($5) : false;\n\t\tthis.generated = ($$ && ($5 = $$.generated) !== undefined) ? ($5) : false;\n\t\tthis.pov = ($$ && ($5 = $$.pov) !== undefined) ? ($5) : null;\n\t\tthis.local = ($$ && ($5 = $$.local) !== undefined) ? ($5) : false;\n\t\tthis.index = ($$ && ($5 = $$.index) !== undefined) ? ($5) : false;\n\t\tthis.virtual = ($$ && ($5 = $$.virtual) !== undefined) ? ($5) : false;\n\t\tthis.session = ($$ && ($5 = $$.session) !== undefined) ? ($5) : false;\n\t\tthis.lazy = ($$ && ($5 = $$.lazy) !== undefined) ? ($5) : false;\n\t\tthis.unique = ($$ && ($5 = $$.unique) !== undefined) ? ($5) : false;\n\t\tthis.autoload = ($$ && ($5 = $$.autoload) !== undefined) ? ($5) : false;\n\t\tthis.$tracked = ($$ && ($5 = $$.$tracked) !== undefined) ? ($5) : false;\n\t\tthis.actionable = ($$ && ($5 = $$.actionable) !== undefined) ? ($5) : false;\n\t\tthis.g = ($$ && ($5 = $$.g) !== undefined) ? ($5) : null;\n\t\t\n\t}\n\t\n\t\n\t// Is this property required\n\t\n\t\n\t// Columntype in database\n\t\n\t\n\t// Makes property observable\n\t\n\t\n\t// Default value for property\n\t\n\t\n\t// Disallow changing property after init\n\t\n\t\n\t// Accessible on the server - hidden everywhere else\n\t// Call it internal instead?\n\t\n\t\n\t// Unchangeable after initial creation\n\t\n\t\n\t// Field is generated from server / other data - no need to serialize from client\n\t\n\t\n\t// Field is unique per user - change name of this?\n\t\n\t\n\t// Field persists to localStorage\n\t\n\t\n\t// Index this field in database\n\t\n\t\n\t\n\t\n\t// Field perssists to sessionStorage\n\t\n\t\n\t// Field is not in sweeping data-fetches\n\t\n\t\n\t// Values have to be unique across instances of model?\n\t\n\t\n\t\n\t\n\t// grouping\n\t\n\t\n\t// Should prefix these as internal\n\t\n\t// defaults to $plain\n\t\n\t\n\t\n\t// Target set for bound fields\n\t\n\t\n\tget $trace(){\n\t\t\n\t\treturn !(!(STACK.debug));\n\t}\n\t\n\tget $stack(){\n\t\t\n\t\treturn STACK;\n\t}\n\t\n\tconstructor(type){\n\t\t\n\t\tthis[$__init__$]();\n\t\tthis.$backlinks = null;\n\t\tthis.R = null;\n\t\tthis.W = null;\n\t\tthis.D = null;\n\t\t\n\t\t// self.$acl = {r:0,w:0}\n\t\tthis.args = Array.from(arguments);\n\t\tif (type) { this.type = type };\n\t}\n\t\n\tget numberΦ(){\n\t\t\n\t\treturn false;\n\t}\n\t\n\tget refΦ(){\n\t\t\n\t\treturn false;\n\t}\n\t\n\tget actionΦ(){\n\t\t\n\t\treturn !(!(this.actionable));\n\t}\n\t\n\tget richΦ(){\n\t\t\n\t\treturn false;\n\t}\n\t\n\tget localΦ(){\n\t\t\n\t\treturn this.local || this.session;\n\t}\n\t\n\tget $path(){\n\t\t\n\t\tlet pre = this.$target && this.$target.$path;\n\t\treturn pre ? ((\"\" + pre + `.` + this.name)) : this.name;\n\t}\n\t\n\t// Only relevant for bound fields\n\tget $up(){\n\t\t\n\t\treturn this.$target;\n\t}\n\t\n\tget $root(){\n\t\t\n\t\treturn this.$up.$root;\n\t}\n\t\n\t// Return true if field needs to evaluate additional code when value changes\n\tget complexΦ(){\n\t\t\n\t\treturn !(!(this.$granted));\n\t}\n\t\n\t// Coerces value to serializable value\n\t$sanitize(value,target){\n\t\t\n\t\tif (this.refΦ) {\n\t\t\t\n\t\t\tif (value instanceof Array) {\n\t\t\t\t\n\t\t\t\treturn value.map(function(_0) { return _0.id || _0; });\n\t\t\t};\n\t\t\treturn value ? ((value.id || value)) : null;\n\t\t};\n\t\treturn value;\n\t}\n\t\n\t$backlinked(field){\n\t\t\n\t\tthis.$backlinks ??= new Set;\n\t\treturn this.$backlinks.add(field);\n\t}\n\t\n\tfallback(cb){\n\t\t\n\t\tthis.$fallback = cb;\n\t\treturn this;\n\t}\n\t\n\t// naming? role / elevate / promote / is  grant / becomes\n\tas(roles){\n\t\t\n\t\tthis.$granted ||= 0;\n\t\tthis.$granted |= +roles;\n\t\treturn true;\n\t}\n\t\n\tguard(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\t$rule(pairs){\n\t\tvar $6;\n\t\t\n\t\t$6 = [];\n\t\tfor (let $7 = 0, $8 = Object.keys(pairs), $9 = $8.length, k, checks; $7 < $9; $7++){\n\t\t\tk = $8[$7];checks = pairs[k];\n\t\t\tlet check = checks[0];\n\t\t\t\n\t\t\tif (checks.length > 1) {\n\t\t\t\t\n\t\t\t\tthrow \"Multiple args to access rules not supported yet\";\n\t\t\t};\n\t\t\t\n\t\t\t$6.push((typeof check == 'number' || (check instanceof OP.Role)) ? (\n\t\t\t\t\n\t\t\t\tthis[k] |= +check\n\t\t\t) : (\n\t\t\t\t\n\t\t\t\tthis[k] = check\n\t\t\t));\n\t\t};\n\t\treturn $6;\n\t}\n\t\n\t// can access field?\n\t// multiple params should identify that all has to be met?\n\tr(roles){\n\t\t\n\t\tif (typeof roles == 'number' || (roles instanceof OP.Role)) {\n\t\t\t\n\t\t\treturn this.R |= +roles;\n\t\t} else {\n\t\t\t\n\t\t\treturn this.R = roles;\n\t\t};\n\t}\n\t\n\t// can edit field?\n\tw(roles){\n\t\t\n\t\tif (typeof roles == 'number' || (roles instanceof OP.Role)) {\n\t\t\t\n\t\t\treturn this.W |= +roles;\n\t\t} else {\n\t\t\t\n\t\t\treturn this.W = roles;\n\t\t};\n\t}\n\t\n\trw(read,write = read){\n\t\t\n\t\tthis.r(read);\n\t\treturn this.w(write);\n\t}\n\t\n\t// set executable rights\n\tx(roles){\n\t\t\n\t\tif (typeof roles == 'number' || (roles instanceof OP.Role)) {\n\t\t\t\n\t\t\treturn this.X |= +roles;\n\t\t} else {\n\t\t\t\n\t\t\treturn this.X = roles;\n\t\t};\n\t}\n\t\n\td(roles){\n\t\t\n\t\tif (typeof roles == 'number' || (roles instanceof OP.Role)) {\n\t\t\t\n\t\t\treturn this.D |= +roles;\n\t\t} else {\n\t\t\t\n\t\t\treturn this.D = roles;\n\t\t};\n\t}\n\t\n\trls(){\n\t\t\n\t\treturn true;\n\t}\n\t\n\t['is'](){\n\t\t\n\t\treturn true;\n\t}\n\t\n\t// just for backwards compat\n\tget meta(){\n\t\t\n\t\treturn this;\n\t}\n\t\n\tset label(val){\n\t\t\n\t\tthis[$label$] = val;\n\t}\n\t\n\tget label(){\n\t\t\n\t\tlet lbl = this[$label$] || this.name.humanize();\n\t\tif (this.$target) {\n\t\t\t\n\t\t\tlbl = lbl.replace(/Item\\b/,this.$target.typeName || 'Item');\n\t\t};\n\t\treturn lbl;\n\t}\n\t\n\t/**\n\t@returns { any }\n\t*/\n\tget valuetype(){\n\t\t\n\t\treturn String;\n\t}\n\t\n\tget $stack(){\n\t\t\n\t\treturn STACK;\n\t}\n\t\n\tget columnΦ(){\n\t\t\n\t\treturn this.pgtype && !(this.local) && !(this.session) && !(this.virtual);\n\t}\n\t\n\t// Run this field as an action\n\trun(ctx = {}){\n\t\t\n\t\tlet val = this.$get(this.$target);\n\t\t\n\t\tif (this.$action) {\n\t\t\t\n\t\t\treturn this.$action.apply(this.$target,[]);\n\t\t} else if (this.callback) {\n\t\t\t\n\t\t\treturn this.callback.apply(this.$target,[]);\n\t\t};\n\t}\n\t\n\t/**\n\t@returns { this }\n\t*/\n\t$accessor(target,key,name,slot,context){\n\t\tvar self = this;\n\t\t\n\t\t\n\t\tlet field = Object.create(this);\n\t\t\n\t\t// hack specifically for id?\n\t\tif (name == 'id') {\n\t\t\t\n\t\t\tif (target != context && target.constructor.prototype == target) {\n\t\t\t\t\n\t\t\t\tcontext = target;\n\t\t\t};\n\t\t};\n\t\t\n\t\tfield.model = context.constructor;\n\t\tfield.name = name;\n\t\tfield.key = key;\n\t\tfield.$symbol = key;\n\t\tfield.slot = slot;\n\t\tfield.$prop = '$plain';\n\t\t\n\t\t// if we instead created a copy of this and cached it\n\t\t// we could reuse the same fields in several places\n\t\tcontext[slot] = field;\n\t\t\n\t\tlet primitive = (this.default?.literal ?? undefined);\n\t\t\n\t\tif (this.default) {\n\t\t\t\n\t\t\t\n\t\t\t// Imba will change this to primitive - just for testing\n\t\t\tif (typeof this.default.literal == 'number') {\n\t\t\t\t\n\t\t\t\tthis.default.sql = this.default.literal;\n\t\t\t\t// field.model.prototype[key] = default.literal\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (field.pov) {\n\t\t\t\n\t\t\t\n\t\t\tlet pov = field.model.Pov.prototype;\n\t\t\tlet desc = getDeepDescriptor(context,name);\n\t\t\tpov[(`αα` + name)] = field;\n\t\t\tObject.defineProperty(pov,name,desc);\n\t\t\t\n\t\t\tif (primitive !== undefined) {\n\t\t\t\t\n\t\t\t\tpov[key] = primitive;\n\t\t\t};\n\t\t\t\n\t\t\t// should make different fields for the povs and pov combinations?\n\t\t\t// how do we map the localpov somewhere?\n\t\t\t\n\t\t\t// override the main property index\n\t\t\tif (false) {} else {\n\t\t\t\t\n\t\t\t\tObject.defineProperty(context,name,{\n\t\t\t\t\tget: function() { return field.$get(this.$pov(OP.agent),key); },\n\t\t\t\t\tset: function(_0) { return field.$set(_0,this.$pov(OP.agent),key); }\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\tcontext;\n\t\t\t\n\t\t\t// if it is aggregated - change the main pointer to something else?\n\t\t};\n\t\t\n\t\t// if $web$\n\t\t// \t# TODO Remove this - now using idb for this store as well?\n\t\t// \t# Not clear how this will work with pov etc\n\t\t// \t# let store = field.local ? imba.locals : (field.session ? imba.session : null)\n\t\tif (field.local) {\n\t\t\t\n\t\t\tfield.$prop = '$localdata';\n\t\t} else if (field.session) {\n\t\t\t\n\t\t\tfield.$prop = '$sessiondata';\n\t\t};\n\t\t\n\t\tif (!(field.pov) && this.observable) {\n\t\t\t\n\t\t\timba_αobservable.call([],context,key);\n\t\t};\n\t\t\n\t\t// add fallback as a nested accessor?\n\t\tif (this.$fallback && !((this instanceof OPPlainField))) {\n\t\t\t\n\t\t\tconsole.warn((\"Warning: in '\" + (field.model.$name) + \"' you are setting a fallback on the rich field '\" + name + \"'. Fallbacks on rich fields are not supported.\").yellow);\n\t\t};\n\t\t\n\t\tif (this.$fallback) {\n\t\t\t\n\t\t\tlet getter = field.$get;\n\t\t\tfield.$get = function(target) {\n\t\t\t\t\n\t\t\t\t// temporary hack\n\t\t\t\tlet val = getter.call(this,target);\n\t\t\t\tif (val === undefined && self.$fallback && !(STACK.serializingΦ)) {\n\t\t\t\t\t\n\t\t\t\t\treturn self.$fallback.call(target);\n\t\t\t\t};\n\t\t\t\treturn val;\n\t\t\t};\n\t\t};\n\t\t\n\t\tfield[$setup$]();\n\t\tOPFieldRegistry.push(field);\n\t\treturn field;\n\t}\n\t\n\t$set(value,target){\n\t\t\n\t\tif (false) {};\n\t\treturn this.$change(value,target);\n\t}\n\t\n\t$change(value,target){\n\t\t\n\t\tlet raw = target[this.key];\n\t\tif (raw === value) { return };\n\t\t\n\t\tthis.$load(value,target);\n\t\t// we always call $changed on the model\n\t\treturn target.$changed(this.name,value,this);\n\t}\n\t\n\t$log(target,...params){\n\t\t\n\t\treturn console.log((`%c ` + (target.id) + `.` + this.name),`color:lightblue`,...params);\n\t}\n\t\n\t$warn(target,...params){\n\t\t\n\t\treturn console.warn((`%c ` + (target.id) + `.` + this.name),`color:lightblue`,...params);\n\t}\n\t\n\t$get(target){\n\t\t\n\t\treturn target[this.$prop][this.name];\n\t}\n\t\n\t$getΞplain(target){\n\t\t\n\t\treturn target.$plain[this.name];\n\t}\n\t\n\t$setΞplain(value,target,ctx){\n\t\t\n\t\t// Is this every called when patching?\n\t\tlet name = this.name;\n\t\tlet data = target[this.$prop];\n\t\tlet prev = data[name];\n\t\tif (prev != value) {\n\t\t\t\n\t\t\tif (ctx) { target?.$willΞset?.(name,value,prev) };\n\t\t\tdata[name] = value;\n\t\t};\n\t\treturn;\n\t}\n\t\n\t$get_with_fallback(target){\n\t\t\n\t\tlet val = target[this.key];\n\t\tif (val === undefined && this.$fallback) {\n\t\t\t\n\t\t\treturn this.$fallback.call(target);\n\t\t};\n\t\treturn val;\n\t}\n\t\n\tget readableΦ(){\n\t\t\n\t\tif (!(this.$target)) {\n\t\t\t\n\t\t\tthrow \"cannot check for unbound field\";\n\t\t};\n\t\treturn OP.rights(this.$target,this) & OP.READ;\n\t}\n\t\n\t$bound(target,...params){\n\t\t\n\t\tlet f = Object.create(this);\n\t\tf.$target = target;\n\t\tf.$params = params;\n\t\treturn f;\n\t}\n\t\n\tget $fields(){\n\t\t\n\t\tif (this.$target) {\n\t\t\t\n\t\t\treturn this.$target.$fields;\n\t\t};\n\t}\n\t\n\tload(value,target){\n\t\t\n\t\tconsole.warn(`Field.load deprecated`);\n\t\treturn this.$load(value,target);\n\t}\n\t\n\t$load(value,target){\n\t\t\n\t\tlet key = this.key;\n\t\tlet track = this.$tracked;\n\t\t\n\t\tif (value !== undefined) {\n\t\t\t\n\t\t\tlet prev = track && target[key];\n\t\t\ttarget[key] = value;\n\t\t\t\n\t\t\tif (track && prev != value) {\n\t\t\t\t\n\t\t\t\tthis.$altered(value,prev,target);\n\t\t\t};\n\t\t};\n\t\treturn;\n\t}\n\t\n\t// Deserialize value into target\n\t$patch(value,target,stack){\n\t\t\n\t\treturn this.$load(value,target);\n\t}\n\t\n\t// Complex properties are awakened when needed\n\t/**\n\t@returns { any }\n\t*/\n\t$wake(target){\n\t\t\n\t\treturn true;\n\t}\n\t\n\t$serialize(target,into){\n\t\t\n\t\tlet raw = target[this.$prop][this.name];\n\t\tlet rich = this.$get(target);\n\t\treturn (this.embeddedΦ && rich?.$serialize) ? rich.$serialize(into) : raw;\n\t}\n\t\n\t/**\n\t\n\t\tChecks value against previous value. Returns undefined if\n\t\tvalues are equal, otherwise return the serialized value to\n\t\tpersist\n\t\t\n\t*/\n\t$diff(target,prev){\n\t\t\n\t\t// Hook into STACK.serializing somehow?\n\t\tlet plain = (target instanceof this.model) ? this.$serialize(this.$get(target),target) : target;\n\t\tlet same = compareShallow(prev,plain);\n\t\tif (same) {\n\t\t\t\n\t\t\treturn undefined;\n\t\t};\n\t\treturn plain;\n\t}\n\t\n\t// Load initial value for fresh objects\n\t$init(value,target){\n\t\t\n\t\t\n\t\tthis.$load(value,target);\n\t\treturn;\n\t}\n\t\n\t$altered(value,prev,target){\n\t\t\n\t\treturn;\n\t}\n\t\n\t$accepts(value,target,context){\n\t\t\n\t\treturn false;\n\t}\n\t\n\t[$setup$](){\n\t\t\n\t\treturn this;\n\t}\n\t\n\ttoString(){\n\t\t\n\t\treturn this.name;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPField');}\n}; globalThis.OPField = OPField;\n\nexport class OPPlainField extends OPField {\n\t\n\t\n\t$get(target){\n\t\t\n\t\treturn (target[this.key] ?? target[this.$prop][this.name]);\n\t}\n\t\n\t$sanitize(value){\n\t\t\n\t\treturn value;\n\t}\n\t\n\t$set(value,target,ctx){\n\t\t\n\t\tlet name = this.name;\n\t\tlet data = target[this.$prop];\n\t\tlet prev = data[name];\n\t\tlet plain = this.$sanitize(value);\n\t\t\n\t\t// compare?\n\t\tif (prev != plain) {\n\t\t\t\n\t\t\ttarget?.$willΞset?.(name,value);\n\t\t\tdata[name] = plain;\n\t\t\tthis.$altered(value,prev,target);\n\t\t};\n\t\t\n\t\treturn;\n\t}\n\t\n\t$patch(value,target,all){\n\t\t\n\t\treturn;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPPlainField');inheritClass$__(this);}\n}; globalThis.OPPlainField = OPPlainField;\n\nexport class OPRichField extends OPField {\n\t\n\t\n\tget richΦ(){\n\t\t\n\t\treturn true;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPRichField');inheritClass$__(this);}\n}; globalThis.OPRichField = OPRichField;\n\nlet EMBED = null;\n\nexport class Value {\n\t\n\tstatic embed(up,key,...rest){\n\t\t\n\t\tEMBED = [up,key];\n\t\treturn new this(...rest);\n\t}\n\t\n\tconstructor(data){\n\t\tlet embed;\n\t\t\n\t\tif (embed = EMBED) {\n\t\t\t\n\t\t\tEMBED = null;\n\t\t\t// should not be enumerable and ideally completely hidden from logging\n\t\t\tthis.$up = embed[0];\n\t\t\tthis.$key = String(embed[1]);\n\t\t\tthis.id = (\"\" + this.$up + `.` + this.$key);\n\t\t\t// EmbedState ?\n\t\t};\n\t}\n\t\n\t$changed(){\n\t\t\n\t\tif (this.$up) { this.$up.$changed(this.$field,this) };\n\t\treturn this;\n\t}\n\t\n\tget $field(){\n\t\t\n\t\treturn this.$up?.$shape[this.$key];\n\t}\n\t\n\tlog(...params){\n\t\t\n\t\treturn console.log((`%c ` + (this.$up.id) + `.` + this.$key),`color:green`,...params);\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Value');}\n};\n\nclass ΩOPObject {\n\t\n\t\n\t/**\n\t@returns { Field }\n\t*/\n\tαany(){\n\t\t\n\t\treturn new OPField;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'OPObject');}\n};\nextend$__(OPObject.prototype,ΩOPObject.prototype);\n;\n","dependencies":[],"map":{"version":3,"file":"any.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/fields/any.imba"],"sourcesContent":["import { getDeepDescriptor, compareShallow } from '../utils'\nimport { STACK } from '../stack'\nimport { R, W, D } from '../protocol'\n\nexport { STACK }\n\n###\nQ What should the standardised interface for patching data field values be?\nTODO Rename value.patch to value.$patch\n###\n\nglobal.OPFieldRegistry = new class OPFields < Array\n\n\tdef children-of type\n\t\tlet hits = []\n\n\t\tfor f in self when f.parent\n\t\t\tif let typ = (f.reftype or f.valuetype)\n\t\t\t\tif typ == type or typ.prototype isa type\n\t\t\t\t\thits.push(f)\n\t\treturn hits\n\n\tget $parent\n\t\tfilter do $1.parent\n\nexport global class OPField\n\n\t# Is this property required\n\trequired = no\n\n\t# Columntype in database\n\tpgtype = 'text'\n\n\t# Makes property observable\n\tobservable = no\n\n\t# Default value for property\n\tdefault = null\n\n\t# Disallow changing property after init\n\treadonly = no\n\n\t# Accessible on the server - hidden everywhere else\n\t# Call it internal instead?\n\thidden = no\n\n\t# Unchangeable after initial creation\n\timmutable = no\n\n\t# Field is generated from server / other data - no need to serialize from client\n\tgenerated = no\n\n\t# Field is unique per user - change name of this?\n\tpov = null\n\n\t# Field persists to localStorage\n\tlocal = no\n\n\t# Index this field in database\n\tindex = no\n\n\tvirtual = no\n\n\t# Field perssists to sessionStorage\n\tsession = no\n\n\t# Field is not in sweeping data-fetches\n\tlazy = no\n\n\t# Values have to be unique across instances of model?\n\tunique = no\n\n\tautoload = no\n\n\t$tracked = no\n\n\tactionable = no\n\n\t# grouping\n\tg = null\n\n\t# Should prefix these as internal\n\n\t# defaults to $plain\n\tdeclare $prop\\string\n\tdeclare model\n\tdeclare key\\symbol\n\tdeclare slot\\symbol\n\tdeclare name\\string\n\n\t# Target set for bound fields\n\tdeclare $target\n\n\tget $trace\n\t\t!!STACK.debug\n\n\tget $stack\n\t\tSTACK\n\n\tdef constructor type\n\t\tsuper\n\t\tself.$backlinks = null\n\t\tself.R = null\n\t\tself.W = null\n\t\tself.D = null\n\n\t\t# self.$acl = {r:0,w:0}\n\t\tself.args = Array.from($0)\n\t\tself.type = type if type\n\n\tget number?\n\t\tno\n\n\tget ref?\n\t\tno\n\n\tget action?\n\t\t!!actionable\n\n\tget rich?\n\t\tno\n\n\tget local?\n\t\tlocal or session\n\n\tget $path\n\t\tlet pre = $target and $target.$path\n\t\tpre ? `{pre}.{name}` : name\n\n\t# Only relevant for bound fields\n\tget $up\n\t\t$target\n\n\tget $root\n\t\t$up.$root\n\n\t# Return true if field needs to evaluate additional code when value changes\n\tget complex?\n\t\t!!$granted\n\n\t# Coerces value to serializable value\n\tdef $sanitize value, target\n\t\tif ref?\n\t\t\tif value isa Array\n\t\t\t\treturn value.map do ($1.id or $1)\n\t\t\treturn value ? (value.id or value) : null\n\t\treturn value\n\n\tdef $backlinked field\n\t\tself.$backlinks ??= new Set\n\t\tself.$backlinks.add(field)\n\n\tdef fallback cb\n\t\t$fallback = cb\n\t\tself\n\n\t# naming? role / elevate / promote / is  grant / becomes\n\tdef as roles\n\t\t$granted ||= 0\n\t\t$granted |= +roles\n\t\tyes\n\n\tdef guard\n\t\tyes\n\n\tdef $rule pairs\n\t\tfor own k,checks of pairs\n\t\t\tlet check = checks[0]\n\n\t\t\tif checks.length > 1\n\t\t\t\tthrow \"Multiple args to access rules not supported yet\"\n\n\t\t\tif typeof check == 'number' or (check isa OP.Role)\n\t\t\t\tself[k] |= +check\n\t\t\telse\n\t\t\t\tself[k] = check\n\n\t# can access field?\n\t# multiple params should identify that all has to be met?\n\tdef r roles\n\t\tif typeof roles == 'number' or (roles isa OP.Role)\n\t\t\tself.R |= +roles\n\t\telse\n\t\t\tself.R = roles\n\n\t# can edit field?\n\tdef w roles\n\t\tif typeof roles == 'number' or (roles isa OP.Role)\n\t\t\tself.W |= +roles\n\t\telse\n\t\t\tself.W = roles\n\n\tdef rw read, write = read\n\t\tr(read)\n\t\tw(write)\n\n\t# set executable rights\n\tdef x roles\n\t\tif typeof roles == 'number' or (roles isa OP.Role)\n\t\t\tself.X |= +roles\n\t\telse\n\t\t\tself.X = roles\n\n\tdef d roles\n\t\tif typeof roles == 'number' or (roles isa OP.Role)\n\t\t\tself.D |= +roles\n\t\telse\n\t\t\tself.D = roles\n\n\tdef rls\n\t\tyes\n\n\tdef ['is']\n\t\tyes\n\n\t# just for backwards compat\n\tget meta\n\t\tself\n\n\tset label val\n\t\t#label = val\n\n\tget label\n\t\tlet lbl = #label or name.humanize!\n\t\tif $target\n\t\t\tlbl = lbl.replace(/Item\\b/,$target.typeName or 'Item')\n\t\treturn lbl\n\n\tget valuetype\\any\n\t\t\tString\n\n\tget $stack\n\t\tSTACK\n\n\tget column?\n\t\tpgtype and !local and !session and !virtual\n\n\t# Run this field as an action\n\tdef run ctx = {}\n\t\tlet val = $get($target)\n\n\t\tif $action\n\t\t\treturn $action.apply($target,[])\n\t\telif callback\n\t\t\treturn callback.apply($target,[])\n\n\tdef $accessor\\this target, key, name, slot, context\n\n\t\tlet field = Object.create(self)\n\n\t\t# hack specifically for id?\n\t\tif name == 'id'\n\t\t\tif target != context and target.constructor.prototype == target\n\t\t\t\tcontext = target\n\n\t\tfield.model = context.constructor\n\t\tfield.name = name\n\t\tfield.key = key\n\t\tfield.$symbol = key\n\t\tfield.slot = slot\n\t\tfield.$prop = '$plain'\n\n\t\t# if we instead created a copy of this and cached it\n\t\t# we could reuse the same fields in several places\n\t\tcontext[slot] = field\n\n\t\tlet primitive = default..literal ?? undefined\n\n\t\tif default\n\n\t\t\t# Imba will change this to primitive - just for testing\n\t\t\tif typeof default.literal == 'number'\n\t\t\t\tdefault.sql = default.literal\n\t\t\t\t# field.model.prototype[key] = default.literal\n\n\t\tif field.pov\n\n\t\t\tlet pov = field.model.Pov.prototype\n\t\t\tlet desc = getDeepDescriptor(context,name)\n\t\t\tpov[`αα{name}`] = field\n\t\t\tObject.defineProperty(pov,name,desc)\n\n\t\t\tif primitive !== undefined\n\t\t\t\tpov[key] = primitive\n\n\t\t\t# should make different fields for the povs and pov combinations?\n\t\t\t# how do we map the localpov somewhere?\n\n\t\t\t# override the main property index\n\t\t\tif $web$\n\t\t\t\t# what if this changes after load? This would happen with login w/o refresh\n\t\t\t\t# Shouldnt be about count vs not? it makes sense for the toggle as well?\n\n\t\t\t\tlet gop = global.#op.pov\n\t\t\t\t# if !field.count\n\t\t\t\tObject.defineProperty(context,name,{\n\t\t\t\t\tget: do field.$get(this[gop or OP.agent] || this.$pov(gop or OP.agent),key)\n\t\t\t\t\tset: do field.$set($1,this[gop or OP.agent] || this.$pov(gop or OP.agent),key)\n\t\t\t\t})\n\n\t\t\t\t# FIXME not doing anything now\n\t\t\t\tif observable\n\t\t\t\t\timba.@observable.call([],pov,key)\n\n\t\t\telif $node$\n\t\t\t\tObject.defineProperty(context,name,{\n\t\t\t\t\tget: do field.$get(this.$pov(OP.agent),key)\n\t\t\t\t\tset: do field.$set($1,this.$pov(OP.agent),key)\n\t\t\t\t})\n\n\t\t\tcontext\n\n\t\t\t# if it is aggregated - change the main pointer to something else?\n\n\t\t# if $web$\n\t\t# \t# TODO Remove this - now using idb for this store as well?\n\t\t# \t# Not clear how this will work with pov etc\n\t\t# \t# let store = field.local ? imba.locals : (field.session ? imba.session : null)\n\t\tif field.local\n\t\t\tfield.$prop = '$localdata'\n\t\telif field.session\n\t\t\tfield.$prop = '$sessiondata'\n\n\t\tif !field.pov and observable\n\t\t\timba.@observable.call([],context,key)\n\n\t\t# add fallback as a nested accessor?\n\t\tif $fallback and !(self isa OPPlainField)\n\t\t\tconsole.warn \"Warning: in '{field.model.$name}' you are setting a fallback on the rich field '{name}'. Fallbacks on rich fields are not supported.\".yellow\n\n\t\tif $fallback\n\t\t\tlet getter = field.$get\n\t\t\tfield.$get = do(target)\n\t\t\t\t# temporary hack\n\t\t\t\tlet val = getter.call(this,target)\n\t\t\t\tif val is undefined and $fallback and !STACK.serializing?\n\t\t\t\t\treturn $fallback.call(target)\n\t\t\t\tval\n\n\t\tfield.#setup!\n\t\tOPFieldRegistry.push(field)\n\t\treturn field\n\n\tdef $set value, target\n\t\tif $web$\n\t\t\tif !target.virtual? and !local and !session and !target.local?\n\t\t\t\treturn unless OP.rights(target,self) & W\n\t\t$change(value,target)\n\n\tdef $change value, target\n\t\tlet raw = target[key]\n\t\treturn if raw === value\n\n\t\t$load(value,target)\n\t\t# we always call $changed on the model\n\t\ttarget.$changed(name,value,self)\n\n\tdef $log target, ...params\n\t\tconsole.log(`%c {target.id}.{name}`,`color:lightblue`,...params)\n\n\tdef $warn target, ...params\n\t\tconsole.warn(`%c {target.id}.{name}`,`color:lightblue`,...params)\n\n\tdef $get target\n\t\ttarget[$prop][name]\n\n\tdef $get-plain target\n\t\ttarget.$plain[name]\n\n\tdef $set-plain value, target, ctx\n\t\t# Is this every called when patching?\n\t\tlet name = name\n\t\tlet data = target[$prop]\n\t\tlet prev = data[name]\n\t\tif prev != value\n\t\t\ttarget..$will-set(name,value,prev) if ctx\n\t\t\tdata[name] = value\n\t\treturn\n\n\tdef $get_with_fallback target\n\t\tlet val = target[key]\n\t\tif val === undefined and $fallback\n\t\t\treturn $fallback.call(target)\n\t\treturn val\n\n\tget readable?\n\t\tif !$target\n\t\t\tthrow \"cannot check for unbound field\"\n\t\treturn OP.rights($target,self) & OP.READ\n\n\tdef $bound target,...params\n\t\tlet f = Object.create(self)\n\t\tf.$target = target\n\t\tf.$params = params\n\t\treturn f\n\n\tget $fields\n\t\tif $target\n\t\t\t$target.$fields\n\n\tdef load value, target\n\t\tconsole.warn `Field.load deprecated`\n\t\t$load(value,target)\n\n\tdef $load value, target\n\t\tlet key = key\n\t\tlet track = $tracked\n\n\t\tunless value === undefined\n\t\t\tlet prev = track and target[key]\n\t\t\ttarget[key] = value\n\n\t\t\tif track and prev != value\n\t\t\t\t$altered(value,prev,target)\n\t\treturn\n\n\t# Deserialize value into target\n\tdef $patch value, target, stack\n\t\t$load(value,target)\n\n\t# Complex properties are awakened when needed\n\tdef $wake\\any target\n\t\tyes\n\n\tdef $serialize target, into\n\t\tlet raw = target[$prop][name]\n\t\tlet rich = $get(target)\n\t\tembedded? and rich..$serialize ? rich.$serialize(into) : raw\n\n\t###\n\tChecks value against previous value. Returns undefined if\n\tvalues are equal, otherwise return the serialized value to\n\tpersist\n\t###\n\tdef $diff target, prev\n\t\t# Hook into STACK.serializing somehow?\n\t\tlet plain = target isa model ? $serialize($get(target),target) : target\n\t\tlet same = compareShallow(prev,plain)\n\t\tif same\n\t\t\treturn undefined\n\t\treturn plain\n\n\t# Load initial value for fresh objects\n\tdef $init value, target\n\n\t\tself.$load(value,target)\n\t\treturn\n\n\tdef $altered value, prev, target\n\t\treturn\n\n\tdef $accepts value, target, context\n\t\tno\n\n\tdef #setup\n\t\tself\n\n\tdef toString\n\t\tname\n\nexport global class OPPlainField < OPField\n\n\tdef $get target\n\t\ttarget[key] ?? target[$prop][name]\n\n\tdef $sanitize value\n\t\tvalue\n\n\tdef $set value,target,ctx\n\t\tlet name = name\n\t\tlet data = target[$prop]\n\t\tlet prev = data[name]\n\t\tlet plain = $sanitize(value)\n\n\t\t# compare?\n\t\tif prev != plain\n\t\t\ttarget..$will-set(name,value)\n\t\t\tdata[name] = plain\n\t\t\t$altered(value,prev,target)\n\n\t\treturn\n\n\tdef $patch value,target,all\n\t\treturn\n\nexport global class OPRichField < OPField\n\n\tget rich?\n\t\tyes\n\nlet EMBED = null\n\nexport class Value\n\tstatic def embed up,key,...rest\n\t\tEMBED = [up,key]\n\t\tnew self(...rest)\n\n\tdef constructor data\n\t\tif let embed = EMBED\n\t\t\tEMBED = null\n\t\t\t# should not be enumerable and ideally completely hidden from logging\n\t\t\tself.$up = embed[0]\n\t\t\tself.$key = String(embed[1])\n\t\t\tself.id = `{$up}.{$key}`\n\t\t\t# EmbedState ?\n\n\tdef $changed\n\t\t$up.$changed($field,self) if $up\n\t\treturn self\n\n\tget $field\n\t\t$up..$shape[$key]\n\n\tdef log ...params\n\t\tconsole.log `%c {$up.id}.{$key}`,`color:green`,...params\n\nextend class OPObject\n\n\tdef @any\\Field\n\t\tnew OPField\n"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}
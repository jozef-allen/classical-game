{"js":{"code":"function iter$__(a){ let v; return a ? ((v=a.toIterable) ? v.call(a) : a) : a; };;\nfunction defineName$__(cls,name){\n\tObject.defineProperty(cls,\"name\",{value:name,configurable:true});\n};;\nfunction inheritClass$__(cls){\n\tObject.getPrototypeOf(cls.prototype).constructor?.inherited?.(cls);\n};\nconst $__initor__$ = Symbol.for('#__initor__'), $__inited__$ = Symbol.for('#__inited__'), $__hooks__$ = Symbol.for('#__hooks__'), $__init__$ = Symbol.for('#__init__'), $__patch__$ = Symbol.for('#__patch__');\nvar $1 = Symbol();\n\n/*body*/\nimport {register} from '../msgpack';\nimport '../protocol';\n/*\nShould be moved to OP as rich embedded object\nAlso should add tests for this\n*/\n\n\nexport function concat(...buffers){\n\t\n\tlet size = 0;\n\tif (buffers.length == 1) {\n\t\t\n\t\treturn buffers[0];\n\t};\n\t\n\tfor (let $2 = 0, $3 = iter$__(buffers), $4 = $3.length; $2 < $4; $2++) {\n\t\tlet buf = $3[$2];\n\t\tsize += buf.length;\n\t};\n\t\n\tlet offset = 0;\n\tlet merged = new Uint8Array(size);\n\tfor (let i = 0, $5 = iter$__(buffers), $6 = $5.length; i < $6; i++) {\n\t\tlet buf = $5[i];\n\t\tmerged.set(buf,offset);\n\t\toffset += buf.length;\n\t};\n\treturn merged;\n};\n\nexport class StreamMissingRangeError extends Error {\n\t\n\tconstructor(start,end){\n\t\t\n\t\tsuper(...arguments);\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis;\n\t\tthis[$__initor__$]===$1 && (this[$__hooks__$]&&this[$__hooks__$].inited(this),this[$__inited__$] && this[$__inited__$]());\n\t}\n\tstatic {\n\t\tthis.prototype[$__initor__$] = $1;defineName$__(this,'StreamMissingRangeError');inheritClass$__(this);}\n};\n\nconst TEXTENCODER = new TextEncoder;\n\nclass Fragments {\n\t\n\tconstructor(buffer){\n\t\t\n\t\tthis.buffer = buffer;\n\t\tthis.offsets = {};\n\t\tthis.chunks = [];\n\t\tthis.holes = null;\n\t\t/**@type {[any,number,number]}*/ this.last = null;\n\t\t\n\t\tthis;\n\t}\n\t\n\t/**\n\t@param {number} offset\n\t*/\n\tadd(chunk,offset){\n\t\t\n\t\tlet len = chunk.length;\n\t\t\n\t\tconsole.log('StreamFragments.add',chunk,offset);\n\t\t\n\t\tif (!(this.last)) {\n\t\t\t\n\t\t\tthis.chunks.push(this.last = [chunk,offset,offset + len]);\n\t\t\treturn new StreamMissingRangeError(this.buffer.size,offset - 1);\n\t\t};\n\t\t\n\t\tlet currOffset = this.last[1];\n\t\tlet nextOffset = this.last[2];\n\t\t// ensure that chunks are always sorted by offset\n\t\t// we can just append to the previous chunk here\n\t\t// make sure that we deal with errors\n\t\t\n\t\tif (offset == nextOffset) {\n\t\t\t\n\t\t\t// we can happily append!\n\t\t\tthis.last[0] = concat(this.last[0],chunk);\n\t\t\tthis.last[2] += len;\n\t\t\treturn true;\n\t\t} else if (offset > nextOffset) {\n\t\t\t\n\t\t\t// there is now another hole!\n\t\t\tthis.chunks.push(this.last = [chunk,offset,offset + len]);\n\t\t\treturn new StreamMissingRangeError(nextOffset,offset - 1);\n\t\t} else if (offset == currOffset) {\n\t\t\t\n\t\t\tconsole.log(\"already received this fragment\",offset,len,this.last);\n\t\t\t// we're re-receiving the same parts. Nothing to see here\n\t\t\tif ((offset + len) > nextOffset) {\n\t\t\t\t\n\t\t\t\tconsole.log(\"got a longer fragment now\");\n\t\t\t};\n\t\t\treturn true;\n\t\t} else {\n\t\t\t\n\t\t\tconsole.log(\"fragment cannot even be handled\");\n\t\t\treturn true;\n\t\t};\n\t}\n\t\n\tpull(offset){\n\t\t\n\t\tlet first = this.chunks[0];\n\t\tif (first) {\n\t\t\t\n\t\t\t\n\t\t\tif (first[1] == offset) {\n\t\t\t\t\n\t\t\t\treturn this.chunks.shift[0];\n\t\t\t} else if (first[2] <= offset) {\n\t\t\t\t\n\t\t\t\tthis.chunks.shift();\n\t\t\t\treturn this.pull(offset);\n\t\t\t};\n\t\t\t// what if we have already filled? parts?\n\t\t};\n\t\treturn null;\n\t}\n\t\n\tget length(){\n\t\t\n\t\treturn this.chunks.length;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'Fragments');}\n};\n\nfunction computeHash(hash,bytes,to = 0){\n\tvar $7;\n\t\n\tlet mod = 1000000007;\n\tlet base = 257;\n\t$7 = 0; for (let byte of iter$__(bytes)){\n\t\tlet i = $7++;\n\t\tif (to && i == to) { break; };\n\t\thash = (hash * base + byte) % mod;\n\t};\n\treturn hash;\n};\n\nexport class BinaryChunk extends OPStruct {\n\t\n\t/**\n\t@returns { number }\n\t*/\n\tget offset(){\n\t\treturn this[0];\n\t}\n\t/**\n\t@returns { Uint8Array }\n\t*/\n\tget data(){\n\t\treturn this[1];\n\t}\n\t/**\n\t@returns { number }\n\t*/\n\tget hash(){\n\t\treturn this[2];\n\t}\n\t\n\tget byteStart(){\n\t\t\n\t\treturn this.offset;\n\t}\n\t\n\tget byteEnd(){\n\t\t\n\t\treturn this.offset + this.data.byteLength;\n\t}\n\t\n\tget byteLength(){\n\t\t\n\t\treturn this.data.byteLength;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'BinaryChunk');inheritClass$__(this);}\n}; globalThis.BinaryChunk = BinaryChunk;\n\n/*\nLike a regular binary chunk but meant to actually\noverwrite bytes at an offset. This would change later\nhashes so it is not apparent how it could work while\ncontinuing to append data to the streams later.\nBut need to support it for the usecase of rewriting\naudio metadata now.\n*/\n\nexport class BinaryPatch extends OPStruct {\n\t\n\t/**\n\t@returns { number }\n\t*/\n\tget offset(){\n\t\treturn this[0];\n\t}\n\t/**\n\t@returns { Uint8Array }\n\t*/\n\tget data(){\n\t\treturn this[1];\n\t}\n\t/**\n\t@returns { number }\n\t*/\n\tget hash(){\n\t\treturn this[2];\n\t}\n\t\n\tget byteStart(){\n\t\t\n\t\treturn this.offset;\n\t}\n\t\n\tget byteEnd(){\n\t\t\n\t\treturn this.offset + this.data.byteLength;\n\t}\n\t\n\tget byteLength(){\n\t\t\n\t\treturn this.data.byteLength;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'BinaryPatch');inheritClass$__(this);}\n}; globalThis.BinaryPatch = BinaryPatch;\n\nexport class BinaryState extends OPStruct {\n\t\n\tget offset(){\n\t\treturn this[0];\n\t}\n\tget hash(){\n\t\treturn this[1];\n\t}\n\t\n\tget byteLength(){\n\t\t\n\t\treturn this.offset;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'BinaryState');inheritClass$__(this);}\n}; globalThis.BinaryState = BinaryState;\n\nexport class BinaryChunkRequest extends OPStruct {\n\t\n\tget offset(){\n\t\treturn this[0];\n\t}\n\t/**\n\t@returns { number }\n\t*/\n\tget end(){\n\t\treturn this[1];\n\t}\n\tget hash(){\n\t\treturn this[2];\n\t}\n\t\n\tget byteStart(){\n\t\t\n\t\treturn this.offset;\n\t}\n\t\n\tget byteEnd(){\n\t\t\n\t\treturn this.end;\n\t}\n\t\n\tget byteLength(){\n\t\t\n\t\treturn this.byteEnd - this.byteStart;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'BinaryChunkRequest');inheritClass$__(this);}\n}; globalThis.BinaryChunkRequest = BinaryChunkRequest;\n\n/*\n\nRepresents the raw binary buffer for a cast.\nHas no understanding of the encoded data, but\nhas helper methods for encoding/decoding to/from\nmsgpack.\n\nWhen adding chunks to the buffer at wrong offsets\nit will also create and store these fragments, while\nexposing details about missing ranges etc.\n\nThis inner part should not at all know about msgpack?\n\nCurrently feels like a pretty chaotic mix between an immutable append-only\nstream and a stream that can be changed / patched - but not in an orderly fashion.\n\nImplement in typescript instead?\n\n*/\n\nexport class BinaryStream {\n\t[$__patch__$]($$ = {},fields = true){\n\t\tvar $8;\n\t\t($8 = $$.buffer) !== undefined && (this.buffer = $8);\n\t\t($8 = $$.readyState) !== undefined && (this.readyState = $8);\n\t\t\n\t}\n\t[$__init__$]($$ = null,deep = true,fields = true){\n\t\tthis.buffer = $$ ? $$.buffer : undefined;\n\t\tthis.readyState = $$ ? $$.readyState : undefined;\n\t\t\n\t}\n\tconstructor(state = {size: 0,hash: 0}){\n\t\tthis[$__init__$]();\n\t\t/*\n\t\t\t\tWe currently fill the buffer with zeroes if inited at a late state.\n\t\t\t\tThis uses a lot of memory. Makes more sense with a compressed structure\n\t\t\t\t*/\n\t\t\n\t\tthis.buffer = new Uint8Array(state.size || 0);\n\t\tthis.readyState = 0;\n\t\tthis.fragments = new Fragments(this);\n\t\tthis.view = this.buffer;\n\t\tthis.base = 257;\n\t\tthis.mod = 1000000007;\n\t\tthis.states = [state];\n\t\tthis.state = state;\n\t\tthis.startState = state;\n\t\t// If startsize is not 0 - add a Hole/MissingRange thing\n\t\tthis;\n\t}\n\t\n\tget hash(){\n\t\t\n\t\treturn this.state.hash;\n\t}\n\t\n\tget size(){\n\t\t\n\t\treturn this.state.size;\n\t}\n\t\n\tget byteLength(){\n\t\t\n\t\treturn this.state.size;\n\t}\n\t\n\t[Symbol.iterator](){\n\t\t\n\t\treturn this.view[Symbol.iterator]();\n\t}\n\t\n\tjoin(...params){\n\t\t\n\t\treturn this.view.join(...params);\n\t}\n\t\n\tstateAtOffset(offset){\n\t\t\n\t\t// find the closest hash we already know\n\t\t\n\t\tlet closest = this.states.find(function(_0) { return _0.size <= offset; });\n\t\tlet hash = closest.hash;\n\t\tlet pos = closest.size;\n\t\t\n\t\tif (pos == offset) {\n\t\t\t\n\t\t\treturn closest;\n\t\t};\n\t\t\n\t\t// just use computeHash instead?\n\t\twhile (pos < offset){\n\t\t\t\n\t\t\tlet byte = this.buffer[pos++];\n\t\t\thash = (hash * this.base + byte) % this.mod;\n\t\t};\n\t\t\n\t\tlet state = {size: offset,hash: hash};\n\t\tthis.states.unshift(state);\n\t\treturn state;\n\t}\n\t\n\thashAtOffset(offset){\n\t\t\n\t\treturn this.stateAtOffset(offset).hash;\n\t}\n\t\n\tresize(size){\n\t\t\n\t\tlet prev = this.buffer;\n\t\tif (this.buffer.length < size) {\n\t\t\t\n\t\t\tthis.buffer = new Uint8Array(size);\n\t\t\tthis.buffer.set(prev,0);\n\t\t};\n\t\treturn this.buffer;\n\t}\n\t\n\t/**\n\t@param {BinaryPatch} chunk\n\t*/\n\tpatch(chunk){\n\t\t\n\t\treturn this.set(chunk.data,chunk.byteStart);\n\t}\n\t\n\t/**\n\t@param {Uint8Array} chunk\n\t*/\n\tset(chunk,offset){\n\t\t\n\t\tlet chunkSize = chunk.length;\n\t\tif ((offset + chunkSize) >= this.buffer.length) {\n\t\t\t\n\t\t\t// add 8kb every time\n\t\t\tthis.resize(offset + chunkSize + 1024 * 8);\n\t\t};\n\t\t\n\t\tthis.buffer.set(chunk,offset);\n\t\t\n\t\tlet newsize = Math.max(this.byteLength,offset + chunkSize);\n\t\tthis.state = this.stateAtOffset(newsize);\n\t\tthis.view = new Uint8Array(this.buffer.buffer,0,this.size);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t@param {BinaryChunk} chunk\n\t*/\n\tload(chunk){\n\t\t\n\t\t// if chunk isa BinaryChunk\n\t\t// at = chunk.offset\n\t\t// chunk = chunk.data\n\t\t\n\t\tlet overlap = this.byteLength - chunk.offset;\n\t\t\n\t\tif (overlap < 0) {\n\t\t\t\n\t\t\treturn BinaryChunkRequest.of(this.byteLength,chunk.byteEnd);\n\t\t};\n\t\t\n\t\tif (overlap == 0) {\n\t\t\t\n\t\t\t// check hash?\n\t\t\tthis.set(chunk.data,chunk.byteStart);\n\t\t} else {\n\t\t\t\n\t\t\tlet old = this.write(chunk.offset,chunk.data,chunk.hash);\n\t\t\tconsole.warn('trying to load with overlap!',chunk,old);\n\t\t};\n\t\t// see if we are repairing etc\n\t\t// self.set(chunk,at)\n\t\treturn this;\n\t}\n\t\n\t// write a binary chunk\n\t/**\n\t@param {(Uint8Array|ArrayBuffer|string)} chunk\n\t*/\n\twrite(pos,chunk,hash = 0){\n\t\t\n\t\tconsole.log('writing!!',pos,chunk,hash,this.size);\n\t\treturn this.append(chunk,{size: pos,hash: hash});\n\t}\n\t\n\t/**\n\t@param {(Uint8Array|ArrayBuffer|string)} chunk\n\t*/\n\tappend(chunk,at = {size: 0,hash: 0}){\n\t\t\n\t\tif (typeof chunk == 'string') {\n\t\t\t\n\t\t\tchunk = TEXTENCODER.encode(chunk);\n\t\t};\n\t\t\n\t\tif (chunk instanceof ArrayBuffer) {\n\t\t\t\n\t\t\tchunk = new Uint8Array(chunk);\n\t\t};\n\t\t\n\t\tif (chunk instanceof Array) {\n\t\t\t\n\t\t\tchunk = new Uint8Array(chunk);\n\t\t};\n\t\t\n\t\tlet before = this.state;\n\t\tlet overlap = this.size - at.size;\n\t\tlet data = chunk;\n\t\tlet chunkStart = at.size;\n\t\tlet chunkEnd = at.size + data.byteLength;\n\t\t\n\t\tif (overlap > 0) {\n\t\t\t\n\t\t\tif (computeHash(at.hash,chunk,overlap) == this.hash) {\n\t\t\t\t\n\t\t\t\tdata = data.slice(overlap);\n\t\t\t\toverlap = 0;\n\t\t\t\tat = this.state;\n\t\t\t};\n\t\t};\n\t\t\n\t\tif (overlap < 0) {\n\t\t\t\n\t\t\t// missing data before\n\t\t\t// remember how much I have missed?\n\t\t\treturn BinaryChunkRequest.of(this.byteLength,chunkEnd);\n\t\t};\n\t\t\n\t\tif (!(overlap) && at.hash == this.hash) {\n\t\t\t\n\t\t\t\n\t\t\tthis.set(data,at.size);\n\t\t\treturn BinaryChunk.of(at.size,data,at.hash);\n\t\t};\n\t\t\n\t\treturn null;\n\t}\n\t\n\trepair(){\n\t\t\n\t\tlet end = this.size;\n\t\tlet chunk = this.fragments.pull(end);\n\t\tif (chunk) {\n\t\t\t\n\t\t\t\n\t\t\treturn this.add(chunk,end);\n\t\t};\n\t}\n\t\n\ttrim(end){\n\t\t\n\t\tif (this.byteLength > end) {\n\t\t\t\n\t\t\tconsole.log('trim the stream!',end,this.byteLength);\n\t\t\tthis.states = this.states.filter(function(_0) { return _0.size <= end; });\n\t\t\t\n\t\t\t// should just change the size param and let the buffer overwrite\n\t\t\tthis.buffer = this.buffer.slice(0,end);\n\t\t\tthis.state = this.stateAtOffset(end);\n\t\t\tthis.view = new Uint8Array(this.buffer.buffer,0,end);\n\t\t\t// self.fragments = new StreamFragments(self)\n\t\t};\n\t\treturn this;\n\t}\n\t\n\tget length(){\n\t\t\n\t\treturn this.size;\n\t}\n\t\n\t/**\n\t@returns { Uint8Array }\n\t*/\n\tslice(start,end){\n\t\t\n\t\treturn end ? this.buffer.slice(start,end) : this.buffer.slice(start,this.size);\n\t}\n\t\n\t/**\n\t@returns { BinaryChunk }\n\t*/\n\tchunk(offset,end){\n\t\t\n\t\tlet buf = this.slice(offset,end);\n\t\treturn BinaryChunk.of(offset,buf,this.hashAtOffset(offset));\n\t}\n\t\n\tget raw(){\n\t\t\n\t\treturn this.buffer;\n\t}\n\tstatic {\n\t\tdefineName$__(this,'BinaryStream');}\n};\n","dependencies":[],"map":{"version":3,"file":"binarystream.js","sourceRoot":"","sources":["/Users/sindre/repos/scrimba/op/src/fields/binarystream.imba"],"sourcesContent":["import {register} from '../msgpack'\nimport '../protocol'\n###\nShould be moved to OP as rich embedded object\nAlso should add tests for this\n###\n\nexport def concat ...buffers\n\tlet size = 0\n\tif buffers.length == 1\n\t\treturn buffers[0]\n\n\tfor buf in buffers\n\t\tsize += buf.length\n\n\tlet offset = 0\n\tlet merged = new Uint8Array(size)\n\tfor buf,i in buffers\n\t\tmerged.set(buf,offset)\n\t\toffset += buf.length\n\treturn merged\n\nexport class StreamMissingRangeError < Error\n\tdef constructor start,end\n\t\tsuper\n\t\tself.start = start\n\t\tself.end = end\n\t\tself\n\nconst TEXTENCODER = new TextEncoder\n\nclass Fragments\n\tdef constructor buffer\n\t\tself.buffer = buffer\n\t\tself.offsets = {}\n\t\tself.chunks = []\n\t\tself.holes = null\n\t\tself.last\\[any,number,number] = null\n\n\t\tself\n\n\tdef add chunk, offset\\number\n\t\tlet len = chunk.length\n\n\t\tconsole.log 'StreamFragments.add',chunk,offset\n\n\t\tunless self.last\n\t\t\tself.chunks.push(self.last = [chunk,offset,offset + len])\n\t\t\treturn new StreamMissingRangeError(self.buffer.size,offset - 1)\n\n\t\tlet currOffset = self.last[1]\n\t\tlet nextOffset = self.last[2]\n\t\t# ensure that chunks are always sorted by offset\n\t\t# we can just append to the previous chunk here\n\t\t# make sure that we deal with errors\n\n\t\tif offset == nextOffset\n\t\t\t# we can happily append!\n\t\t\tself.last[0] = concat(self.last[0],chunk)\n\t\t\tself.last[2] += len\n\t\t\treturn true\n\n\t\telif offset > nextOffset\n\t\t\t# there is now another hole!\n\t\t\tself.chunks.push(self.last = [chunk,offset,offset + len])\n\t\t\treturn new StreamMissingRangeError(nextOffset,offset - 1)\n\n\t\telif offset == currOffset\n\t\t\tconsole.log \"already received this fragment\",offset,len,self.last\n\t\t\t# we're re-receiving the same parts. Nothing to see here\n\t\t\tif (offset + len) > nextOffset\n\t\t\t\tconsole.log \"got a longer fragment now\"\n\t\t\treturn true\n\t\telse\n\t\t\tconsole.log \"fragment cannot even be handled\"\n\t\t\treturn true\n\n\tdef pull offset\n\t\tlet first = self.chunks[0]\n\t\tif first\n\n\t\t\tif first[1] == offset\n\t\t\t\treturn self.chunks.shift[0]\n\t\t\telif first[2] <= offset\n\t\t\t\tself.chunks.shift!\n\t\t\t\treturn self.pull(offset)\n\t\t\t# what if we have already filled? parts?\n\t\treturn null\n\n\tget length\n\t\tself.chunks.length\n\ndef computeHash hash,bytes,to = 0\n\tlet mod = 1000000007\n\tlet base = 257\n\tfor byte,i of bytes\n\t\tbreak if to and i == to\n\t\thash = (hash * base + byte) % mod\n\treturn hash\n\nexport global class BinaryChunk < OPStruct\n\tget offset\\number do self[0]\n\tget data\\Uint8Array do self[1]\n\tget hash\\number do self[2]\n\n\tget byteStart\n\t\toffset\n\n\tget byteEnd\n\t\toffset + data.byteLength\n\n\tget byteLength\n\t\tdata.byteLength\n\n###\nLike a regular binary chunk but meant to actually\noverwrite bytes at an offset. This would change later\nhashes so it is not apparent how it could work while\ncontinuing to append data to the streams later.\nBut need to support it for the usecase of rewriting\naudio metadata now.\n###\nexport global class BinaryPatch < OPStruct\n\tget offset\\number do self[0]\n\tget data\\Uint8Array do self[1]\n\tget hash\\number do self[2]\n\n\tget byteStart\n\t\toffset\n\n\tget byteEnd\n\t\toffset + data.byteLength\n\n\tget byteLength\n\t\tdata.byteLength\n\nexport global class BinaryState < OPStruct\n\tget offset do self[0]\n\tget hash do self[1]\n\n\tget byteLength\n\t\toffset\n\nexport global class BinaryChunkRequest < OPStruct\n\tget offset do self[0]\n\tget end\\number do self[1]\n\tget hash do self[2]\n\n\tget byteStart\n\t\toffset\n\n\tget byteEnd\n\t\tend\n\n\tget byteLength\n\t\tbyteEnd - byteStart\n\n###\n\nRepresents the raw binary buffer for a cast.\nHas no understanding of the encoded data, but\nhas helper methods for encoding/decoding to/from\nmsgpack.\n\nWhen adding chunks to the buffer at wrong offsets\nit will also create and store these fragments, while\nexposing details about missing ranges etc.\n\nThis inner part should not at all know about msgpack?\n\nCurrently feels like a pretty chaotic mix between an immutable append-only\nstream and a stream that can be changed / patched - but not in an orderly fashion.\n\nImplement in typescript instead?\n\n###\nexport class BinaryStream\n\n\tprop buffer\\Uint8Array\n\tprop readyState\n\n\tdef constructor state = {size: 0, hash: 0}\n\t\t###\n\t\tWe currently fill the buffer with zeroes if inited at a late state.\n\t\tThis uses a lot of memory. Makes more sense with a compressed structure\n\t\t###\n\t\tself.buffer = new Uint8Array(state.size or 0)\n\t\tself.readyState = 0\n\t\tself.fragments = new Fragments(self)\n\t\tself.view = self.buffer\n\t\tself.base = 257\n\t\tself.mod = 1000000007\n\t\tself.states = [state]\n\t\tself.state = state\n\t\tself.startState = state\n\t\t// If startsize is not 0 - add a Hole/MissingRange thing\n\t\tself\n\n\tget hash\n\t\tstate.hash\n\n\tget size\n\t\tstate.size\n\n\tget byteLength\n\t\tstate.size\n\n\tdef [Symbol.iterator]\n\t\tview[Symbol.iterator]()\n\n\tdef join ...params\n\t\tview.join(...params)\n\n\tdef stateAtOffset offset\n\t\t# find the closest hash we already know\n\n\t\tlet closest = states.find(do $1.size <= offset )\n\t\tlet hash = closest.hash\n\t\tlet pos = closest.size\n\n\t\tif pos == offset\n\t\t\treturn closest\n\n\t\t# just use computeHash instead?\n\t\twhile pos < offset\n\t\t\tlet byte = buffer[pos++]\n\t\t\thash = (hash * this.base + byte) % this.mod\n\n\t\tlet state = {size:offset,hash:hash}\n\t\tstates.unshift(state)\n\t\treturn state\n\n\tdef hashAtOffset offset\n\t\tstateAtOffset(offset).hash\n\n\tdef resize size\n\t\tlet prev = self.buffer\n\t\tif self.buffer.length < size\n\t\t\tself.buffer = new Uint8Array(size)\n\t\t\tself.buffer.set(prev,0)\n\t\treturn self.buffer\n\n\tdef patch chunk\\BinaryPatch\n\t\tself.set(chunk.data,chunk.byteStart)\n\n\tdef set chunk\\Uint8Array, offset\n\t\tlet chunkSize = chunk.length\n\t\tif (offset + chunkSize) >= self.buffer.length\n\t\t\t# add 8kb every time\n\t\t\tself.resize(offset + chunkSize + 1024 * 8)\n\n\t\tself.buffer.set(chunk,offset)\n\n\t\tlet newsize = Math.max(byteLength,offset + chunkSize)\n\t\tself.state = stateAtOffset(newsize)\n\t\tself.view = new Uint8Array(self.buffer.buffer,0,self.size)\n\t\treturn self\n\n\tdef load chunk\\BinaryChunk\n\t\t# if chunk isa BinaryChunk\n\t\t#\tat = chunk.offset\n\t\t#\tchunk = chunk.data\n\n\t\tlet overlap = byteLength - chunk.offset\n\n\t\tif overlap < 0\n\t\t\treturn BinaryChunkRequest.of(byteLength,chunk.byteEnd)\n\n\t\tif overlap == 0\n\t\t\t# check hash?\n\t\t\tself.set(chunk.data,chunk.byteStart)\n\n\t\telse\n\t\t\tlet old = write(chunk.offset,chunk.data,chunk.hash)\n\t\t\tconsole.warn 'trying to load with overlap!',chunk,old\n\t\t# see if we are repairing etc\n\t\t# self.set(chunk,at)\n\t\tself\n\n\t# write a binary chunk\n\tdef write pos, chunk\\(Uint8Array|ArrayBuffer|string), hash = 0\n\t\tconsole.log 'writing!!',pos,chunk,hash,size\n\t\tappend(chunk,{size: pos, hash: hash})\n\n\tdef append chunk\\(Uint8Array|ArrayBuffer|string), at = {size:0,hash:0}\n\t\tif typeof chunk == 'string'\n\t\t\tchunk = TEXTENCODER.encode(chunk)\n\n\t\tif chunk isa ArrayBuffer\n\t\t\tchunk = new Uint8Array(chunk)\n\n\t\tif chunk isa Array\n\t\t\tchunk = new Uint8Array(chunk)\n\n\t\tlet before = state\n\t\tlet overlap = size - at.size\n\t\tlet data\\Uint8Array = chunk\n\t\tlet chunkStart = at.size\n\t\tlet chunkEnd = at.size + data.byteLength\n\n\t\tif overlap > 0\n\t\t\tif computeHash(at.hash,chunk,overlap) == hash\n\t\t\t\tdata = data.slice(overlap)\n\t\t\t\toverlap = 0\n\t\t\t\tat = state\n\n\t\tif overlap < 0\n\t\t\t# missing data before\n\t\t\t# remember how much I have missed?\n\t\t\treturn BinaryChunkRequest.of(byteLength,chunkEnd)\n\n\t\tif !overlap and at.hash == hash\n\n\t\t\tself.set(data,at.size)\n\t\t\treturn BinaryChunk.of(at.size,data,at.hash)\n\n\t\treturn null\n\n\tdef repair\n\t\tlet end = self.size\n\t\tlet chunk = self.fragments.pull(end)\n\t\tif chunk\n\n\t\t\tself.add(chunk,end)\n\n\tdef trim end\n\t\tif byteLength > end\n\t\t\tconsole.log 'trim the stream!',end,self.byteLength\n\t\t\tstates = states.filter(do $1.size <= end )\n\n\t\t\t# should just change the size param and let the buffer overwrite\n\t\t\tself.buffer = self.buffer.slice(0,end)\n\t\t\tself.state = stateAtOffset(end)\n\t\t\tself.view = new Uint8Array(self.buffer.buffer,0,end)\n\t\t\t# self.fragments = new StreamFragments(self)\n\t\tself\n\n\tget length\n\t\tself.size\n\n\tdef slice\\Uint8Array start,end\n\t\tend ? self.buffer.slice(start,end) : self.buffer.slice(start,self.size)\n\n\tdef chunk\\BinaryChunk offset, end\n\t\tlet buf = slice(offset,end)\n\t\tBinaryChunk.of(offset,buf,hashAtOffset(offset))\n\n\tget raw\n\t\tself.buffer"],"names":[],"mappings":"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"}},"css":{"code":""},"warnings":[],"errors":[]}